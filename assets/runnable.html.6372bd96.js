import{_ as c}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as m,c as p,d as a,a as e,w as n,f as r,r as o,b as i}from"./app.b80cbaa0.js";const v="/psp_pages/assets/Single_vs_MultiThreaded_Approaches.3d0beeb7.jpg",h="/psp_pages/assets/threads_process_end.c389d466.png",b={},g=e("h1",{id:"_3-1-clases-java-para-la-gestion-de-hilos",tabindex:"-1"},"3.1. Clases Java para la gesti\xF3n de hilos",-1),q={class:"table-of-contents"},f=i("3.1.1. El interfaz Runnable"),y=i("Clase Java que implementa la interfaz Runnable"),j=i("Implementaci\xF3n con clase an\xF3nima de la interfaz Runnable"),T=i("Implementaci\xF3n de Runnable a trav\xE9s de una expresi\xF3n Lambda"),x=i("Llamar al m\xE9todo run de una clase que implemente Runnable"),_=i("3.1.2 Thread subclass"),R=i("3.1.3 Starting a Thread With a Runnable"),S=i("Subclass or Runnable?"),z=i("3.1.4 M\xE9todos de la clase java.lang.Thread"),E=i("C\xF3mo pausar un hilo"),C=i("Gesti\xF3n de la prioridad de los hilos"),M=r('<h2 id="_3-1-1-el-interfaz-runnable" tabindex="-1">3.1.1. El interfaz Runnable</h2><p>Un hilo (thread en adelante) puede ejecutar c\xF3digo Java dentro de tu aplicaci\xF3n Java.</p><p><img src="'+v+`" alt="alt_text"></p><p>Cuando un programa Java se lanza (se convierte en un proceso) empieza a ejecutarse por su m\xE9todo main() que lo ejecuta el thread principal (main), un hilo especial creado por la Java VM para ejecutar la aplicaci\xF3n. Desde un proceso se pueden crear e iniciar tantos threads como necesites. Estos hilos ejecutar\xE1n partes del c\xF3digo de la aplicaci\xF3n en paralelo con el thread principal</p><p>Los thread en Java son objetos como cualquier otro. Un thread es una instancia de la clase java.lang.Thread, o instancias de clases que heredan de \xE9sta. Como ya hemos icho, adem\xE1s de ser objetos, los threads tienen la capacidad de ejecutar c\xF3digo.</p><p>La forma m\xE1s usada para indicar a un thread qu\xE9 codigo queremos que ejecute es creando una clase que implemente la interfaz <code>java.lang.Runnable</code>.</p><p>Esta interfaz es una interfaz est\xE1ndar que viene con la plataforma Java. La interfaz Runnable s\xF3lo tiene un \xFAnico m\xE9todo, void run().</p><blockquote><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html" target="_blank" rel="noopener noreferrer">java.lang.Runnable specification</a></p></blockquote><p>Sea lo que sea lo que el thread tenga que hacer, debe estar incluido en la implementaci\xF3n del m\xE9todo run. Tenemos tres posibilidades de implementar dicha interfaz:</p><ul><li>Crear una clase Java que implemente la interfaz Runnable.</li><li>Crear una clase an\xF3nima que implemente la interfaz Runnable.</li><li>Crear una expresi\xF3n Lambda que implemente la interfaz Runnable.</li></ul><p>En las siguientes secciones podemos ver c\xF3mo usar cada una de ellas.</p><h3 id="clase-java-que-implementa-la-interfaz-runnable" tabindex="-1">Clase Java que implementa la interfaz Runnable</h3><p>La primera forma que vamos a ver es creando una clase que implementa la interfaz. Podemos ver un ejemplo b\xE1sico en el siguiente c\xF3digo:</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>public class MyRunnable implements Runnable {

  public void run(){
      System.out.println(&quot;MyRunnable running&quot;);
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Todo lo que hace la implementaci\xF3n es imprimir el texto &quot;MyRunnable running&quot;. Tras ejecutar esa l\xEDnea de c\xF3digo, el m\xE9todo run termina y el thread que estuviese ejecut\xE1ndolo se parar\xEDa.</p><h3 id="implementacion-con-clase-anonima-de-la-interfaz-runnable" tabindex="-1">Implementaci\xF3n con clase an\xF3nima de la interfaz Runnable</h3><p>Otra forma de obtener un objeto que implemente Runnable es crear una clase an\xF3nima. A continuaci\xF3n tenemos un ejemplo de c\xF3mo hacerlo</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>Runnable myRunnable =
    new Runnable(){
        public void run(){
            System.out.println(&quot;Runnable running&quot;);
        }
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Salvo por el hecho de usar una clase an\xF3nima, el ejemplo hace exactamente lo mismo que el anterior en el que se creaba una clase que implementaba la interfaz.</p><h3 id="implementacion-de-runnable-a-traves-de-una-expresion-lambda" tabindex="-1">Implementaci\xF3n de Runnable a trav\xE9s de una expresi\xF3n Lambda</h3><p>Para la tercera forma nos vamos a basar en la caracter\xEDstica de la interfaz Runnable, esto es, que s\xF3lo tiene un \xFAnico m\xE9todo a implementar, el m\xE9todo run. Aunque Runnable no es una interfaz funcional, podemos crear una expresi\xF3n Lambda que no dar\xE1 lugar a confusi\xF3n acerca del m\xE9todo que se quiere ejecutar. Por este motivo podemos usar la expresi\xF3n lambda como si Runnable fuese una interfaz funcional.</p><p>Vamos a verlo con un ejemplo</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>Runnable runnable =
        () -&gt; { System.out.println(&quot;Lambda Runnable running&quot;); };
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="llamar-al-metodo-run-de-una-clase-que-implemente-runnable" tabindex="-1">Llamar al m\xE9todo run de una clase que implemente Runnable</h3><p>Vamos a fijarnos en este ejemplo</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>public class LiftOff implements Runnable {
    private int countDown = 10;
    private static int taskCount = 0;
    private final int id = taskCount;
    
    public LiftOff() {}
    
    public LiftOff(int countDown) {
        this.countDown = countDown;
    }
    
    @Override
    public void run() {
        while (countDown &gt; 0) {
            System.out.println(&quot;#&quot; + id + &quot; (&quot; + countDown + &quot;)&quot; );
            countDown--;
        }
        System.out.println(&quot;Lanzamiento (&quot; + id + &quot;)&quot;);
    }
    
    public static void main(String[] args) {
        LiftOff launch = new LiftOff();
        launch.run();
        System.out.println(&quot;Comienza la cuenta atr\xE1s!&quot;);
    }    
}
</code></pre><div class="highlight-lines"><div class="highlight-line">\xA0</div><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line">\xA0</div><br><br><br><br><br><br><br><br><br><div class="highlight-line">\xA0</div><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Copy the previous code and try tu run it in your IDE</p><p>::: question \xBFQu\xE9 est\xE1 pasando con la ejecuci\xF3n del programa anterior? Tras ejecutarlo, \xBFel mensaje &quot;Comienza la cuenta atr\xE1s!&quot; est\xE1 puesto en el sitio correcto?</p><p>intenta crear m\xE1s instancias del la clase LiftOff y haz que se ejecuten todas (dentro del main)</p><p>Si observas la salida de aplicaci\xF3n, \xBFest\xE1 haciendo algo diferente a una aplicaci\xF3n monohilo? \xBFQu\xE9 puedes extraer de la salida del programa? :::</p><p>::: details Respuesta a las cuestiones planteadas El mensaje deber\xEDa mostrarse antes que la cuenta atr\xE1s. De hecho la instrucci\xF3n con el System.out est\xE1 despu\xE9s de la llamada al m\xE9todo run.</p><p>Como se puede observar, no estamos haciendo nada diferente. El c\xF3digo de run se est\xE1 ejecutando uno despu\xE9s de otro.</p><p>En realidad, <strong>no estamos creando nuevos threads</strong>, lo \xFAnico que hemos hecho hasta ahora es implementar una interfaz, pero llamando al m\xE9todo run estamos haciendo que el hilo principal de la aplicaci\xF3n, el \xFAnico hilo de momento, est\xE9 ejecutando un m\xE9todo run, despu\xE9s otro, despu\xE9s otro, ... y cuando ha acabado con todos hace el System.out. :::</p><h2 id="_3-1-2-thread-subclass" tabindex="-1">3.1.2 Thread subclass</h2><p>Adem\xE1s de implementando la interfaz Runnable, laa segunda forma que tenemos de indicar a un thread el c\xF3digo a ejecutar es creando una subclase de <code>java.lang.Thread</code> y sobrescribiendo el m\xE9todo run(). La clase Thread implementa de forma impl\xEDcita la interfaz Runnable. Al igual que con Runnable, el m\xE9todo run() contiene el c\xF3digo que ejecutar\xE1 un thread cuando se llame al m\xE9todo <code>start()</code>.</p><blockquote><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html" target="_blank" rel="noopener noreferrer">java.lang.Thread specification</a></p></blockquote><p>Vamos a ver un ejemplo de creaci\xF3n de una clase que herede de Thread:</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>public class MyThread extends Thread {
  public void run(){
      System.out.println(&quot;MyThread running&quot;);
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Para crear y lanzar un nuevo thread tenemos que usar el siguiente c\xF3digo</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>MyThread myThread = new MyThread();
myTread.start();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>La llamada al m\xE9todo start() devuelve el control al thread principal en cuanto el hilo asociado se inicia. A diferencia del ejemplo de la cuenta atr\xE1s, cuando llamamos al m\xE9todo start no el hilo principal no espera a que el m\xE9todo run() se ejecute por completo antes de seguir. El m\xE9todo run() se ejecutar\xE1 en un hilo de ejecuci\xF3n diferente, posiblemente por un procesador diferente, entrando en la cola de procesos para competir por las unidades de procesamiento del sistema. Al igual que en los casos anteriores, cuando se ejecute el m\xE9todo run() mostrar\xE1 por pantalla el mensaje &quot;MyThread running&quot; y el hilo terminar\xE1 su ejecuci\xF3n (y su vida) porque finaliza el c\xF3digo del m\xE9todo run().</p><p>El ejemplo se puede repetir con una clase an\xF3nima, aunque ya no con una expresi\xF3n lambda, ya que la clase Thread tiene muchos m\xE1s m\xE9todos y no es una interfaz funcional.:</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>Thread thread = new Thread(){
  public void run(){
    System.out.println(&quot;Thread Running&quot;);
  }
}

thread.start();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>El ejemplo mostrar\xE1 el mensaje &quot;Thread running&quot; cuando el m\xE9todo run() se ejecutado por el nuevo thread.</p><p>::: question Ejemplo Cuenta atr\xE1s Copia el ejemplo original de la &quot;Cuenta Atr\xE1s&quot; y haz que la clase LiftOff ahora herede de Thread. Ahora, en vez de llamar directamente al m\xE9todo run, haz que los threads llamen al m\xE9todo start().</p><p>El mensaje &quot;Comienza la cuenta atr\xE1s!&quot; \xBFaparece ahora en el sitio correcto? \xBFPorqu\xE9 sale antes si en el c\xF3digo est\xE1 despu\xE9s?</p><p>Crea nuevas instancias de LiftOff y has que se lancen en el main \xBFEn qu\xE9 ha cambiado ahora la ejecuci\xF3n de las aplicaci\xF3n respecto a una aplicaci\xF3n monohilo? \xBFQu\xE9 puedes extraer de la salida del programa? :::</p><p>::: details Respuesta a las cuestiones planteadas Ahora el mensaje &quot;Comienza la cuenta atr\xE1s!&quot; s\xED aparece, en la salida, en la posici\xF3n correcta, es decir, antes de la cuenta atr\xE1s. Si observamos el c\xF3digo, siguiendo una l\xF3gica secuencial, el mensaje deber\xEDa aparecer despu\xE9s, como pas\xF3 en la primera prueba que hicimos.</p><p>La diferencia ahora es que el c\xF3digo del run() lo est\xE1 ejecutando un hilo diferente, y desde el momento en que se hace el start() el control vuelve al hilo principal (main) que contin\xFAa ejecutando las l\xEDneas de c\xF3digo que hay en el m\xE9todo main. La creaci\xF3n de un hilo, aunque menos que la de un proceso, tambi\xE9n tiene un coste de recursos y temporal, por lo que el hilo tarda unos instantes en empezar a ejecutarse. Por eso el hilo principal tiene tiempo de ejecutar la siguiente instrucci\xF3n y mostrar el mensaje.</p><p>La gran diferencia ahora, que podemos observar en la salida, es que los hilos se est\xE1n ejecutando concurrentemente, ya que vemos como sus salidas se intercalan.</p><p>Esa es la diferencia m\xE1s obvia. Sin embargo, si ejecutamos el programa varias veces, podremos observar que no hay dos ejecuciones iguales. No depende de nosotros el orden en el que se ejecutan las instrucciones, sino que depende de la planificaci\xF3n que realice el SO. En este contexto nos encontramos con una ejecuci\xF3n aleatoria o <strong>indeterminista</strong> como la denominamos en el primer tema.</p><p>El c\xF3mo controlar ese orden es lo que trabajaremos en la segunda parte del tema. :::</p><p>::: info \xBFCu\xE1ndo termina un proceso? En el ejemplo anterior, la \xFAltima l\xEDnea del hilo principal se ejecuta antes que el c\xF3digo de los hilos. \xBFQu\xE9 pasa entonces con el proceso?</p><p>En un proceso monohilo, estamos acostumbrados a que el proceso sigue en ejecuci\xF3n (vivo) mientras el c\xF3digo que hayamos puesto en el main est\xE9 ejecut\xE1ndose. En concreto mientras el main-thread est\xE9 en ejecuci\xF3n.</p><p><img src="`+h+`" alt="Ciclo de vida de un proceso"></p><p>Cuando un proceso tiene mas hilos, la norma es que el proceso no finaliza su ejecuci\xF3n hasta que el \xFAltimo de los hilos haya terminado. As\xED que podemos encontrarnos, como en ejemplo de la cuenta atr\xE1s, que el main-thread acaba y el proceso sigue en ejecuci\xF3n. :::</p><h2 id="_3-1-3-starting-a-thread-with-a-runnable" tabindex="-1">3.1.3 Starting a Thread With a Runnable</h2><p>Para hacer que un thread ejecute el c\xF3digo del m\xE9todo run de una clase (instancia de clase, clase an\xF3nima, expresi\xF3n lambda) que implemente la interfaz Runnable, tenemos que pasar esa instancia como par\xE1metro en el constructor de la clase Thread. Veamos c\xF3mo se hace:</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>Runnable runnable = new MyRunnable(); // or an anonymous class, or lambda...

Thread thread = new Thread(runnable);
thread.start();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Cuando se inicia el thread, llamando a su m\xE9todo start(), se crea un nuevo thread que ejecuta el c\xF3digo del m\xE9todo run de la instancia MyRunnable. El ejemplo anterior imprimir\xE1 el texto &quot;MyRunnable running (ver el c\xF3digo de MyRunnable en los ejemplos anteriores).</p><p>::: info En resumen, tenemos dos formas de indicarle a un thread qu\xE9 c\xF3digo debe ejecutar.</p><ul><li>Crear una subclase de Thread y sobrescribir el m\xE9todo run().</li><li>Pasar una instancia de un objeto que implemente la interfaz Runnable al constructor de Thread.</li></ul><p><strong>En ambos casos, para que se cree el thread y ejecute el c\xF3digo del m\xE9todo run, debemos llamar al m\xE9todo start() del objeto Thread.</strong> :::</p>`,63),P=e("div",{class:"language-java ext-java line-numbers-mode"},[e("pre",{class:"language-java"},[e("code",null,`public class EjemploThread extends Thread {
  public void run() {
    // C\xF3digo del hilo
  }

  public static void main(String[] args) {
    EjemploThread hilo = new EjemploThread();
    hilo.start();
  }
}
`)]),e("div",{class:"highlight-lines"},[e("div",{class:"highlight-line"},"\xA0"),e("br"),e("br"),e("br"),e("br"),e("br"),e("div",{class:"highlight-line"},"\xA0"),e("br"),e("br"),e("br")]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),w=e("div",{class:"language-java ext-java line-numbers-mode"},[e("pre",{class:"language-java"},[e("code",null,`public class EjemploRunnable implements Runnable {
  public void run() {
    // C\xF3digo del hilo
  }

  public static void main(String[] args) {
    Thread hilo = new Thread(new EjemploRunnable());
    hilo.start();
  }    
}
`)]),e("div",{class:"highlight-lines"},[e("div",{class:"highlight-line"},"\xA0"),e("br"),e("br"),e("br"),e("br"),e("br"),e("div",{class:"highlight-line"},"\xA0"),e("br"),e("br"),e("br")]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),L=r(`<h3 id="subclass-or-runnable" tabindex="-1">Subclass or Runnable?</h3><p>No hay nada que indique que una forma es mejor que otra. Ambos m\xE9todos son similares y el resultado es el mismo. . <strong>El m\xE9todo preferido deber\xEDa ser implementar Runnable</strong>, y pasarle la instancia al constructor de Thread.</p><p>unas cuantas razones en contra de usar Thread</p><ul><li>Cuando heredamos de la clase Thread, no estamos sobrescribiendo ninguno de sus m\xE9todos. Por contra, estamos sobrescribiendo un m\xE9todo de la interfaz Runnable (que Thread implementa internamente . Esto supone una clara violaci\xF3n del principio IS-A del Thread.</li><li>Cuando pasamos la instancia de Runnable y la utilizamos como argumento en el constructor de Thread estamos usando composici\xF3n y no herencia, lo cual permite mucha m\xE1s flexibilidad.</li><li>Si heredamos de Thread, ya no podemos heredar de otras clases. Esto supone un gran problema cuando usamos librer\xEDas o componentes gr\xE1ficos, ya que Java noi permite la herencia m\xFAltiple.</li><li>Desde Java 8 en adelante, la interfaz Runnable se puede representar con expresiones lambda</li></ul><p>::: danger Error com\xFAn: Llamar a run () en vez de a start() Cuando empezamos a trabajar con hilos, un error muy com\xFAn es llamar directamente al m\xE9todo run en vez de llamar al m\xE9todo start():</p><blockquote><p>Thread newThread = new Thread(MyRunnable()); newThread.run(); //should be start();</p></blockquote><p>or</p><blockquote><p>MyRunnable runnable = new MyRunnable(); runnable.run();</p></blockquote><p>En principio no notamos ning\xFAn error ya que el c\xF3digo de run() se ejecuta y podemos ver los resultados. Sin embargo, ese c\xF3digo <strong>no es ejecutado por el nuevo thread</strong> que acabamos de crear. El m\xE9todo run() es ejecutado por el thread que ha creado el objeto, es decir, el mismo thread que ha ejecutado las l\xEDneas anteriores a la llamada a run().</p><p>Para hacer que el m\xE9todo run, de una instancia que implemente Runnable o de una que herede de Thread, sea ejecutado por un el nuevo thread que acabamos de crear, newThread, debemos llamar al m\xE9todo newThread.start(). :::</p><h2 id="_3-1-4-metodos-de-la-clase-java-lang-thread" tabindex="-1">3.1.4 M\xE9todos de la clase java.lang.Thread</h2><p>Si miramos a la definici\xF3n de la clase Thread veremos que tiene muchos m\xE9todos. Debemos tener cuidado ya que algunos de estos m\xE9todos como stop(), suspend(), resume() and destroy() han sido marcados como <code>obsoletos(deprecated)</code>.</p><p>Vemos algunos de los m\xE9todos de la clase Thread m\xE1s utilizados:</p><table><thead><tr><th style="text-align:left;">Method</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;">start()</td><td style="text-align:left;">HAce que un nuevo thread ejecute el c\xF3digo del m\xE9todo run()</td></tr><tr><td style="text-align:left;">boolean isAlive()</td><td style="text-align:left;">Comprueba si un thread est\xE1 vivo o no</td></tr><tr><td style="text-align:left;">sleep(long ms)</td><td style="text-align:left;">Cambia el estado del thread a bloqueado durante los ms indicados</td></tr><tr><td style="text-align:left;">run()</td><td style="text-align:left;">Es el c\xF3digo que el thread ejecuta. Es llamado por el m\xE9todo start(). Representa el ciclo de vida de un thread.</td></tr><tr><td style="text-align:left;">String toString()</td><td style="text-align:left;">Devuelve una representaci\xF3n legible de un thread [nombre, priority, nombre_del_grupo</td></tr><tr><td style="text-align:left;">long getId()</td><td style="text-align:left;">Devuelve el identificador del thread (es un id asignado por el proceso)</td></tr><tr><td style="text-align:left;">void yield()</td><td style="text-align:left;">Makes the thread stop running at the moment going back to the queue and allowing other threads to be executed.</td></tr><tr><td style="text-align:left;">void join()</td><td style="text-align:left;">Se llama desde otro thread y hace que el thread que lo invoca se bloquee hasta que el thread termine. Es parecido a p.waitFor() para los procesos</td></tr><tr><td style="text-align:left;">String getName()</td><td style="text-align:left;">Obtiene el nombre del thread</td></tr><tr><td style="text-align:left;">String setName(String name)</td><td style="text-align:left;">Cambia el nombre del thread</td></tr><tr><td style="text-align:left;">int getPriority()</td><td style="text-align:left;">Obtiene la prioridad del thread</td></tr><tr><td style="text-align:left;">setPriority(int p)</td><td style="text-align:left;">Modifica la prioridad del thread</td></tr><tr><td style="text-align:left;">void interrupt()</td><td style="text-align:left;">Interrumpe la ejecuci\xF3n del thread provocando que salte una excepci\xF3n de tipo InterruptedException</td></tr><tr><td style="text-align:left;">boolean interrupted()</td><td style="text-align:left;">Comprueba si un thread ha sido interrumpido</td></tr><tr><td style="text-align:left;">Thread.currentThread()</td><td style="text-align:left;">M\xE9todo est\xE1tico de la clase Thread que devuelve una referencia al hilo que est\xE1 ejecutando el c\xF3digo</td></tr><tr><td style="text-align:left;">boolean isDaemon()</td><td style="text-align:left;">Comprueba si un hilo es un servicio/demonio. Un proceso/hilo de baja prioridad que se ejecuta de forma independiente de su proceso padre. Un proceso puede finalizar aunque un hilo <em>daemon</em> est\xE9 todav\xEDa ejecut\xE1ndose.</td></tr><tr><td style="text-align:left;">setDaemon(boolean on)</td><td style="text-align:left;">Convierte un hilo en un demonio/servicio. Por defecto todos los hilos se crean como hilos de usuario.</td></tr><tr><td style="text-align:left;">int activeCount()</td><td style="text-align:left;">Devuelve el n\xFAmero de hilos pertenecientes a un grupo que siguen activos.</td></tr><tr><td style="text-align:left;">Thread.State getState()</td><td style="text-align:left;">Devuelve el estado actual del hilo. Los posibles valores son NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING or TERMINATED.</td></tr></tbody></table><p>La clase Thread tambi\xE9n tiene unos 9 constructores, la mayor\xEDa de ellos est\xE1n duplicados permitiendo recibir un objeto dRunnable como par\xE1metro</p><table><thead><tr><th style="text-align:left;">Constructores de la clase Thread</th></tr></thead><tbody><tr><td style="text-align:left;">Thread()</td></tr><tr><td style="text-align:left;">Thread\u200B(Runnable target)</td></tr><tr><td style="text-align:left;">Thread\u200B(String name)</td></tr><tr><td style="text-align:left;">Thread\u200B(ThreadGroup group, String name)</td></tr><tr><td style="text-align:left;">Thread\u200B(Runnable target, String name)</td></tr><tr><td style="text-align:left;">Thread\u200B(ThreadGroup group, Runnable target)</td></tr><tr><td style="text-align:left;">Thread\u200B(ThreadGroup group, Runnable target, String name)</td></tr><tr><td style="text-align:left;">Thread\u200B(ThreadGroup group, Runnable target, String name, long stackSize)</td></tr><tr><td style="text-align:left;">Thread\u200B(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals)</td></tr></tbody></table><p>Veamos un ejemplo pr\xE1ctico de uso de todos estos m\xE9todos</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>public class U3S2_ThreadMethodsExample extends Thread {
    
    U3S2_ThreadMethodsExample (ThreadGroup group, String name) {
        // Call to parent class constructor with group and thread name
        super(group, name);
    }
    
    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        System.out.println(&quot;[&quot;+threadName+&quot;] &quot; + &quot;Inside the thread&quot;);
        System.out.println(&quot;[&quot;+threadName+&quot;] &quot; + &quot;Priority: &quot; 
          + Thread.currentThread().getPriority());
        Thread.yield();
        System.out.println(&quot;[&quot;+threadName+&quot;] &quot; + &quot;Id: &quot; 
          + Thread.currentThread().getId());
        System.out.println(&quot;[&quot;+threadName+&quot;] &quot; + &quot;ThreadGroup: &quot; 
          + Thread.currentThread().getThreadGroup().getName());
        System.out.println(&quot;[&quot;+threadName+&quot;] &quot; + &quot;ThreadGroup count: &quot; 
          + Thread.currentThread().getThreadGroup().activeCount());
    } 
    
    public static void main(String[] args) {
        // main thread 
        Thread.currentThread().setName(&quot;Main&quot;);
        System.out.println(Thread.currentThread().getName());
        System.out.println(Thread.currentThread().toString());
        
        ThreadGroup even = new ThreadGroup(&quot;Even threads&quot;);
        ThreadGroup odd = new ThreadGroup(&quot;Odd threads&quot;);
        
        Thread localThread = null;
        for (int i=0; i&lt;10; i++) {
            localThread = new U3S2_ThreadMethodsExample((i%2==0)?even:odd, &quot;Thread&quot;+i);
            localThread.setPriority(i+1);
            localThread.start();
        }
              
        try {
            localThread.join(); // --&gt; Will wait until last thread ends 
                                // like a waitFor() for processes
        } catch (InterruptedException ex) {
            ex.printStackTrace();
            System.err.println(&quot;The main thread was interrupted while waiting for &quot; 
              + localThread.toString() + &quot;to finish&quot;);
        }
        System.out.println(&quot;Main thread ending&quot;);
    }    
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>En el ejemplo anterior podemos ver c\xF3mo tenemos que ayudarnos el m\xE9todo est\xE1tico Thread.currentThread() par saber qu\xE9 hilo est\xE1 ejecut\xE1ndose en cada momento, ya que hay muchos hilos ejecutando el mismo c\xF3digo al mismo tiempo.</p><p>Hemos creado una \xFAnica clase para los hilos y para el hilo principal. No deber\xEDa ser una pr\xE1ctica com\xFAn m\xE1s all\xE1 de los ejemplos. Es mejor separar el c\xF3digo del objeto que hereda de Thread o que implementa Runnable en una clase aparte.</p><p>Tambi\xE9n es importante hacer ver que la clase Thread (o Runnable) puede tener sus propios constructores, propiedades y m\xE9todos, m\xE1s all\xE1 del m\xE9todo run que est\xE1n obligadas a sobrescribir. Tambi\xE9n puede invocar a los constructores de la superclase haciendo uso de super().</p><p>:::question Dividir el c\xF3digo en dos clases Copia el c\xF3digo de ThreadMethodsExample y div\xEDdelo en dos clases. Por un lado, una que contenga a la clase que extiende de Thread y otra que s\xEDmplemente tenga el m\xE9todo main y el c\xF3digo para crear y lanzar los hilos..</p><p>Una vez dividido el c\xF3digo cambia U3S2_ThreadMethodsExample para que implemente la interfaz Runnable. Haz los cambios oportunos en la otra clase para que todo vuelva a funcionar como antes. :::</p><p>Si ejecutas el programa podr\xE1s ver que aunque los threads son lanzados en orden (1, 2, 3 etc.) su ejecuci\xF3n ya no se realiza de forma secuencial. they may not execute sequentially, meaning thread 1 may not be the first thread to write its name to System.out. This is because the threads are in principle executing in parallel and not sequentially. The JVM and/or operating system determines the order in which the threads are executed. This order does not have to be the same order in which they were started nor each time the are run.</p><h3 id="como-pausar-un-hilo" tabindex="-1">C\xF3mo pausar un hilo</h3><p>Un thread puede pausar su propia ejecuci\xF3n llamando al m\xE9todo est\xE1tico <strong>Thread.sleep()</strong>. El m\xE9todo sleep() recibe como par\xE1metro el n\xFAmero de milisegundos que quiere estar pausado antes de volver a ponerse como listo para ejecuci\xF3n. No es un m\xE9todo 100% precise (menos \xE1un si utilizamos la versi\xF3n que recibe ms y ns), pero a\xFAn as\xED es bastante preciso. A continuaci\xF3n tenemos un ejemplo de un thread que se pausa durante 3 segundos (3000ms) llamando al m\xE9todo sleep():</p><div class="language-java ext-java"><pre class="language-java"><code>try {
    Thread.sleep(3000L);
} catch (InterruptedException e) {
    e.printStackTrace();
}
</code></pre></div><p>::: info Simulaci\xF3n de sistema reales Este es un m\xE9todo que vamos a utilizar exhaustivamente en las actividades para simular per\xEDodos de tiempo y acelerar las simulaciones.</p><p>Por ejemplo, podemos hacer un ajuste para que cada hora <em>real</em> se reduzca a un segundo. De esta forma podremos simular un d\xEDa completo en tan solo 24 segundos.</p><p>Tambi\xE9n es interesante su uso para utilizar per\xEDodos de tiempo aleatorios en la ejecuci\xF3n de cada hilo, permitiendo as\xED una simulaci\xF3n realista de los eventos en un sistema real. :::</p><p>En Java podemos generar n\xFAmeros aleatorios en el rango de los enteros, long, float y double.</p><p>Tenemos tres m\xE9todos b\xE1sicos para hacerlo</p><h4 id="method-1-usando-la-clase-random" tabindex="-1">Method 1: Usando la clase Random</h4><p>Podemos usar la clase <code>java.util.Random</code> para generar datos aleatorios, siguiendo los siguientes pasos:</p><ul><li>Importar la clase java.util.Random</li><li>Crear una instancia de la clase Random, por ejemplo <code>Random rand = new Random()</code></li><li>Llamar a alguno de los m\xE9todos del objeto: <ul><li>nextInt(limitesuperior) genera n\xFAmeros aleatorios en el rango 0 a l\xEDmitesuperior-1.</li><li>nextFloat() genera un float entre 0.0 and 1.0.</li><li>nextDouble() genera un double entre 0.0 and 1.0.</li></ul></li></ul><p>Si llamamos al m\xE9todo nextInt con par\xE1metros (el l\xEDmite superior), obtendremos n\xFAmeros enteros en el rango</p><blockquote><p>int randomWithNextIntWithinARange = random.nextInt(max)</p></blockquote><p>Esto nos dar\xE1 un n\xFAmero entre <em>0 (inclusive)</em> y <em>max</em> (no incluido) [min, max[. El valor del l\xEDmite debe ser mayor que 0 sino obtendremos una java.lang.IllegalArgumentException.</p><h4 id="method-2-usando-math-random" tabindex="-1">Method 2: Usando Math.random</h4><p>Para generar n\xFAmeros aleatorios en un rango podemos usar Math.random() siguiendo los pasos detallados a continuaci\xF3n:</p><ul><li>Declarar el valor m\xEDnimo del rango</li><li>Declarar el valor m\xE1ximos del rango</li><li>Usar la f\xF3rmula <code>Math.random()*(max-min)+min</code> para generar valores entre <em>min</em> y <em>max</em>, ambos inclusive [min, max].</li></ul><p>El valor devuelto por Math.random() est\xE1 en el rango [0, 1]</p><p>Para generar n\xFAmeros entre 0 y un l\xEDmite superior (50)</p><blockquote><p>Math.random()*50</p></blockquote><p>Para generar n\xFAmeros entre 1 y un l\xEDmite superior (50)</p><blockquote><p>Math.random()*49+1</p></blockquote><p>Para generar n\xFAmeros en un rango predeterminado [200, 500]</p><blockquote><p>Math.random()*300+200</p></blockquote><h4 id="method-3-usar-threadlocalrandom" tabindex="-1">Method 3: Usar ThreadLocalRandom</h4><p>La clase <code>java.util.Random</code> no tiene buen rendimiento en entornos multihilo. De forma simplificada, el motivo es la contenci\xF3n, ya que muchos hilos comparten la misma instancia de Random y se tiene que secuenciar y sincronizar el acceso a sus m\xE9todos.</p><p>Para evitar esa limitaci\xF3n, Java introdujo la clase <code>java.util.concurrent.ThreadLocalRandom</code> para generar n\xFAmeros aleatorios en entornos multihilo.</p><p>Si llamamos al m\xE9todo <code>ThreadLocalRandom.current()</code> nos devolver\xE1 la instancia de ThreadLocalRandom para el hilo actual. A partir de aqu\xED podemos generar valores aleatorios llamando a los m\xE9todos de la clase con la instancia obtenida.</p><p>Para generar valores enteros sin l\xEDmite:</p><blockquote><p>int unboundedRandomValue = ThreadLocalRandom.current().nextInt());</p></blockquote><p>Para generar valores enteros en un rango dato, es decir, con un l\xEDmite superior e inferior [0, 100[:</p><blockquote><p>int boundedRandomValue = ThreadLocalRandom.current().nextInt(0, 100);</p></blockquote><p>Al igual que con Random, 0 est\xE1 incluido en el rango mientra que 100 no.</p><p>Tambi\xE9n podemos generar otros tipos de datos como long y Double llamando a los m\xE9todos <code>nextLong()</code> y <code>nextDouble()</code> de forma similar a los ejemplos anteriores.</p><p>La clase ThreadLocalRandom hereda de Random, por lo que comparten muchos m\xE9todos y funcionalidad.</p><h3 id="gestion-de-la-prioridad-de-los-hilos" tabindex="-1">Gesti\xF3n de la prioridad de los hilos</h3><p>Los hilos heredan la prioridad del padre en Java, pero este valor puede ser cambiado con el m\xE9todo <code>setPriority()</code> y con <code>getPriority()</code> podemos saber la prioridad de un hilo.</p><p>El valor de la prioridad var\xEDa entre 1 y 10. <em>Cuanto m\xE1s alto es el valor, mayor es la prioridad</em>. La clase Thread define las siguientes constantes <code>MIN_PRIORITY</code> (valor 1) <code>MAX_PRIORITY</code> (valor 10) y <code>NORM_PRIORITY</code> (valor 5). El planificador elige el hilo en funci\xF3n de su prioridad. Si dos hilos tienen la misma prioridad realiza un round-robin, es decir de forma c\xEDclica va alternando los hilos.</p><p>El hilo de mayor prioridad seguir\xE1 funcionando hasta que ceda el control:</p><ul><li>Cede el control llamando al m\xE9todo yield().</li><li>Deja de ser ejecutable (por muerte o por bloqueo)</li><li>Aparece un hilo de mayor prioridad, por ejemplo si se encontraba en estado dormido por una operaci\xF3n de E/S o bien es desbloqueado por otro con los m\xE9todos notifyAll() / notify().</li></ul><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>class U3S3_HiloPrioridad1 extends Thread {
  private int c = 0;
  private boolean stopHilo = false;
  public int getContador () {
    return c;
  }
  public void pararHilo() {
    stopHilo = true;
  }
  public void run() {
    while (!stopHilo) c++;
  }
}

public class U3S3_EjemploHiloPrioridad1 {
  public static void main(String args[]) {
    U3S3_HiloPrioridad1 h1 = new U3S3_HiloPrioridad1();
    U3S3_HiloPrioridad1 h2 = new U3S3_HiloPrioridad1();
    U3S3_HiloPrioridad1 h3 = new U3S3_HiloPrioridad1();

    h1.setPriority(Thread.NOR_PRIORITY);
    h2.setPriority(Thread.MAX_PRIORITY);
    h3.setPriority(Thread.MIN_PRIORITY);

    h1.start();
    h2.start();
    h3.start();

    try {
      Thread.sleep(10000);
    } catch (exception e) {}

    h1.pararHilo();
    h2.pararHilo();
    h3.pararHilo();

    System.out.println(&quot;h2 (Prio. M\xE1x: &quot;+h2.getContador());
    System.out.println(&quot;h1 (Prio. Normal: &quot;+h1.getContador());
    System.out.println(&quot;h3 (Prio. M\xEDnima: &quot;+h3.getContador());
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,65);function I(D,k){const s=o("DownloadPDF-component"),d=o("DocumentCover-component"),l=o("router-link"),t=o("CodeGroupItem"),u=o("CodeGroup");return m(),p("div",null,[a(s),a(d,{titulo:"3.1. Clases Java para la gesti\xF3n de hilos"}),g,e("nav",q,[e("ul",null,[e("li",null,[a(l,{to:"#_3-1-1-el-interfaz-runnable"},{default:n(()=>[f]),_:1}),e("ul",null,[e("li",null,[a(l,{to:"#clase-java-que-implementa-la-interfaz-runnable"},{default:n(()=>[y]),_:1})]),e("li",null,[a(l,{to:"#implementacion-con-clase-anonima-de-la-interfaz-runnable"},{default:n(()=>[j]),_:1})]),e("li",null,[a(l,{to:"#implementacion-de-runnable-a-traves-de-una-expresion-lambda"},{default:n(()=>[T]),_:1})]),e("li",null,[a(l,{to:"#llamar-al-metodo-run-de-una-clase-que-implemente-runnable"},{default:n(()=>[x]),_:1})])])]),e("li",null,[a(l,{to:"#_3-1-2-thread-subclass"},{default:n(()=>[_]),_:1})]),e("li",null,[a(l,{to:"#_3-1-3-starting-a-thread-with-a-runnable"},{default:n(()=>[R]),_:1}),e("ul",null,[e("li",null,[a(l,{to:"#subclass-or-runnable"},{default:n(()=>[S]),_:1})])])]),e("li",null,[a(l,{to:"#_3-1-4-metodos-de-la-clase-java-lang-thread"},{default:n(()=>[z]),_:1}),e("ul",null,[e("li",null,[a(l,{to:"#como-pausar-un-hilo"},{default:n(()=>[E]),_:1})]),e("li",null,[a(l,{to:"#gestion-de-la-prioridad-de-los-hilos"},{default:n(()=>[C]),_:1})])])])])]),M,a(u,null,{default:n(()=>[a(t,{title:"Extends Thread",active:""},{default:n(()=>[P]),_:1}),a(t,{title:"Runnable"},{default:n(()=>[w]),_:1})]),_:1}),L])}const O=c(b,[["render",I],["__file","runnable.html.vue"]]);export{O as default};
