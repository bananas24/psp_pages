const nl="modulepreload",rl=function(e){return"/psp_pages/"+e},Go={},k=function(n,r,a){return!r||r.length===0?n():Promise.all(r.map(o=>{if(o=rl(o),o in Go)return;Go[o]=!0;const t=o.endsWith(".css"),s=t?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${o}"]${s}`))return;const i=document.createElement("link");if(i.rel=t?"stylesheet":nl,t||(i.as="script",i.crossOrigin=""),i.href=o,document.head.appendChild(i),t)return new Promise((l,c)=>{i.addEventListener("load",l),i.addEventListener("error",()=>c(new Error(`Unable to preload CSS for ${o}`)))})})).then(()=>n())},al={"v-8daa1a0e":()=>k(()=>import("./index.html.126d04d1.js"),[]).then(({data:e})=>e),"v-705d1b76":()=>k(()=>import("./test_page.html.4a568a14.js"),[]).then(({data:e})=>e),"v-2d0a870d":()=>k(()=>import("./index.html.2d249cda.js"),[]).then(({data:e})=>e),"v-2d0a87a8":()=>k(()=>import("./index.html.e4bac9da.js"),[]).then(({data:e})=>e),"v-5aa74f15":()=>k(()=>import("./concurrency.html.a9773ff7.js"),[]).then(({data:e})=>e),"v-b73e5022":()=>k(()=>import("./index.html.76cb1e03.js"),[]).then(({data:e})=>e),"v-4b0532d0":()=>k(()=>import("./operatingsystem.html.3b383b5c.js"),[]).then(({data:e})=>e),"v-3f423939":()=>k(()=>import("./process.html.ccddbda9.js"),[]).then(({data:e})=>e),"v-8100edac":()=>k(()=>import("./curl_annex.html.5b95d392.js"),[]).then(({data:e})=>e),"v-b73e4fe4":()=>k(()=>import("./index.html.713d9d95.js"),[]).then(({data:e})=>e),"v-74406b7a":()=>k(()=>import("./iostreams.html.0499ab29.js"),[]).then(({data:e})=>e),"v-348bab3f":()=>k(()=>import("./processbuilder.html.2ac46f2f.js"),[]).then(({data:e})=>e),"v-1daecb0f":()=>k(()=>import("./runtime.html.1518979e.js"),[]).then(({data:e})=>e),"v-5bb12cb4":()=>k(()=>import("./alternatives.html.1b039ff6.js"),[]).then(({data:e})=>e),"v-10f2297a":()=>k(()=>import("./arraylist_annex.html.9254b220.js"),[]).then(({data:e})=>e),"v-737de6d4":()=>k(()=>import("./debugger_annex.html.d8031590.js"),[]).then(({data:e})=>e),"v-3714d943":()=>k(()=>import("./hashmap_annex.html.1b53ca24.js"),[]).then(({data:e})=>e),"v-b73e4fa6":()=>k(()=>import("./index.html.90dd1516.js"),[]).then(({data:e})=>e),"v-30e3afd6":()=>k(()=>import("./producer-consumer.html.f0b74cf3.js"),[]).then(({data:e})=>e),"v-27271e62":()=>k(()=>import("./runnable.html.940abf8d.js"),[]).then(({data:e})=>e),"v-1dbfca26":()=>k(()=>import("./synchronization.html.7a373daf.js"),[]).then(({data:e})=>e),"v-b73e4f68":()=>k(()=>import("./index.html.5a1c957c.js"),[]).then(({data:e})=>e),"v-14f705b1":()=>k(()=>import("./sockets-tcp.html.7bcdd997.js"),[]).then(({data:e})=>e),"v-9c83245e":()=>k(()=>import("./sockets-udp.html.d7b19f4f.js"),[]).then(({data:e})=>e),"v-17f557b3":()=>k(()=>import("./stateful-protocols.html.60941d4c.js"),[]).then(({data:e})=>e),"v-de8e734c":()=>k(()=>import("./tcp-ip.html.8815e59f.js"),[]).then(({data:e})=>e),"v-3af7f8ae":()=>k(()=>import("./urls.html.511e9d5c.js"),[]).then(({data:e})=>e),"v-6e11e1d8":()=>k(()=>import("./asymmetric-keys.html.f481fb53.js"),[]).then(({data:e})=>e),"v-4e4467f3":()=>k(()=>import("./hash-functions.html.f2e488c5.js"),[]).then(({data:e})=>e),"v-b73e4eec":()=>k(()=>import("./index.html.3125dbf0.js"),[]).then(({data:e})=>e),"v-6fa59714":()=>k(()=>import("./jsse.html.ea4313fc.js"),[]).then(({data:e})=>e),"v-2e9c294f":()=>k(()=>import("./security.html.2cfb65ed.js"),[]).then(({data:e})=>e),"v-0b29848c":()=>k(()=>import("./symmetric-key.html.2bea1717.js"),[]).then(({data:e})=>e),"v-46af1970":()=>k(()=>import("./concurrency.html.2bd7bd3f.js"),[]).then(({data:e})=>e),"v-a8728f6c":()=>k(()=>import("./index.html.57b7491c.js"),[]).then(({data:e})=>e),"v-e2dae91a":()=>k(()=>import("./operatingsystem.html.c87c3d7d.js"),[]).then(({data:e})=>e),"v-75292dd8":()=>k(()=>import("./process.html.d2672a8d.js"),[]).then(({data:e})=>e),"v-3277876f":()=>k(()=>import("./curl_annex.html.ff7b94d1.js"),[]).then(({data:e})=>e),"v-a8728f2e":()=>k(()=>import("./index.html.5c876409.js"),[]).then(({data:e})=>e),"v-14dd1095":()=>k(()=>import("./iostreams.html.ec26c929.js"),[]).then(({data:e})=>e),"v-5320ff04":()=>k(()=>import("./processbuilder.html.a8bda9fe.js"),[]).then(({data:e})=>e),"v-b8500a2c":()=>k(()=>import("./runtime.html.a3b94484.js"),[]).then(({data:e})=>e),"v-6718eaab":()=>k(()=>import("./alternatives.html.c19a759a.js"),[]).then(({data:e})=>e),"v-75f16356":()=>k(()=>import("./arraylist_annex.html.426a4dd2.js"),[]).then(({data:e})=>e),"v-36533f4a":()=>k(()=>import("./debugger_annex.html.9b023420.js"),[]).then(({data:e})=>e),"v-405378de":()=>k(()=>import("./hashmap_annex.html.07d64413.js"),[]).then(({data:e})=>e),"v-a8728ef0":()=>k(()=>import("./index.html.f0f464ca.js"),[]).then(({data:e})=>e),"v-2a24fba0":()=>k(()=>import("./producer-consumer.html.cad4b523.js"),[]).then(({data:e})=>e),"v-2b693c54":()=>k(()=>import("./runnable.html.bdf3f987.js"),[]).then(({data:e})=>e),"v-5c5621fe":()=>k(()=>import("./synchronization.html.61a213aa.js"),[]).then(({data:e})=>e),"v-a8728eb2":()=>k(()=>import("./index.html.057b8751.js"),[]).then(({data:e})=>e),"v-00fed00c":()=>k(()=>import("./sockets-tcp.html.74f1d9df.js"),[]).then(({data:e})=>e),"v-c4738fa8":()=>k(()=>import("./sockets-udp.html.60d9fa63.js"),[]).then(({data:e})=>e),"v-fefd7e10":()=>k(()=>import("./stateful-protocols.html.d3951d43.js"),[]).then(({data:e})=>e),"v-d5e6a1c2":()=>k(()=>import("./tcp-ip.html.6f4fc277.js"),[]).then(({data:e})=>e),"v-75d559ae":()=>k(()=>import("./urls.html.e770cfe1.js"),[]).then(({data:e})=>e),"v-222706b3":()=>k(()=>import("./asymmetric-keys.html.36b9f5c2.js"),[]).then(({data:e})=>e),"v-6cd9bbb8":()=>k(()=>import("./hash-functions.html.ccb792f4.js"),[]).then(({data:e})=>e),"v-a8728e36":()=>k(()=>import("./index.html.d1b218e6.js"),[]).then(({data:e})=>e),"v-02f6ed19":()=>k(()=>import("./jsse.html.b9e92c60.js"),[]).then(({data:e})=>e),"v-6d98f4d4":()=>k(()=>import("./security.html.d9380a55.js"),[]).then(({data:e})=>e),"v-03a9dd55":()=>k(()=>import("./symmetric-key.html.d447e967.js"),[]).then(({data:e})=>e),"v-3706649a":()=>k(()=>import("./404.html.d2dc3323.js"),[]).then(({data:e})=>e)};function ho(e,n){const r=Object.create(null),a=e.split(",");for(let o=0;o<a.length;o++)r[a[o]]=!0;return n?o=>!!r[o.toLowerCase()]:o=>!!r[o]}const ol="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",tl=ho(ol);function us(e){return!!e||e===""}function Br(e){if(oe(e)){const n={};for(let r=0;r<e.length;r++){const a=e[r],o=Ee(a)?ll(a):Br(a);if(o)for(const t in o)n[t]=o[t]}return n}else{if(Ee(e))return e;if(_e(e))return e}}const sl=/;(?![^(]*\))/g,il=/:(.+)/;function ll(e){const n={};return e.split(sl).forEach(r=>{if(r){const a=r.split(il);a.length>1&&(n[a[0].trim()]=a[1].trim())}}),n}function Xe(e){let n="";if(Ee(e))n=e;else if(oe(e))for(let r=0;r<e.length;r++){const a=Xe(e[r]);a&&(n+=a+" ")}else if(_e(e))for(const r in e)e[r]&&(n+=r+" ");return n.trim()}const Me=e=>Ee(e)?e:e==null?"":oe(e)||_e(e)&&(e.toString===gs||!le(e.toString))?JSON.stringify(e,ms,2):String(e),ms=(e,n)=>n&&n.__v_isRef?ms(e,n.value):cr(n)?{[`Map(${n.size})`]:[...n.entries()].reduce((r,[a,o])=>(r[`${a} =>`]=o,r),{})}:ps(n)?{[`Set(${n.size})`]:[...n.values()]}:_e(n)&&!oe(n)&&!fs(n)?String(n):n,je={},lr=[],cn=()=>{},cl=()=>!1,dl=/^on[^a-z]/,Fr=e=>dl.test(e),go=e=>e.startsWith("onUpdate:"),Ue=Object.assign,fo=(e,n)=>{const r=e.indexOf(n);r>-1&&e.splice(r,1)},ul=Object.prototype.hasOwnProperty,he=(e,n)=>ul.call(e,n),oe=Array.isArray,cr=e=>Sa(e)==="[object Map]",ps=e=>Sa(e)==="[object Set]",le=e=>typeof e=="function",Ee=e=>typeof e=="string",vo=e=>typeof e=="symbol",_e=e=>e!==null&&typeof e=="object",hs=e=>_e(e)&&le(e.then)&&le(e.catch),gs=Object.prototype.toString,Sa=e=>gs.call(e),ml=e=>Sa(e).slice(8,-1),fs=e=>Sa(e)==="[object Object]",bo=e=>Ee(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,xr=ho(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),wa=e=>{const n=Object.create(null);return r=>n[r]||(n[r]=e(r))},pl=/-(\w)/g,gn=wa(e=>e.replace(pl,(n,r)=>r?r.toUpperCase():"")),hl=/\B([A-Z])/g,rr=wa(e=>e.replace(hl,"-$1").toLowerCase()),Pa=wa(e=>e.charAt(0).toUpperCase()+e.slice(1)),La=wa(e=>e?`on${Pa(e)}`:""),Lr=(e,n)=>!Object.is(e,n),Da=(e,n)=>{for(let r=0;r<e.length;r++)e[r](n)},sa=(e,n,r)=>{Object.defineProperty(e,n,{configurable:!0,enumerable:!1,value:r})},vs=e=>{const n=parseFloat(e);return isNaN(n)?e:n};let Ko;const gl=()=>Ko||(Ko=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});let Qe;class fl{constructor(n=!1){this.active=!0,this.effects=[],this.cleanups=[],!n&&Qe&&(this.parent=Qe,this.index=(Qe.scopes||(Qe.scopes=[])).push(this)-1)}run(n){if(this.active){const r=Qe;try{return Qe=this,n()}finally{Qe=r}}}on(){Qe=this}off(){Qe=this.parent}stop(n){if(this.active){let r,a;for(r=0,a=this.effects.length;r<a;r++)this.effects[r].stop();for(r=0,a=this.cleanups.length;r<a;r++)this.cleanups[r]();if(this.scopes)for(r=0,a=this.scopes.length;r<a;r++)this.scopes[r].stop(!0);if(this.parent&&!n){const o=this.parent.scopes.pop();o&&o!==this&&(this.parent.scopes[this.index]=o,o.index=this.index)}this.active=!1}}}function vl(e,n=Qe){n&&n.active&&n.effects.push(e)}function bl(){return Qe}function yl(e){Qe&&Qe.cleanups.push(e)}const yo=e=>{const n=new Set(e);return n.w=0,n.n=0,n},bs=e=>(e.w&Mn)>0,ys=e=>(e.n&Mn)>0,Sl=({deps:e})=>{if(e.length)for(let n=0;n<e.length;n++)e[n].w|=Mn},wl=e=>{const{deps:n}=e;if(n.length){let r=0;for(let a=0;a<n.length;a++){const o=n[a];bs(o)&&!ys(o)?o.delete(e):n[r++]=o,o.w&=~Mn,o.n&=~Mn}n.length=r}},Ka=new WeakMap;let jr=0,Mn=1;const $a=30;let sn;const Zn=Symbol(""),Ya=Symbol("");class So{constructor(n,r=null,a){this.fn=n,this.scheduler=r,this.active=!0,this.deps=[],this.parent=void 0,vl(this,a)}run(){if(!this.active)return this.fn();let n=sn,r=Rn;for(;n;){if(n===this)return;n=n.parent}try{return this.parent=sn,sn=this,Rn=!0,Mn=1<<++jr,jr<=$a?Sl(this):$o(this),this.fn()}finally{jr<=$a&&wl(this),Mn=1<<--jr,sn=this.parent,Rn=r,this.parent=void 0,this.deferStop&&this.stop()}}stop(){sn===this?this.deferStop=!0:this.active&&($o(this),this.onStop&&this.onStop(),this.active=!1)}}function $o(e){const{deps:n}=e;if(n.length){for(let r=0;r<n.length;r++)n[r].delete(e);n.length=0}}let Rn=!0;const Ss=[];function br(){Ss.push(Rn),Rn=!1}function yr(){const e=Ss.pop();Rn=e===void 0?!0:e}function en(e,n,r){if(Rn&&sn){let a=Ka.get(e);a||Ka.set(e,a=new Map);let o=a.get(r);o||a.set(r,o=yo()),ws(o)}}function ws(e,n){let r=!1;jr<=$a?ys(e)||(e.n|=Mn,r=!bs(e)):r=!e.has(sn),r&&(e.add(sn),sn.deps.push(e))}function En(e,n,r,a,o,t){const s=Ka.get(e);if(!s)return;let i=[];if(n==="clear")i=[...s.values()];else if(r==="length"&&oe(e))s.forEach((l,c)=>{(c==="length"||c>=a)&&i.push(l)});else switch(r!==void 0&&i.push(s.get(r)),n){case"add":oe(e)?bo(r)&&i.push(s.get("length")):(i.push(s.get(Zn)),cr(e)&&i.push(s.get(Ya)));break;case"delete":oe(e)||(i.push(s.get(Zn)),cr(e)&&i.push(s.get(Ya)));break;case"set":cr(e)&&i.push(s.get(Zn));break}if(i.length===1)i[0]&&Qa(i[0]);else{const l=[];for(const c of i)c&&l.push(...c);Qa(yo(l))}}function Qa(e,n){const r=oe(e)?e:[...e];for(const a of r)a.computed&&Yo(a);for(const a of r)a.computed||Yo(a)}function Yo(e,n){(e!==sn||e.allowRecurse)&&(e.scheduler?e.scheduler():e.run())}const Pl=ho("__proto__,__v_isRef,__isVue"),Ps=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(vo)),El=wo(),ql=wo(!1,!0),Cl=wo(!0),Qo=kl();function kl(){const e={};return["includes","indexOf","lastIndexOf"].forEach(n=>{e[n]=function(...r){const a=Se(this);for(let t=0,s=this.length;t<s;t++)en(a,"get",t+"");const o=a[n](...r);return o===-1||o===!1?a[n](...r.map(Se)):o}}),["push","pop","shift","unshift","splice"].forEach(n=>{e[n]=function(...r){br();const a=Se(this)[n].apply(this,r);return yr(),a}}),e}function wo(e=!1,n=!1){return function(a,o,t){if(o==="__v_isReactive")return!e;if(o==="__v_isReadonly")return e;if(o==="__v_isShallow")return n;if(o==="__v_raw"&&t===(e?n?Ul:js:n?ks:Cs).get(a))return a;const s=oe(a);if(!e&&s&&he(Qo,o))return Reflect.get(Qo,o,t);const i=Reflect.get(a,o,t);return(vo(o)?Ps.has(o):Pl(o))||(e||en(a,"get",o),n)?i:Ne(i)?s&&bo(o)?i:i.value:_e(i)?e?qo(i):Sr(i):i}}const jl=Es(),xl=Es(!0);function Es(e=!1){return function(r,a,o,t){let s=r[a];if(pr(s)&&Ne(s)&&!Ne(o))return!1;if(!e&&(!ia(o)&&!pr(o)&&(s=Se(s),o=Se(o)),!oe(r)&&Ne(s)&&!Ne(o)))return s.value=o,!0;const i=oe(r)&&bo(a)?Number(a)<r.length:he(r,a),l=Reflect.set(r,a,o,t);return r===Se(t)&&(i?Lr(o,s)&&En(r,"set",a,o):En(r,"add",a,o)),l}}function Al(e,n){const r=he(e,n);e[n];const a=Reflect.deleteProperty(e,n);return a&&r&&En(e,"delete",n,void 0),a}function Il(e,n){const r=Reflect.has(e,n);return(!vo(n)||!Ps.has(n))&&en(e,"has",n),r}function _l(e){return en(e,"iterate",oe(e)?"length":Zn),Reflect.ownKeys(e)}const qs={get:El,set:jl,deleteProperty:Al,has:Il,ownKeys:_l},Tl={get:Cl,set(e,n){return!0},deleteProperty(e,n){return!0}},Ll=Ue({},qs,{get:ql,set:xl}),Po=e=>e,Ea=e=>Reflect.getPrototypeOf(e);function Kr(e,n,r=!1,a=!1){e=e.__v_raw;const o=Se(e),t=Se(n);r||(n!==t&&en(o,"get",n),en(o,"get",t));const{has:s}=Ea(o),i=a?Po:r?ko:Dr;if(s.call(o,n))return i(e.get(n));if(s.call(o,t))return i(e.get(t));e!==o&&e.get(n)}function $r(e,n=!1){const r=this.__v_raw,a=Se(r),o=Se(e);return n||(e!==o&&en(a,"has",e),en(a,"has",o)),e===o?r.has(e):r.has(e)||r.has(o)}function Yr(e,n=!1){return e=e.__v_raw,!n&&en(Se(e),"iterate",Zn),Reflect.get(e,"size",e)}function Xo(e){e=Se(e);const n=Se(this);return Ea(n).has.call(n,e)||(n.add(e),En(n,"add",e,e)),this}function Zo(e,n){n=Se(n);const r=Se(this),{has:a,get:o}=Ea(r);let t=a.call(r,e);t||(e=Se(e),t=a.call(r,e));const s=o.call(r,e);return r.set(e,n),t?Lr(n,s)&&En(r,"set",e,n):En(r,"add",e,n),this}function et(e){const n=Se(this),{has:r,get:a}=Ea(n);let o=r.call(n,e);o||(e=Se(e),o=r.call(n,e)),a&&a.call(n,e);const t=n.delete(e);return o&&En(n,"delete",e,void 0),t}function nt(){const e=Se(this),n=e.size!==0,r=e.clear();return n&&En(e,"clear",void 0,void 0),r}function Qr(e,n){return function(a,o){const t=this,s=t.__v_raw,i=Se(s),l=n?Po:e?ko:Dr;return!e&&en(i,"iterate",Zn),s.forEach((c,d)=>a.call(o,l(c),l(d),t))}}function Xr(e,n,r){return function(...a){const o=this.__v_raw,t=Se(o),s=cr(t),i=e==="entries"||e===Symbol.iterator&&s,l=e==="keys"&&s,c=o[e](...a),d=r?Po:n?ko:Dr;return!n&&en(t,"iterate",l?Ya:Zn),{next(){const{value:m,done:u}=c.next();return u?{value:m,done:u}:{value:i?[d(m[0]),d(m[1])]:d(m),done:u}},[Symbol.iterator](){return this}}}}function xn(e){return function(...n){return e==="delete"?!1:this}}function Dl(){const e={get(t){return Kr(this,t)},get size(){return Yr(this)},has:$r,add:Xo,set:Zo,delete:et,clear:nt,forEach:Qr(!1,!1)},n={get(t){return Kr(this,t,!1,!0)},get size(){return Yr(this)},has:$r,add:Xo,set:Zo,delete:et,clear:nt,forEach:Qr(!1,!0)},r={get(t){return Kr(this,t,!0)},get size(){return Yr(this,!0)},has(t){return $r.call(this,t,!0)},add:xn("add"),set:xn("set"),delete:xn("delete"),clear:xn("clear"),forEach:Qr(!0,!1)},a={get(t){return Kr(this,t,!0,!0)},get size(){return Yr(this,!0)},has(t){return $r.call(this,t,!0)},add:xn("add"),set:xn("set"),delete:xn("delete"),clear:xn("clear"),forEach:Qr(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(t=>{e[t]=Xr(t,!1,!1),r[t]=Xr(t,!0,!1),n[t]=Xr(t,!1,!0),a[t]=Xr(t,!0,!0)}),[e,r,n,a]}const[Rl,zl,Ol,Ml]=Dl();function Eo(e,n){const r=n?e?Ml:Ol:e?zl:Rl;return(a,o,t)=>o==="__v_isReactive"?!e:o==="__v_isReadonly"?e:o==="__v_raw"?a:Reflect.get(he(r,o)&&o in a?r:a,o,t)}const Nl={get:Eo(!1,!1)},Bl={get:Eo(!1,!0)},Fl={get:Eo(!0,!1)},Cs=new WeakMap,ks=new WeakMap,js=new WeakMap,Ul=new WeakMap;function Hl(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Wl(e){return e.__v_skip||!Object.isExtensible(e)?0:Hl(ml(e))}function Sr(e){return pr(e)?e:Co(e,!1,qs,Nl,Cs)}function Vl(e){return Co(e,!1,Ll,Bl,ks)}function qo(e){return Co(e,!0,Tl,Fl,js)}function Co(e,n,r,a,o){if(!_e(e)||e.__v_raw&&!(n&&e.__v_isReactive))return e;const t=o.get(e);if(t)return t;const s=Wl(e);if(s===0)return e;const i=new Proxy(e,s===2?a:r);return o.set(e,i),i}function dr(e){return pr(e)?dr(e.__v_raw):!!(e&&e.__v_isReactive)}function pr(e){return!!(e&&e.__v_isReadonly)}function ia(e){return!!(e&&e.__v_isShallow)}function xs(e){return dr(e)||pr(e)}function Se(e){const n=e&&e.__v_raw;return n?Se(n):e}function As(e){return sa(e,"__v_skip",!0),e}const Dr=e=>_e(e)?Sr(e):e,ko=e=>_e(e)?qo(e):e;function Is(e){Rn&&sn&&(e=Se(e),ws(e.dep||(e.dep=yo())))}function _s(e,n){e=Se(e),e.dep&&Qa(e.dep)}function Ne(e){return!!(e&&e.__v_isRef===!0)}function qe(e){return Ls(e,!1)}function Ts(e){return Ls(e,!0)}function Ls(e,n){return Ne(e)?e:new Jl(e,n)}class Jl{constructor(n,r){this.__v_isShallow=r,this.dep=void 0,this.__v_isRef=!0,this._rawValue=r?n:Se(n),this._value=r?n:Dr(n)}get value(){return Is(this),this._value}set value(n){const r=this.__v_isShallow||ia(n)||pr(n);n=r?n:Se(n),Lr(n,this._rawValue)&&(this._rawValue=n,this._value=r?n:Dr(n),_s(this))}}function M(e){return Ne(e)?e.value:e}const Gl={get:(e,n,r)=>M(Reflect.get(e,n,r)),set:(e,n,r,a)=>{const o=e[n];return Ne(o)&&!Ne(r)?(o.value=r,!0):Reflect.set(e,n,r,a)}};function Ds(e){return dr(e)?e:new Proxy(e,Gl)}function qa(e){const n=oe(e)?new Array(e.length):{};for(const r in e)n[r]=$l(e,r);return n}class Kl{constructor(n,r,a){this._object=n,this._key=r,this._defaultValue=a,this.__v_isRef=!0}get value(){const n=this._object[this._key];return n===void 0?this._defaultValue:n}set value(n){this._object[this._key]=n}}function $l(e,n,r){const a=e[n];return Ne(a)?a:new Kl(e,n,r)}var Rs;class Yl{constructor(n,r,a,o){this._setter=r,this.dep=void 0,this.__v_isRef=!0,this[Rs]=!1,this._dirty=!0,this.effect=new So(n,()=>{this._dirty||(this._dirty=!0,_s(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!o,this.__v_isReadonly=a}get value(){const n=Se(this);return Is(n),(n._dirty||!n._cacheable)&&(n._dirty=!1,n._value=n.effect.run()),n._value}set value(n){this._setter(n)}}Rs="__v_isReadonly";function Ql(e,n,r=!1){let a,o;const t=le(e);return t?(a=e,o=cn):(a=e.get,o=e.set),new Yl(a,o,t||!o,r)}function zn(e,n,r,a){let o;try{o=a?e(...a):e()}catch(t){Ur(t,n,r)}return o}function an(e,n,r,a){if(le(e)){const t=zn(e,n,r,a);return t&&hs(t)&&t.catch(s=>{Ur(s,n,r)}),t}const o=[];for(let t=0;t<e.length;t++)o.push(an(e[t],n,r,a));return o}function Ur(e,n,r,a=!0){const o=n?n.vnode:null;if(n){let t=n.parent;const s=n.proxy,i=r;for(;t;){const c=t.ec;if(c){for(let d=0;d<c.length;d++)if(c[d](e,s,i)===!1)return}t=t.parent}const l=n.appContext.config.errorHandler;if(l){zn(l,null,10,[e,s,i]);return}}Xl(e,r,o,a)}function Xl(e,n,r,a=!0){console.error(e)}let Rr=!1,Xa=!1;const He=[];let hn=0;const ur=[];let bn=null,$n=0;const zs=Promise.resolve();let jo=null;function Hr(e){const n=jo||zs;return e?n.then(this?e.bind(this):e):n}function Zl(e){let n=hn+1,r=He.length;for(;n<r;){const a=n+r>>>1;zr(He[a])<e?n=a+1:r=a}return n}function Ca(e){(!He.length||!He.includes(e,Rr&&e.allowRecurse?hn+1:hn))&&(e.id==null?He.push(e):He.splice(Zl(e.id),0,e),Os())}function Os(){!Rr&&!Xa&&(Xa=!0,jo=zs.then(Ms))}function ec(e){const n=He.indexOf(e);n>hn&&He.splice(n,1)}function nc(e){oe(e)?ur.push(...e):(!bn||!bn.includes(e,e.allowRecurse?$n+1:$n))&&ur.push(e),Os()}function rt(e,n=Rr?hn+1:0){for(;n<He.length;n++){const r=He[n];r&&r.pre&&(He.splice(n,1),n--,r())}}function la(e){if(ur.length){const n=[...new Set(ur)];if(ur.length=0,bn){bn.push(...n);return}for(bn=n,bn.sort((r,a)=>zr(r)-zr(a)),$n=0;$n<bn.length;$n++)bn[$n]();bn=null,$n=0}}const zr=e=>e.id==null?1/0:e.id,rc=(e,n)=>{const r=zr(e)-zr(n);if(r===0){if(e.pre&&!n.pre)return-1;if(n.pre&&!e.pre)return 1}return r};function Ms(e){Xa=!1,Rr=!0,He.sort(rc);const n=cn;try{for(hn=0;hn<He.length;hn++){const r=He[hn];r&&r.active!==!1&&zn(r,null,14)}}finally{hn=0,He.length=0,la(),Rr=!1,jo=null,(He.length||ur.length)&&Ms()}}function ac(e,n,...r){if(e.isUnmounted)return;const a=e.vnode.props||je;let o=r;const t=n.startsWith("update:"),s=t&&n.slice(7);if(s&&s in a){const d=`${s==="modelValue"?"model":s}Modifiers`,{number:m,trim:u}=a[d]||je;u&&(o=r.map(p=>p.trim())),m&&(o=r.map(vs))}let i,l=a[i=La(n)]||a[i=La(gn(n))];!l&&t&&(l=a[i=La(rr(n))]),l&&an(l,e,6,o);const c=a[i+"Once"];if(c){if(!e.emitted)e.emitted={};else if(e.emitted[i])return;e.emitted[i]=!0,an(c,e,6,o)}}function Ns(e,n,r=!1){const a=n.emitsCache,o=a.get(e);if(o!==void 0)return o;const t=e.emits;let s={},i=!1;if(!le(e)){const l=c=>{const d=Ns(c,n,!0);d&&(i=!0,Ue(s,d))};!r&&n.mixins.length&&n.mixins.forEach(l),e.extends&&l(e.extends),e.mixins&&e.mixins.forEach(l)}return!t&&!i?(_e(e)&&a.set(e,null),null):(oe(t)?t.forEach(l=>s[l]=null):Ue(s,t),_e(e)&&a.set(e,s),s)}function ka(e,n){return!e||!Fr(n)?!1:(n=n.slice(2).replace(/Once$/,""),he(e,n[0].toLowerCase()+n.slice(1))||he(e,rr(n))||he(e,n))}let We=null,Bs=null;function ca(e){const n=We;return We=e,Bs=e&&e.type.__scopeId||null,n}function Fe(e,n=We,r){if(!n||e._n)return e;const a=(...o)=>{a._d&&pt(-1);const t=ca(n),s=e(...o);return ca(t),a._d&&pt(1),s};return a._n=!0,a._c=!0,a._d=!0,a}function Ra(e){const{type:n,vnode:r,proxy:a,withProxy:o,props:t,propsOptions:[s],slots:i,attrs:l,emit:c,render:d,renderCache:m,data:u,setupState:p,ctx:b,inheritAttrs:q}=e;let w,f;const S=ca(e);try{if(r.shapeFlag&4){const R=o||a;w=tn(d.call(R,R,m,t,p,u,b)),f=l}else{const R=n;w=tn(R.length>1?R(t,{attrs:l,slots:i,emit:c}):R(t,null)),f=n.props?l:oc(l)}}catch(R){Ir.length=0,Ur(R,e,1),w=se(Ze)}let C=w;if(f&&q!==!1){const R=Object.keys(f),{shapeFlag:U}=C;R.length&&U&7&&(s&&R.some(go)&&(f=tc(f,s)),C=Bn(C,f))}return r.dirs&&(C=Bn(C),C.dirs=C.dirs?C.dirs.concat(r.dirs):r.dirs),r.transition&&(C.transition=r.transition),w=C,ca(S),w}const oc=e=>{let n;for(const r in e)(r==="class"||r==="style"||Fr(r))&&((n||(n={}))[r]=e[r]);return n},tc=(e,n)=>{const r={};for(const a in e)(!go(a)||!(a.slice(9)in n))&&(r[a]=e[a]);return r};function sc(e,n,r){const{props:a,children:o,component:t}=e,{props:s,children:i,patchFlag:l}=n,c=t.emitsOptions;if(n.dirs||n.transition)return!0;if(r&&l>=0){if(l&1024)return!0;if(l&16)return a?at(a,s,c):!!s;if(l&8){const d=n.dynamicProps;for(let m=0;m<d.length;m++){const u=d[m];if(s[u]!==a[u]&&!ka(c,u))return!0}}}else return(o||i)&&(!i||!i.$stable)?!0:a===s?!1:a?s?at(a,s,c):!0:!!s;return!1}function at(e,n,r){const a=Object.keys(n);if(a.length!==Object.keys(e).length)return!0;for(let o=0;o<a.length;o++){const t=a[o];if(n[t]!==e[t]&&!ka(r,t))return!0}return!1}function ic({vnode:e,parent:n},r){for(;n&&n.subTree===e;)(e=n.vnode).el=r,n=n.parent}const lc=e=>e.__isSuspense;function Fs(e,n){n&&n.pendingBranch?oe(e)?n.effects.push(...e):n.effects.push(e):nc(e)}function er(e,n){if(Oe){let r=Oe.provides;const a=Oe.parent&&Oe.parent.provides;a===r&&(r=Oe.provides=Object.create(a)),r[e]=n}}function Be(e,n,r=!1){const a=Oe||We;if(a){const o=a.parent==null?a.vnode.appContext&&a.vnode.appContext.provides:a.parent.provides;if(o&&e in o)return o[e];if(arguments.length>1)return r&&le(n)?n.call(a.proxy):n}}const ot={};function dn(e,n,r){return Us(e,n,r)}function Us(e,n,{immediate:r,deep:a,flush:o,onTrack:t,onTrigger:s}=je){const i=Oe;let l,c=!1,d=!1;if(Ne(e)?(l=()=>e.value,c=ia(e)):dr(e)?(l=()=>e,a=!0):oe(e)?(d=!0,c=e.some(f=>dr(f)||ia(f)),l=()=>e.map(f=>{if(Ne(f))return f.value;if(dr(f))return Xn(f);if(le(f))return zn(f,i,2)})):le(e)?n?l=()=>zn(e,i,2):l=()=>{if(!(i&&i.isUnmounted))return m&&m(),an(e,i,3,[u])}:l=cn,n&&a){const f=l;l=()=>Xn(f())}let m,u=f=>{m=w.onStop=()=>{zn(f,i,4)}};if(gr)return u=cn,n?r&&an(n,i,3,[l(),d?[]:void 0,u]):l(),cn;let p=d?[]:ot;const b=()=>{if(!!w.active)if(n){const f=w.run();(a||c||(d?f.some((S,C)=>Lr(S,p[C])):Lr(f,p)))&&(m&&m(),an(n,i,3,[f,p===ot?void 0:p,u]),p=f)}else w.run()};b.allowRecurse=!!n;let q;o==="sync"?q=b:o==="post"?q=()=>Ge(b,i&&i.suspense):(b.pre=!0,i&&(b.id=i.uid),q=()=>Ca(b));const w=new So(l,q);return n?r?b():p=w.run():o==="post"?Ge(w.run.bind(w),i&&i.suspense):w.run(),()=>{w.stop(),i&&i.scope&&fo(i.scope.effects,w)}}function cc(e,n,r){const a=this.proxy,o=Ee(e)?e.includes(".")?Hs(a,e):()=>a[e]:e.bind(a,a);let t;le(n)?t=n:(t=n.handler,r=n);const s=Oe;hr(this);const i=Us(o,t.bind(a),r);return s?hr(s):nr(),i}function Hs(e,n){const r=n.split(".");return()=>{let a=e;for(let o=0;o<r.length&&a;o++)a=a[r[o]];return a}}function Xn(e,n){if(!_e(e)||e.__v_skip||(n=n||new Set,n.has(e)))return e;if(n.add(e),Ne(e))Xn(e.value,n);else if(oe(e))for(let r=0;r<e.length;r++)Xn(e[r],n);else if(ps(e)||cr(e))e.forEach(r=>{Xn(r,n)});else if(fs(e))for(const r in e)Xn(e[r],n);return e}function dc(){const e={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return Ke(()=>{e.isMounted=!0}),Vr(()=>{e.isUnmounting=!0}),e}const nn=[Function,Array],uc={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:nn,onEnter:nn,onAfterEnter:nn,onEnterCancelled:nn,onBeforeLeave:nn,onLeave:nn,onAfterLeave:nn,onLeaveCancelled:nn,onBeforeAppear:nn,onAppear:nn,onAfterAppear:nn,onAppearCancelled:nn},setup(e,{slots:n}){const r=_o(),a=dc();let o;return()=>{const t=n.default&&Js(n.default(),!0);if(!t||!t.length)return;let s=t[0];if(t.length>1){for(const q of t)if(q.type!==Ze){s=q;break}}const i=Se(e),{mode:l}=i;if(a.isLeaving)return za(s);const c=tt(s);if(!c)return za(s);const d=Za(c,i,a,r);eo(c,d);const m=r.subTree,u=m&&tt(m);let p=!1;const{getTransitionKey:b}=c.type;if(b){const q=b();o===void 0?o=q:q!==o&&(o=q,p=!0)}if(u&&u.type!==Ze&&(!Yn(c,u)||p)){const q=Za(u,i,a,r);if(eo(u,q),l==="out-in")return a.isLeaving=!0,q.afterLeave=()=>{a.isLeaving=!1,r.update()},za(s);l==="in-out"&&c.type!==Ze&&(q.delayLeave=(w,f,S)=>{const C=Vs(a,u);C[String(u.key)]=u,w._leaveCb=()=>{f(),w._leaveCb=void 0,delete d.delayedLeave},d.delayedLeave=S})}return s}}},Ws=uc;function Vs(e,n){const{leavingVNodes:r}=e;let a=r.get(n.type);return a||(a=Object.create(null),r.set(n.type,a)),a}function Za(e,n,r,a){const{appear:o,mode:t,persisted:s=!1,onBeforeEnter:i,onEnter:l,onAfterEnter:c,onEnterCancelled:d,onBeforeLeave:m,onLeave:u,onAfterLeave:p,onLeaveCancelled:b,onBeforeAppear:q,onAppear:w,onAfterAppear:f,onAppearCancelled:S}=n,C=String(e.key),R=Vs(r,e),U=(g,Y)=>{g&&an(g,a,9,Y)},X=(g,Y)=>{const W=Y[1];U(g,Y),oe(g)?g.every(D=>D.length<=1)&&W():g.length<=1&&W()},x={mode:t,persisted:s,beforeEnter(g){let Y=i;if(!r.isMounted)if(o)Y=q||i;else return;g._leaveCb&&g._leaveCb(!0);const W=R[C];W&&Yn(e,W)&&W.el._leaveCb&&W.el._leaveCb(),U(Y,[g])},enter(g){let Y=l,W=c,D=d;if(!r.isMounted)if(o)Y=w||l,W=f||c,D=S||d;else return;let y=!1;const P=g._enterCb=j=>{y||(y=!0,j?U(D,[g]):U(W,[g]),x.delayedLeave&&x.delayedLeave(),g._enterCb=void 0)};Y?X(Y,[g,P]):P()},leave(g,Y){const W=String(e.key);if(g._enterCb&&g._enterCb(!0),r.isUnmounting)return Y();U(m,[g]);let D=!1;const y=g._leaveCb=P=>{D||(D=!0,Y(),P?U(b,[g]):U(p,[g]),g._leaveCb=void 0,R[W]===e&&delete R[W])};R[W]=e,u?X(u,[g,y]):y()},clone(g){return Za(g,n,r,a)}};return x}function za(e){if(Wr(e))return e=Bn(e),e.children=null,e}function tt(e){return Wr(e)?e.children?e.children[0]:void 0:e}function eo(e,n){e.shapeFlag&6&&e.component?eo(e.component.subTree,n):e.shapeFlag&128?(e.ssContent.transition=n.clone(e.ssContent),e.ssFallback.transition=n.clone(e.ssFallback)):e.transition=n}function Js(e,n=!1,r){let a=[],o=0;for(let t=0;t<e.length;t++){let s=e[t];const i=r==null?s.key:String(r)+String(s.key!=null?s.key:t);s.type===Ae?(s.patchFlag&128&&o++,a=a.concat(Js(s.children,n,i))):(n||s.type!==Ze)&&a.push(i!=null?Bn(s,{key:i}):s)}if(o>1)for(let t=0;t<a.length;t++)a[t].patchFlag=-2;return a}function ge(e){return le(e)?{setup:e,name:e.name}:e}const mr=e=>!!e.type.__asyncLoader;function Z(e){le(e)&&(e={loader:e});const{loader:n,loadingComponent:r,errorComponent:a,delay:o=200,timeout:t,suspensible:s=!0,onError:i}=e;let l=null,c,d=0;const m=()=>(d++,l=null,u()),u=()=>{let p;return l||(p=l=n().catch(b=>{if(b=b instanceof Error?b:new Error(String(b)),i)return new Promise((q,w)=>{i(b,()=>q(m()),()=>w(b),d+1)});throw b}).then(b=>p!==l&&l?l:(b&&(b.__esModule||b[Symbol.toStringTag]==="Module")&&(b=b.default),c=b,b)))};return ge({name:"AsyncComponentWrapper",__asyncLoader:u,get __asyncResolved(){return c},setup(){const p=Oe;if(c)return()=>Oa(c,p);const b=S=>{l=null,Ur(S,p,13,!a)};if(s&&p.suspense||gr)return u().then(S=>()=>Oa(S,p)).catch(S=>(b(S),()=>a?se(a,{error:S}):null));const q=qe(!1),w=qe(),f=qe(!!o);return o&&setTimeout(()=>{f.value=!1},o),t!=null&&setTimeout(()=>{if(!q.value&&!w.value){const S=new Error(`Async component timed out after ${t}ms.`);b(S),w.value=S}},t),u().then(()=>{q.value=!0,p.parent&&Wr(p.parent.vnode)&&Ca(p.parent.update)}).catch(S=>{b(S),w.value=S}),()=>{if(q.value&&c)return Oa(c,p);if(w.value&&a)return se(a,{error:w.value});if(r&&!f.value)return se(r)}}})}function Oa(e,{vnode:{ref:n,props:r,children:a,shapeFlag:o},parent:t}){const s=se(e,r,a);return s.ref=n,s}const Wr=e=>e.type.__isKeepAlive;function mc(e,n){Gs(e,"a",n)}function pc(e,n){Gs(e,"da",n)}function Gs(e,n,r=Oe){const a=e.__wdc||(e.__wdc=()=>{let o=r;for(;o;){if(o.isDeactivated)return;o=o.parent}return e()});if(ja(n,a,r),r){let o=r.parent;for(;o&&o.parent;)Wr(o.parent.vnode)&&hc(a,n,r,o),o=o.parent}}function hc(e,n,r,a){const o=ja(n,e,a,!0);xa(()=>{fo(a[n],o)},r)}function ja(e,n,r=Oe,a=!1){if(r){const o=r[e]||(r[e]=[]),t=n.__weh||(n.__weh=(...s)=>{if(r.isUnmounted)return;br(),hr(r);const i=an(n,r,e,s);return nr(),yr(),i});return a?o.unshift(t):o.push(t),t}}const Cn=e=>(n,r=Oe)=>(!gr||e==="sp")&&ja(e,n,r),Ks=Cn("bm"),Ke=Cn("m"),gc=Cn("bu"),fc=Cn("u"),Vr=Cn("bum"),xa=Cn("um"),vc=Cn("sp"),bc=Cn("rtg"),yc=Cn("rtc");function Sc(e,n=Oe){ja("ec",e,n)}function da(e,n){const r=We;if(r===null)return e;const a=Ia(r)||r.proxy,o=e.dirs||(e.dirs=[]);for(let t=0;t<n.length;t++){let[s,i,l,c=je]=n[t];le(s)&&(s={mounted:s,updated:s}),s.deep&&Xn(i),o.push({dir:s,instance:a,value:i,oldValue:void 0,arg:l,modifiers:c})}return e}function pn(e,n,r,a){const o=e.dirs,t=n&&n.dirs;for(let s=0;s<o.length;s++){const i=o[s];t&&(i.oldValue=t[s].value);let l=i.dir[a];l&&(br(),an(l,r,8,[e.el,i,e,n]),yr())}}const $s="components";function qn(e,n){return Pc($s,e,!0,n)||e}const wc=Symbol();function Pc(e,n,r=!0,a=!1){const o=We||Oe;if(o){const t=o.type;if(e===$s){const i=Xc(t,!1);if(i&&(i===n||i===gn(n)||i===Pa(gn(n))))return t}const s=st(o[e]||t[e],n)||st(o.appContext[e],n);return!s&&a?t:s}}function st(e,n){return e&&(e[n]||e[gn(n)]||e[Pa(gn(n))])}function Nn(e,n,r,a){let o;const t=r&&r[a];if(oe(e)||Ee(e)){o=new Array(e.length);for(let s=0,i=e.length;s<i;s++)o[s]=n(e[s],s,void 0,t&&t[s])}else if(typeof e=="number"){o=new Array(e);for(let s=0;s<e;s++)o[s]=n(s+1,s,void 0,t&&t[s])}else if(_e(e))if(e[Symbol.iterator])o=Array.from(e,(s,i)=>n(s,i,void 0,t&&t[i]));else{const s=Object.keys(e);o=new Array(s.length);for(let i=0,l=s.length;i<l;i++){const c=s[i];o[i]=n(e[c],c,i,t&&t[i])}}else o=[];return r&&(r[a]=o),o}function xe(e,n,r={},a,o){if(We.isCE||We.parent&&mr(We.parent)&&We.parent.isCE)return se("slot",n==="default"?null:{name:n},a&&a());let t=e[n];t&&t._c&&(t._d=!1),V();const s=t&&Ys(t(r)),i=ze(Ae,{key:r.key||s&&s.key||`_${n}`},s||(a?a():[]),s&&e._===1?64:-2);return!o&&i.scopeId&&(i.slotScopeIds=[i.scopeId+"-s"]),t&&t._c&&(t._d=!0),i}function Ys(e){return e.some(n=>ha(n)?!(n.type===Ze||n.type===Ae&&!Ys(n.children)):!0)?e:null}const no=e=>e?ii(e)?Ia(e)||e.proxy:no(e.parent):null,ua=Ue(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>no(e.parent),$root:e=>no(e.root),$emit:e=>e.emit,$options:e=>xo(e),$forceUpdate:e=>e.f||(e.f=()=>Ca(e.update)),$nextTick:e=>e.n||(e.n=Hr.bind(e.proxy)),$watch:e=>cc.bind(e)}),Ec={get({_:e},n){const{ctx:r,setupState:a,data:o,props:t,accessCache:s,type:i,appContext:l}=e;let c;if(n[0]!=="$"){const p=s[n];if(p!==void 0)switch(p){case 1:return a[n];case 2:return o[n];case 4:return r[n];case 3:return t[n]}else{if(a!==je&&he(a,n))return s[n]=1,a[n];if(o!==je&&he(o,n))return s[n]=2,o[n];if((c=e.propsOptions[0])&&he(c,n))return s[n]=3,t[n];if(r!==je&&he(r,n))return s[n]=4,r[n];ro&&(s[n]=0)}}const d=ua[n];let m,u;if(d)return n==="$attrs"&&en(e,"get",n),d(e);if((m=i.__cssModules)&&(m=m[n]))return m;if(r!==je&&he(r,n))return s[n]=4,r[n];if(u=l.config.globalProperties,he(u,n))return u[n]},set({_:e},n,r){const{data:a,setupState:o,ctx:t}=e;return o!==je&&he(o,n)?(o[n]=r,!0):a!==je&&he(a,n)?(a[n]=r,!0):he(e.props,n)||n[0]==="$"&&n.slice(1)in e?!1:(t[n]=r,!0)},has({_:{data:e,setupState:n,accessCache:r,ctx:a,appContext:o,propsOptions:t}},s){let i;return!!r[s]||e!==je&&he(e,s)||n!==je&&he(n,s)||(i=t[0])&&he(i,s)||he(a,s)||he(ua,s)||he(o.config.globalProperties,s)},defineProperty(e,n,r){return r.get!=null?e._.accessCache[n]=0:he(r,"value")&&this.set(e,n,r.value,null),Reflect.defineProperty(e,n,r)}};let ro=!0;function qc(e){const n=xo(e),r=e.proxy,a=e.ctx;ro=!1,n.beforeCreate&&it(n.beforeCreate,e,"bc");const{data:o,computed:t,methods:s,watch:i,provide:l,inject:c,created:d,beforeMount:m,mounted:u,beforeUpdate:p,updated:b,activated:q,deactivated:w,beforeDestroy:f,beforeUnmount:S,destroyed:C,unmounted:R,render:U,renderTracked:X,renderTriggered:x,errorCaptured:g,serverPrefetch:Y,expose:W,inheritAttrs:D,components:y,directives:P,filters:j}=n;if(c&&Cc(c,a,null,e.appContext.config.unwrapInjectedRef),s)for(const N in s){const G=s[N];le(G)&&(a[N]=G.bind(r))}if(o){const N=o.call(r,r);_e(N)&&(e.data=Sr(N))}if(ro=!0,t)for(const N in t){const G=t[N],ce=le(G)?G.bind(r,r):le(G.get)?G.get.bind(r,r):cn,ue=!le(G)&&le(G.set)?G.set.bind(r):cn,we=J({get:ce,set:ue});Object.defineProperty(a,N,{enumerable:!0,configurable:!0,get:()=>we.value,set:De=>we.value=De})}if(i)for(const N in i)Qs(i[N],a,r,N);if(l){const N=le(l)?l.call(r):l;Reflect.ownKeys(N).forEach(G=>{er(G,N[G])})}d&&it(d,e,"c");function I(N,G){oe(G)?G.forEach(ce=>N(ce.bind(r))):G&&N(G.bind(r))}if(I(Ks,m),I(Ke,u),I(gc,p),I(fc,b),I(mc,q),I(pc,w),I(Sc,g),I(yc,X),I(bc,x),I(Vr,S),I(xa,R),I(vc,Y),oe(W))if(W.length){const N=e.exposed||(e.exposed={});W.forEach(G=>{Object.defineProperty(N,G,{get:()=>r[G],set:ce=>r[G]=ce})})}else e.exposed||(e.exposed={});U&&e.render===cn&&(e.render=U),D!=null&&(e.inheritAttrs=D),y&&(e.components=y),P&&(e.directives=P)}function Cc(e,n,r=cn,a=!1){oe(e)&&(e=ao(e));for(const o in e){const t=e[o];let s;_e(t)?"default"in t?s=Be(t.from||o,t.default,!0):s=Be(t.from||o):s=Be(t),Ne(s)&&a?Object.defineProperty(n,o,{enumerable:!0,configurable:!0,get:()=>s.value,set:i=>s.value=i}):n[o]=s}}function it(e,n,r){an(oe(e)?e.map(a=>a.bind(n.proxy)):e.bind(n.proxy),n,r)}function Qs(e,n,r,a){const o=a.includes(".")?Hs(r,a):()=>r[a];if(Ee(e)){const t=n[e];le(t)&&dn(o,t)}else if(le(e))dn(o,e.bind(r));else if(_e(e))if(oe(e))e.forEach(t=>Qs(t,n,r,a));else{const t=le(e.handler)?e.handler.bind(r):n[e.handler];le(t)&&dn(o,t,e)}}function xo(e){const n=e.type,{mixins:r,extends:a}=n,{mixins:o,optionsCache:t,config:{optionMergeStrategies:s}}=e.appContext,i=t.get(n);let l;return i?l=i:!o.length&&!r&&!a?l=n:(l={},o.length&&o.forEach(c=>ma(l,c,s,!0)),ma(l,n,s)),_e(n)&&t.set(n,l),l}function ma(e,n,r,a=!1){const{mixins:o,extends:t}=n;t&&ma(e,t,r,!0),o&&o.forEach(s=>ma(e,s,r,!0));for(const s in n)if(!(a&&s==="expose")){const i=kc[s]||r&&r[s];e[s]=i?i(e[s],n[s]):n[s]}return e}const kc={data:lt,props:Jn,emits:Jn,methods:Jn,computed:Jn,beforeCreate:Ve,created:Ve,beforeMount:Ve,mounted:Ve,beforeUpdate:Ve,updated:Ve,beforeDestroy:Ve,beforeUnmount:Ve,destroyed:Ve,unmounted:Ve,activated:Ve,deactivated:Ve,errorCaptured:Ve,serverPrefetch:Ve,components:Jn,directives:Jn,watch:xc,provide:lt,inject:jc};function lt(e,n){return n?e?function(){return Ue(le(e)?e.call(this,this):e,le(n)?n.call(this,this):n)}:n:e}function jc(e,n){return Jn(ao(e),ao(n))}function ao(e){if(oe(e)){const n={};for(let r=0;r<e.length;r++)n[e[r]]=e[r];return n}return e}function Ve(e,n){return e?[...new Set([].concat(e,n))]:n}function Jn(e,n){return e?Ue(Ue(Object.create(null),e),n):n}function xc(e,n){if(!e)return n;if(!n)return e;const r=Ue(Object.create(null),e);for(const a in n)r[a]=Ve(e[a],n[a]);return r}function Ac(e,n,r,a=!1){const o={},t={};sa(t,Aa,1),e.propsDefaults=Object.create(null),Xs(e,n,o,t);for(const s in e.propsOptions[0])s in o||(o[s]=void 0);r?e.props=a?o:Vl(o):e.type.props?e.props=o:e.props=t,e.attrs=t}function Ic(e,n,r,a){const{props:o,attrs:t,vnode:{patchFlag:s}}=e,i=Se(o),[l]=e.propsOptions;let c=!1;if((a||s>0)&&!(s&16)){if(s&8){const d=e.vnode.dynamicProps;for(let m=0;m<d.length;m++){let u=d[m];if(ka(e.emitsOptions,u))continue;const p=n[u];if(l)if(he(t,u))p!==t[u]&&(t[u]=p,c=!0);else{const b=gn(u);o[b]=oo(l,i,b,p,e,!1)}else p!==t[u]&&(t[u]=p,c=!0)}}}else{Xs(e,n,o,t)&&(c=!0);let d;for(const m in i)(!n||!he(n,m)&&((d=rr(m))===m||!he(n,d)))&&(l?r&&(r[m]!==void 0||r[d]!==void 0)&&(o[m]=oo(l,i,m,void 0,e,!0)):delete o[m]);if(t!==i)for(const m in t)(!n||!he(n,m)&&!0)&&(delete t[m],c=!0)}c&&En(e,"set","$attrs")}function Xs(e,n,r,a){const[o,t]=e.propsOptions;let s=!1,i;if(n)for(let l in n){if(xr(l))continue;const c=n[l];let d;o&&he(o,d=gn(l))?!t||!t.includes(d)?r[d]=c:(i||(i={}))[d]=c:ka(e.emitsOptions,l)||(!(l in a)||c!==a[l])&&(a[l]=c,s=!0)}if(t){const l=Se(r),c=i||je;for(let d=0;d<t.length;d++){const m=t[d];r[m]=oo(o,l,m,c[m],e,!he(c,m))}}return s}function oo(e,n,r,a,o,t){const s=e[r];if(s!=null){const i=he(s,"default");if(i&&a===void 0){const l=s.default;if(s.type!==Function&&le(l)){const{propsDefaults:c}=o;r in c?a=c[r]:(hr(o),a=c[r]=l.call(null,n),nr())}else a=l}s[0]&&(t&&!i?a=!1:s[1]&&(a===""||a===rr(r))&&(a=!0))}return a}function Zs(e,n,r=!1){const a=n.propsCache,o=a.get(e);if(o)return o;const t=e.props,s={},i=[];let l=!1;if(!le(e)){const d=m=>{l=!0;const[u,p]=Zs(m,n,!0);Ue(s,u),p&&i.push(...p)};!r&&n.mixins.length&&n.mixins.forEach(d),e.extends&&d(e.extends),e.mixins&&e.mixins.forEach(d)}if(!t&&!l)return _e(e)&&a.set(e,lr),lr;if(oe(t))for(let d=0;d<t.length;d++){const m=gn(t[d]);ct(m)&&(s[m]=je)}else if(t)for(const d in t){const m=gn(d);if(ct(m)){const u=t[d],p=s[m]=oe(u)||le(u)?{type:u}:u;if(p){const b=mt(Boolean,p.type),q=mt(String,p.type);p[0]=b>-1,p[1]=q<0||b<q,(b>-1||he(p,"default"))&&i.push(m)}}}const c=[s,i];return _e(e)&&a.set(e,c),c}function ct(e){return e[0]!=="$"}function dt(e){const n=e&&e.toString().match(/^\s*function (\w+)/);return n?n[1]:e===null?"null":""}function ut(e,n){return dt(e)===dt(n)}function mt(e,n){return oe(n)?n.findIndex(r=>ut(r,e)):le(n)&&ut(n,e)?0:-1}const ei=e=>e[0]==="_"||e==="$stable",Ao=e=>oe(e)?e.map(tn):[tn(e)],_c=(e,n,r)=>{if(n._n)return n;const a=Fe((...o)=>Ao(n(...o)),r);return a._c=!1,a},ni=(e,n,r)=>{const a=e._ctx;for(const o in e){if(ei(o))continue;const t=e[o];if(le(t))n[o]=_c(o,t,a);else if(t!=null){const s=Ao(t);n[o]=()=>s}}},ri=(e,n)=>{const r=Ao(n);e.slots.default=()=>r},Tc=(e,n)=>{if(e.vnode.shapeFlag&32){const r=n._;r?(e.slots=Se(n),sa(n,"_",r)):ni(n,e.slots={})}else e.slots={},n&&ri(e,n);sa(e.slots,Aa,1)},Lc=(e,n,r)=>{const{vnode:a,slots:o}=e;let t=!0,s=je;if(a.shapeFlag&32){const i=n._;i?r&&i===1?t=!1:(Ue(o,n),!r&&i===1&&delete o._):(t=!n.$stable,ni(n,o)),s=n}else n&&(ri(e,n),s={default:1});if(t)for(const i in o)!ei(i)&&!(i in s)&&delete o[i]};function ai(){return{app:null,config:{isNativeTag:cl,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let Dc=0;function Rc(e,n){return function(a,o=null){le(a)||(a=Object.assign({},a)),o!=null&&!_e(o)&&(o=null);const t=ai(),s=new Set;let i=!1;const l=t.app={_uid:Dc++,_component:a,_props:o,_container:null,_context:t,_instance:null,version:ed,get config(){return t.config},set config(c){},use(c,...d){return s.has(c)||(c&&le(c.install)?(s.add(c),c.install(l,...d)):le(c)&&(s.add(c),c(l,...d))),l},mixin(c){return t.mixins.includes(c)||t.mixins.push(c),l},component(c,d){return d?(t.components[c]=d,l):t.components[c]},directive(c,d){return d?(t.directives[c]=d,l):t.directives[c]},mount(c,d,m){if(!i){const u=se(a,o);return u.appContext=t,d&&n?n(u,c):e(u,c,m),i=!0,l._container=c,c.__vue_app__=l,Ia(u.component)||u.component.proxy}},unmount(){i&&(e(null,l._container),delete l._container.__vue_app__)},provide(c,d){return t.provides[c]=d,l}};return l}}function pa(e,n,r,a,o=!1){if(oe(e)){e.forEach((u,p)=>pa(u,n&&(oe(n)?n[p]:n),r,a,o));return}if(mr(a)&&!o)return;const t=a.shapeFlag&4?Ia(a.component)||a.component.proxy:a.el,s=o?null:t,{i,r:l}=e,c=n&&n.r,d=i.refs===je?i.refs={}:i.refs,m=i.setupState;if(c!=null&&c!==l&&(Ee(c)?(d[c]=null,he(m,c)&&(m[c]=null)):Ne(c)&&(c.value=null)),le(l))zn(l,i,12,[s,d]);else{const u=Ee(l),p=Ne(l);if(u||p){const b=()=>{if(e.f){const q=u?d[l]:l.value;o?oe(q)&&fo(q,t):oe(q)?q.includes(t)||q.push(t):u?(d[l]=[t],he(m,l)&&(m[l]=d[l])):(l.value=[t],e.k&&(d[e.k]=l.value))}else u?(d[l]=s,he(m,l)&&(m[l]=s)):p&&(l.value=s,e.k&&(d[e.k]=s))};s?(b.id=-1,Ge(b,r)):b()}}}let An=!1;const Zr=e=>/svg/.test(e.namespaceURI)&&e.tagName!=="foreignObject",ea=e=>e.nodeType===8;function zc(e){const{mt:n,p:r,o:{patchProp:a,createText:o,nextSibling:t,parentNode:s,remove:i,insert:l,createComment:c}}=e,d=(f,S)=>{if(!S.hasChildNodes()){r(null,f,S),la(),S._vnode=f;return}An=!1,m(S.firstChild,f,null,null,null),la(),S._vnode=f,An&&console.error("Hydration completed but contains mismatches.")},m=(f,S,C,R,U,X=!1)=>{const x=ea(f)&&f.data==="[",g=()=>q(f,S,C,R,U,x),{type:Y,ref:W,shapeFlag:D,patchFlag:y}=S,P=f.nodeType;S.el=f,y===-2&&(X=!1,S.dynamicChildren=null);let j=null;switch(Y){case Or:P!==3?S.children===""?(l(S.el=o(""),s(f),f),j=f):j=g():(f.data!==S.children&&(An=!0,f.data=S.children),j=t(f));break;case Ze:P!==8||x?j=g():j=t(f);break;case Ar:if(P!==1&&P!==3)j=g();else{j=f;const _=!S.children.length;for(let I=0;I<S.staticCount;I++)_&&(S.children+=j.nodeType===1?j.outerHTML:j.data),I===S.staticCount-1&&(S.anchor=j),j=t(j);return j}break;case Ae:x?j=b(f,S,C,R,U,X):j=g();break;default:if(D&1)P!==1||S.type.toLowerCase()!==f.tagName.toLowerCase()?j=g():j=u(f,S,C,R,U,X);else if(D&6){S.slotScopeIds=U;const _=s(f);if(n(S,_,null,C,R,Zr(_),X),j=x?w(f):t(f),j&&ea(j)&&j.data==="teleport end"&&(j=t(j)),mr(S)){let I;x?(I=se(Ae),I.anchor=j?j.previousSibling:_.lastChild):I=f.nodeType===3?Fn(""):se("div"),I.el=f,S.component.subTree=I}}else D&64?P!==8?j=g():j=S.type.hydrate(f,S,C,R,U,X,e,p):D&128&&(j=S.type.hydrate(f,S,C,R,Zr(s(f)),U,X,e,m))}return W!=null&&pa(W,null,R,S),j},u=(f,S,C,R,U,X)=>{X=X||!!S.dynamicChildren;const{type:x,props:g,patchFlag:Y,shapeFlag:W,dirs:D}=S,y=x==="input"&&D||x==="option";if(y||Y!==-1){if(D&&pn(S,null,C,"created"),g)if(y||!X||Y&48)for(const j in g)(y&&j.endsWith("value")||Fr(j)&&!xr(j))&&a(f,j,null,g[j],!1,void 0,C);else g.onClick&&a(f,"onClick",null,g.onClick,!1,void 0,C);let P;if((P=g&&g.onVnodeBeforeMount)&&rn(P,C,S),D&&pn(S,null,C,"beforeMount"),((P=g&&g.onVnodeMounted)||D)&&Fs(()=>{P&&rn(P,C,S),D&&pn(S,null,C,"mounted")},R),W&16&&!(g&&(g.innerHTML||g.textContent))){let j=p(f.firstChild,S,f,C,R,U,X);for(;j;){An=!0;const _=j;j=j.nextSibling,i(_)}}else W&8&&f.textContent!==S.children&&(An=!0,f.textContent=S.children)}return f.nextSibling},p=(f,S,C,R,U,X,x)=>{x=x||!!S.dynamicChildren;const g=S.children,Y=g.length;for(let W=0;W<Y;W++){const D=x?g[W]:g[W]=tn(g[W]);if(f)f=m(f,D,R,U,X,x);else{if(D.type===Or&&!D.children)continue;An=!0,r(null,D,C,null,R,U,Zr(C),X)}}return f},b=(f,S,C,R,U,X)=>{const{slotScopeIds:x}=S;x&&(U=U?U.concat(x):x);const g=s(f),Y=p(t(f),S,g,C,R,U,X);return Y&&ea(Y)&&Y.data==="]"?t(S.anchor=Y):(An=!0,l(S.anchor=c("]"),g,Y),Y)},q=(f,S,C,R,U,X)=>{if(An=!0,S.el=null,X){const Y=w(f);for(;;){const W=t(f);if(W&&W!==Y)i(W);else break}}const x=t(f),g=s(f);return i(f),r(null,S,g,x,C,R,Zr(g),U),x},w=f=>{let S=0;for(;f;)if(f=t(f),f&&ea(f)&&(f.data==="["&&S++,f.data==="]")){if(S===0)return t(f);S--}return f};return[d,m]}const Ge=Fs;function Oc(e){return Mc(e,zc)}function Mc(e,n){const r=gl();r.__VUE__=!0;const{insert:a,remove:o,patchProp:t,createElement:s,createText:i,createComment:l,setText:c,setElementText:d,parentNode:m,nextSibling:u,setScopeId:p=cn,cloneNode:b,insertStaticContent:q}=e,w=(h,v,E,L=null,T=null,B=null,$=!1,F=null,H=!!v.dynamicChildren)=>{if(h===v)return;h&&!Yn(h,v)&&(L=K(h),Te(h,T,B,!0),h=null),v.patchFlag===-2&&(H=!1,v.dynamicChildren=null);const{type:O,ref:ne,shapeFlag:ee}=v;switch(O){case Or:f(h,v,E,L);break;case Ze:S(h,v,E,L);break;case Ar:h==null&&C(v,E,L,$);break;case Ae:P(h,v,E,L,T,B,$,F,H);break;default:ee&1?X(h,v,E,L,T,B,$,F,H):ee&6?j(h,v,E,L,T,B,$,F,H):(ee&64||ee&128)&&O.process(h,v,E,L,T,B,$,F,H,fe)}ne!=null&&T&&pa(ne,h&&h.ref,B,v||h,!v)},f=(h,v,E,L)=>{if(h==null)a(v.el=i(v.children),E,L);else{const T=v.el=h.el;v.children!==h.children&&c(T,v.children)}},S=(h,v,E,L)=>{h==null?a(v.el=l(v.children||""),E,L):v.el=h.el},C=(h,v,E,L)=>{[h.el,h.anchor]=q(h.children,v,E,L,h.el,h.anchor)},R=({el:h,anchor:v},E,L)=>{let T;for(;h&&h!==v;)T=u(h),a(h,E,L),h=T;a(v,E,L)},U=({el:h,anchor:v})=>{let E;for(;h&&h!==v;)E=u(h),o(h),h=E;o(v)},X=(h,v,E,L,T,B,$,F,H)=>{$=$||v.type==="svg",h==null?x(v,E,L,T,B,$,F,H):W(h,v,T,B,$,F,H)},x=(h,v,E,L,T,B,$,F)=>{let H,O;const{type:ne,props:ee,shapeFlag:re,transition:ie,patchFlag:ve,dirs:Ce}=h;if(h.el&&b!==void 0&&ve===-1)H=h.el=b(h.el);else{if(H=h.el=s(h.type,B,ee&&ee.is,ee),re&8?d(H,h.children):re&16&&Y(h.children,H,null,L,T,B&&ne!=="foreignObject",$,F),Ce&&pn(h,null,L,"created"),ee){for(const Ie in ee)Ie!=="value"&&!xr(Ie)&&t(H,Ie,null,ee[Ie],B,h.children,L,T,z);"value"in ee&&t(H,"value",null,ee.value),(O=ee.onVnodeBeforeMount)&&rn(O,L,h)}g(H,h,h.scopeId,$,L)}Ce&&pn(h,null,L,"beforeMount");const ke=(!T||T&&!T.pendingBranch)&&ie&&!ie.persisted;ke&&ie.beforeEnter(H),a(H,v,E),((O=ee&&ee.onVnodeMounted)||ke||Ce)&&Ge(()=>{O&&rn(O,L,h),ke&&ie.enter(H),Ce&&pn(h,null,L,"mounted")},T)},g=(h,v,E,L,T)=>{if(E&&p(h,E),L)for(let B=0;B<L.length;B++)p(h,L[B]);if(T){let B=T.subTree;if(v===B){const $=T.vnode;g(h,$,$.scopeId,$.slotScopeIds,T.parent)}}},Y=(h,v,E,L,T,B,$,F,H=0)=>{for(let O=H;O<h.length;O++){const ne=h[O]=F?Tn(h[O]):tn(h[O]);w(null,ne,v,E,L,T,B,$,F)}},W=(h,v,E,L,T,B,$)=>{const F=v.el=h.el;let{patchFlag:H,dynamicChildren:O,dirs:ne}=v;H|=h.patchFlag&16;const ee=h.props||je,re=v.props||je;let ie;E&&Un(E,!1),(ie=re.onVnodeBeforeUpdate)&&rn(ie,E,v,h),ne&&pn(v,h,E,"beforeUpdate"),E&&Un(E,!0);const ve=T&&v.type!=="foreignObject";if(O?D(h.dynamicChildren,O,F,E,L,ve,B):$||ce(h,v,F,null,E,L,ve,B,!1),H>0){if(H&16)y(F,v,ee,re,E,L,T);else if(H&2&&ee.class!==re.class&&t(F,"class",null,re.class,T),H&4&&t(F,"style",ee.style,re.style,T),H&8){const Ce=v.dynamicProps;for(let ke=0;ke<Ce.length;ke++){const Ie=Ce[ke],on=ee[Ie],or=re[Ie];(or!==on||Ie==="value")&&t(F,Ie,on,or,T,h.children,E,L,z)}}H&1&&h.children!==v.children&&d(F,v.children)}else!$&&O==null&&y(F,v,ee,re,E,L,T);((ie=re.onVnodeUpdated)||ne)&&Ge(()=>{ie&&rn(ie,E,v,h),ne&&pn(v,h,E,"updated")},L)},D=(h,v,E,L,T,B,$)=>{for(let F=0;F<v.length;F++){const H=h[F],O=v[F],ne=H.el&&(H.type===Ae||!Yn(H,O)||H.shapeFlag&70)?m(H.el):E;w(H,O,ne,null,L,T,B,$,!0)}},y=(h,v,E,L,T,B,$)=>{if(E!==L){for(const F in L){if(xr(F))continue;const H=L[F],O=E[F];H!==O&&F!=="value"&&t(h,F,O,H,$,v.children,T,B,z)}if(E!==je)for(const F in E)!xr(F)&&!(F in L)&&t(h,F,E[F],null,$,v.children,T,B,z);"value"in L&&t(h,"value",E.value,L.value)}},P=(h,v,E,L,T,B,$,F,H)=>{const O=v.el=h?h.el:i(""),ne=v.anchor=h?h.anchor:i("");let{patchFlag:ee,dynamicChildren:re,slotScopeIds:ie}=v;ie&&(F=F?F.concat(ie):ie),h==null?(a(O,E,L),a(ne,E,L),Y(v.children,E,ne,T,B,$,F,H)):ee>0&&ee&64&&re&&h.dynamicChildren?(D(h.dynamicChildren,re,E,T,B,$,F),(v.key!=null||T&&v===T.subTree)&&oi(h,v,!0)):ce(h,v,E,ne,T,B,$,F,H)},j=(h,v,E,L,T,B,$,F,H)=>{v.slotScopeIds=F,h==null?v.shapeFlag&512?T.ctx.activate(v,E,L,$,H):_(v,E,L,T,B,$,H):I(h,v,H)},_=(h,v,E,L,T,B,$)=>{const F=h.component=Gc(h,L,T);if(Wr(h)&&(F.ctx.renderer=fe),Kc(F),F.asyncDep){if(T&&T.registerDep(F,N),!h.el){const H=F.subTree=se(Ze);S(null,H,v,E)}return}N(F,h,v,E,T,B,$)},I=(h,v,E)=>{const L=v.component=h.component;if(sc(h,v,E))if(L.asyncDep&&!L.asyncResolved){G(L,v,E);return}else L.next=v,ec(L.update),L.update();else v.el=h.el,L.vnode=v},N=(h,v,E,L,T,B,$)=>{const F=()=>{if(h.isMounted){let{next:ne,bu:ee,u:re,parent:ie,vnode:ve}=h,Ce=ne,ke;Un(h,!1),ne?(ne.el=ve.el,G(h,ne,$)):ne=ve,ee&&Da(ee),(ke=ne.props&&ne.props.onVnodeBeforeUpdate)&&rn(ke,ie,ne,ve),Un(h,!0);const Ie=Ra(h),on=h.subTree;h.subTree=Ie,w(on,Ie,m(on.el),K(on),h,T,B),ne.el=Ie.el,Ce===null&&ic(h,Ie.el),re&&Ge(re,T),(ke=ne.props&&ne.props.onVnodeUpdated)&&Ge(()=>rn(ke,ie,ne,ve),T)}else{let ne;const{el:ee,props:re}=v,{bm:ie,m:ve,parent:Ce}=h,ke=mr(v);if(Un(h,!1),ie&&Da(ie),!ke&&(ne=re&&re.onVnodeBeforeMount)&&rn(ne,Ce,v),Un(h,!0),ee&&te){const Ie=()=>{h.subTree=Ra(h),te(ee,h.subTree,h,T,null)};ke?v.type.__asyncLoader().then(()=>!h.isUnmounted&&Ie()):Ie()}else{const Ie=h.subTree=Ra(h);w(null,Ie,E,L,h,T,B),v.el=Ie.el}if(ve&&Ge(ve,T),!ke&&(ne=re&&re.onVnodeMounted)){const Ie=v;Ge(()=>rn(ne,Ce,Ie),T)}(v.shapeFlag&256||Ce&&mr(Ce.vnode)&&Ce.vnode.shapeFlag&256)&&h.a&&Ge(h.a,T),h.isMounted=!0,v=E=L=null}},H=h.effect=new So(F,()=>Ca(O),h.scope),O=h.update=()=>H.run();O.id=h.uid,Un(h,!0),O()},G=(h,v,E)=>{v.component=h;const L=h.vnode.props;h.vnode=v,h.next=null,Ic(h,v.props,L,E),Lc(h,v.children,E),br(),rt(),yr()},ce=(h,v,E,L,T,B,$,F,H=!1)=>{const O=h&&h.children,ne=h?h.shapeFlag:0,ee=v.children,{patchFlag:re,shapeFlag:ie}=v;if(re>0){if(re&128){we(O,ee,E,L,T,B,$,F,H);return}else if(re&256){ue(O,ee,E,L,T,B,$,F,H);return}}ie&8?(ne&16&&z(O,T,B),ee!==O&&d(E,ee)):ne&16?ie&16?we(O,ee,E,L,T,B,$,F,H):z(O,T,B,!0):(ne&8&&d(E,""),ie&16&&Y(ee,E,L,T,B,$,F,H))},ue=(h,v,E,L,T,B,$,F,H)=>{h=h||lr,v=v||lr;const O=h.length,ne=v.length,ee=Math.min(O,ne);let re;for(re=0;re<ee;re++){const ie=v[re]=H?Tn(v[re]):tn(v[re]);w(h[re],ie,E,null,T,B,$,F,H)}O>ne?z(h,T,B,!0,!1,ee):Y(v,E,L,T,B,$,F,H,ee)},we=(h,v,E,L,T,B,$,F,H)=>{let O=0;const ne=v.length;let ee=h.length-1,re=ne-1;for(;O<=ee&&O<=re;){const ie=h[O],ve=v[O]=H?Tn(v[O]):tn(v[O]);if(Yn(ie,ve))w(ie,ve,E,null,T,B,$,F,H);else break;O++}for(;O<=ee&&O<=re;){const ie=h[ee],ve=v[re]=H?Tn(v[re]):tn(v[re]);if(Yn(ie,ve))w(ie,ve,E,null,T,B,$,F,H);else break;ee--,re--}if(O>ee){if(O<=re){const ie=re+1,ve=ie<ne?v[ie].el:L;for(;O<=re;)w(null,v[O]=H?Tn(v[O]):tn(v[O]),E,ve,T,B,$,F,H),O++}}else if(O>re)for(;O<=ee;)Te(h[O],T,B,!0),O++;else{const ie=O,ve=O,Ce=new Map;for(O=ve;O<=re;O++){const Ye=v[O]=H?Tn(v[O]):tn(v[O]);Ye.key!=null&&Ce.set(Ye.key,O)}let ke,Ie=0;const on=re-ve+1;let or=!1,Wo=0;const Pr=new Array(on);for(O=0;O<on;O++)Pr[O]=0;for(O=ie;O<=ee;O++){const Ye=h[O];if(Ie>=on){Te(Ye,T,B,!0);continue}let mn;if(Ye.key!=null)mn=Ce.get(Ye.key);else for(ke=ve;ke<=re;ke++)if(Pr[ke-ve]===0&&Yn(Ye,v[ke])){mn=ke;break}mn===void 0?Te(Ye,T,B,!0):(Pr[mn-ve]=O+1,mn>=Wo?Wo=mn:or=!0,w(Ye,v[mn],E,null,T,B,$,F,H),Ie++)}const Vo=or?Nc(Pr):lr;for(ke=Vo.length-1,O=on-1;O>=0;O--){const Ye=ve+O,mn=v[Ye],Jo=Ye+1<ne?v[Ye+1].el:L;Pr[O]===0?w(null,mn,E,Jo,T,B,$,F,H):or&&(ke<0||O!==Vo[ke]?De(mn,E,Jo,2):ke--)}}},De=(h,v,E,L,T=null)=>{const{el:B,type:$,transition:F,children:H,shapeFlag:O}=h;if(O&6){De(h.component.subTree,v,E,L);return}if(O&128){h.suspense.move(v,E,L);return}if(O&64){$.move(h,v,E,fe);return}if($===Ae){a(B,v,E);for(let ee=0;ee<H.length;ee++)De(H[ee],v,E,L);a(h.anchor,v,E);return}if($===Ar){R(h,v,E);return}if(L!==2&&O&1&&F)if(L===0)F.beforeEnter(B),a(B,v,E),Ge(()=>F.enter(B),T);else{const{leave:ee,delayLeave:re,afterLeave:ie}=F,ve=()=>a(B,v,E),Ce=()=>{ee(B,()=>{ve(),ie&&ie()})};re?re(B,ve,Ce):Ce()}else a(B,v,E)},Te=(h,v,E,L=!1,T=!1)=>{const{type:B,props:$,ref:F,children:H,dynamicChildren:O,shapeFlag:ne,patchFlag:ee,dirs:re}=h;if(F!=null&&pa(F,null,E,h,!0),ne&256){v.ctx.deactivate(h);return}const ie=ne&1&&re,ve=!mr(h);let Ce;if(ve&&(Ce=$&&$.onVnodeBeforeUnmount)&&rn(Ce,v,h),ne&6)Q(h.component,E,L);else{if(ne&128){h.suspense.unmount(E,L);return}ie&&pn(h,null,v,"beforeUnmount"),ne&64?h.type.remove(h,v,E,T,fe,L):O&&(B!==Ae||ee>0&&ee&64)?z(O,v,E,!1,!0):(B===Ae&&ee&384||!T&&ne&16)&&z(H,v,E),L&&$e(h)}(ve&&(Ce=$&&$.onVnodeUnmounted)||ie)&&Ge(()=>{Ce&&rn(Ce,v,h),ie&&pn(h,null,v,"unmounted")},E)},$e=h=>{const{type:v,el:E,anchor:L,transition:T}=h;if(v===Ae){A(E,L);return}if(v===Ar){U(h);return}const B=()=>{o(E),T&&!T.persisted&&T.afterLeave&&T.afterLeave()};if(h.shapeFlag&1&&T&&!T.persisted){const{leave:$,delayLeave:F}=T,H=()=>$(E,B);F?F(h.el,B,H):H()}else B()},A=(h,v)=>{let E;for(;h!==v;)E=u(h),o(h),h=E;o(v)},Q=(h,v,E)=>{const{bum:L,scope:T,update:B,subTree:$,um:F}=h;L&&Da(L),T.stop(),B&&(B.active=!1,Te($,h,v,E)),F&&Ge(F,v),Ge(()=>{h.isUnmounted=!0},v),v&&v.pendingBranch&&!v.isUnmounted&&h.asyncDep&&!h.asyncResolved&&h.suspenseId===v.pendingId&&(v.deps--,v.deps===0&&v.resolve())},z=(h,v,E,L=!1,T=!1,B=0)=>{for(let $=B;$<h.length;$++)Te(h[$],v,E,L,T)},K=h=>h.shapeFlag&6?K(h.component.subTree):h.shapeFlag&128?h.suspense.next():u(h.anchor||h.el),me=(h,v,E)=>{h==null?v._vnode&&Te(v._vnode,null,null,!0):w(v._vnode||null,h,v,null,null,null,E),rt(),la(),v._vnode=h},fe={p:w,um:Te,m:De,r:$e,mt:_,mc:Y,pc:ce,pbc:D,n:K,o:e};let de,te;return n&&([de,te]=n(fe)),{render:me,hydrate:de,createApp:Rc(me,de)}}function Un({effect:e,update:n},r){e.allowRecurse=n.allowRecurse=r}function oi(e,n,r=!1){const a=e.children,o=n.children;if(oe(a)&&oe(o))for(let t=0;t<a.length;t++){const s=a[t];let i=o[t];i.shapeFlag&1&&!i.dynamicChildren&&((i.patchFlag<=0||i.patchFlag===32)&&(i=o[t]=Tn(o[t]),i.el=s.el),r||oi(s,i))}}function Nc(e){const n=e.slice(),r=[0];let a,o,t,s,i;const l=e.length;for(a=0;a<l;a++){const c=e[a];if(c!==0){if(o=r[r.length-1],e[o]<c){n[a]=o,r.push(a);continue}for(t=0,s=r.length-1;t<s;)i=t+s>>1,e[r[i]]<c?t=i+1:s=i;c<e[r[t]]&&(t>0&&(n[a]=r[t-1]),r[t]=a)}}for(t=r.length,s=r[t-1];t-- >0;)r[t]=s,s=n[s];return r}const Bc=e=>e.__isTeleport,Ae=Symbol(void 0),Or=Symbol(void 0),Ze=Symbol(void 0),Ar=Symbol(void 0),Ir=[];let ln=null;function V(e=!1){Ir.push(ln=e?null:[])}function Fc(){Ir.pop(),ln=Ir[Ir.length-1]||null}let Mr=1;function pt(e){Mr+=e}function ti(e){return e.dynamicChildren=Mr>0?ln||lr:null,Fc(),Mr>0&&ln&&ln.push(e),e}function ae(e,n,r,a,o,t){return ti(ye(e,n,r,a,o,t,!0))}function ze(e,n,r,a,o){return ti(se(e,n,r,a,o,!0))}function ha(e){return e?e.__v_isVNode===!0:!1}function Yn(e,n){return e.type===n.type&&e.key===n.key}const Aa="__vInternal",si=({key:e})=>e!=null?e:null,aa=({ref:e,ref_key:n,ref_for:r})=>e!=null?Ee(e)||Ne(e)||le(e)?{i:We,r:e,k:n,f:!!r}:e:null;function ye(e,n=null,r=null,a=0,o=null,t=e===Ae?0:1,s=!1,i=!1){const l={__v_isVNode:!0,__v_skip:!0,type:e,props:n,key:n&&si(n),ref:n&&aa(n),scopeId:Bs,slotScopeIds:null,children:r,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:t,patchFlag:a,dynamicProps:o,dynamicChildren:null,appContext:null};return i?(Io(l,r),t&128&&e.normalize(l)):r&&(l.shapeFlag|=Ee(r)?8:16),Mr>0&&!s&&ln&&(l.patchFlag>0||t&6)&&l.patchFlag!==32&&ln.push(l),l}const se=Uc;function Uc(e,n=null,r=null,a=0,o=null,t=!1){if((!e||e===wc)&&(e=Ze),ha(e)){const i=Bn(e,n,!0);return r&&Io(i,r),Mr>0&&!t&&ln&&(i.shapeFlag&6?ln[ln.indexOf(e)]=i:ln.push(i)),i.patchFlag|=-2,i}if(Zc(e)&&(e=e.__vccOpts),n){n=Hc(n);let{class:i,style:l}=n;i&&!Ee(i)&&(n.class=Xe(i)),_e(l)&&(xs(l)&&!oe(l)&&(l=Ue({},l)),n.style=Br(l))}const s=Ee(e)?1:lc(e)?128:Bc(e)?64:_e(e)?4:le(e)?2:0;return ye(e,n,r,a,o,s,t,!0)}function Hc(e){return e?xs(e)||Aa in e?Ue({},e):e:null}function Bn(e,n,r=!1){const{props:a,ref:o,patchFlag:t,children:s}=e,i=n?to(a||{},n):a;return{__v_isVNode:!0,__v_skip:!0,type:e.type,props:i,key:i&&si(i),ref:n&&n.ref?r&&o?oe(o)?o.concat(aa(n)):[o,aa(n)]:aa(n):o,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:s,target:e.target,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:n&&e.type!==Ae?t===-1?16:t|16:t,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:e.transition,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&Bn(e.ssContent),ssFallback:e.ssFallback&&Bn(e.ssFallback),el:e.el,anchor:e.anchor}}function Fn(e=" ",n=0){return se(Or,null,e,n)}function Wc(e,n){const r=se(Ar,null,e);return r.staticCount=n,r}function Re(e="",n=!1){return n?(V(),ze(Ze,null,e)):se(Ze,null,e)}function tn(e){return e==null||typeof e=="boolean"?se(Ze):oe(e)?se(Ae,null,e.slice()):typeof e=="object"?Tn(e):se(Or,null,String(e))}function Tn(e){return e.el===null||e.memo?e:Bn(e)}function Io(e,n){let r=0;const{shapeFlag:a}=e;if(n==null)n=null;else if(oe(n))r=16;else if(typeof n=="object")if(a&65){const o=n.default;o&&(o._c&&(o._d=!1),Io(e,o()),o._c&&(o._d=!0));return}else{r=32;const o=n._;!o&&!(Aa in n)?n._ctx=We:o===3&&We&&(We.slots._===1?n._=1:(n._=2,e.patchFlag|=1024))}else le(n)?(n={default:n,_ctx:We},r=32):(n=String(n),a&64?(r=16,n=[Fn(n)]):r=8);e.children=n,e.shapeFlag|=r}function to(...e){const n={};for(let r=0;r<e.length;r++){const a=e[r];for(const o in a)if(o==="class")n.class!==a.class&&(n.class=Xe([n.class,a.class]));else if(o==="style")n.style=Br([n.style,a.style]);else if(Fr(o)){const t=n[o],s=a[o];s&&t!==s&&!(oe(t)&&t.includes(s))&&(n[o]=t?[].concat(t,s):s)}else o!==""&&(n[o]=a[o])}return n}function rn(e,n,r,a=null){an(e,n,7,[r,a])}const Vc=ai();let Jc=0;function Gc(e,n,r){const a=e.type,o=(n?n.appContext:e.appContext)||Vc,t={uid:Jc++,vnode:e,type:a,parent:n,appContext:o,root:null,next:null,subTree:null,effect:null,update:null,scope:new fl(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:n?n.provides:Object.create(o.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:Zs(a,o),emitsOptions:Ns(a,o),emit:null,emitted:null,propsDefaults:je,inheritAttrs:a.inheritAttrs,ctx:je,data:je,props:je,attrs:je,slots:je,refs:je,setupState:je,setupContext:null,suspense:r,suspenseId:r?r.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return t.ctx={_:t},t.root=n?n.root:t,t.emit=ac.bind(null,t),e.ce&&e.ce(t),t}let Oe=null;const _o=()=>Oe||We,hr=e=>{Oe=e,e.scope.on()},nr=()=>{Oe&&Oe.scope.off(),Oe=null};function ii(e){return e.vnode.shapeFlag&4}let gr=!1;function Kc(e,n=!1){gr=n;const{props:r,children:a}=e.vnode,o=ii(e);Ac(e,r,o,n),Tc(e,a);const t=o?$c(e,n):void 0;return gr=!1,t}function $c(e,n){const r=e.type;e.accessCache=Object.create(null),e.proxy=As(new Proxy(e.ctx,Ec));const{setup:a}=r;if(a){const o=e.setupContext=a.length>1?Qc(e):null;hr(e),br();const t=zn(a,e,0,[e.props,o]);if(yr(),nr(),hs(t)){if(t.then(nr,nr),n)return t.then(s=>{ht(e,s,n)}).catch(s=>{Ur(s,e,0)});e.asyncDep=t}else ht(e,t,n)}else li(e,n)}function ht(e,n,r){le(n)?e.type.__ssrInlineRender?e.ssrRender=n:e.render=n:_e(n)&&(e.setupState=Ds(n)),li(e,r)}let gt;function li(e,n,r){const a=e.type;if(!e.render){if(!n&&gt&&!a.render){const o=a.template||xo(e).template;if(o){const{isCustomElement:t,compilerOptions:s}=e.appContext.config,{delimiters:i,compilerOptions:l}=a,c=Ue(Ue({isCustomElement:t,delimiters:i},s),l);a.render=gt(o,c)}}e.render=a.render||cn}hr(e),br(),qc(e),yr(),nr()}function Yc(e){return new Proxy(e.attrs,{get(n,r){return en(e,"get","$attrs"),n[r]}})}function Qc(e){const n=a=>{e.exposed=a||{}};let r;return{get attrs(){return r||(r=Yc(e))},slots:e.slots,emit:e.emit,expose:n}}function Ia(e){if(e.exposed)return e.exposeProxy||(e.exposeProxy=new Proxy(Ds(As(e.exposed)),{get(n,r){if(r in n)return n[r];if(r in ua)return ua[r](e)}}))}function Xc(e,n=!0){return le(e)?e.displayName||e.name:e.name||n&&e.__name}function Zc(e){return le(e)&&"__vccOpts"in e}const J=(e,n)=>Ql(e,n,gr);function pe(e,n,r){const a=arguments.length;return a===2?_e(n)&&!oe(n)?ha(n)?se(e,null,[n]):se(e,n):se(e,null,n):(a>3?r=Array.prototype.slice.call(arguments,2):a===3&&ha(r)&&(r=[r]),se(e,n,r))}const ed="3.2.39",nd="http://www.w3.org/2000/svg",Qn=typeof document<"u"?document:null,ft=Qn&&Qn.createElement("template"),rd={insert:(e,n,r)=>{n.insertBefore(e,r||null)},remove:e=>{const n=e.parentNode;n&&n.removeChild(e)},createElement:(e,n,r,a)=>{const o=n?Qn.createElementNS(nd,e):Qn.createElement(e,r?{is:r}:void 0);return e==="select"&&a&&a.multiple!=null&&o.setAttribute("multiple",a.multiple),o},createText:e=>Qn.createTextNode(e),createComment:e=>Qn.createComment(e),setText:(e,n)=>{e.nodeValue=n},setElementText:(e,n)=>{e.textContent=n},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>Qn.querySelector(e),setScopeId(e,n){e.setAttribute(n,"")},cloneNode(e){const n=e.cloneNode(!0);return"_value"in e&&(n._value=e._value),n},insertStaticContent(e,n,r,a,o,t){const s=r?r.previousSibling:n.lastChild;if(o&&(o===t||o.nextSibling))for(;n.insertBefore(o.cloneNode(!0),r),!(o===t||!(o=o.nextSibling)););else{ft.innerHTML=a?`<svg>${e}</svg>`:e;const i=ft.content;if(a){const l=i.firstChild;for(;l.firstChild;)i.appendChild(l.firstChild);i.removeChild(l)}n.insertBefore(i,r)}return[s?s.nextSibling:n.firstChild,r?r.previousSibling:n.lastChild]}};function ad(e,n,r){const a=e._vtc;a&&(n=(n?[n,...a]:[...a]).join(" ")),n==null?e.removeAttribute("class"):r?e.setAttribute("class",n):e.className=n}function od(e,n,r){const a=e.style,o=Ee(r);if(r&&!o){for(const t in r)so(a,t,r[t]);if(n&&!Ee(n))for(const t in n)r[t]==null&&so(a,t,"")}else{const t=a.display;o?n!==r&&(a.cssText=r):n&&e.removeAttribute("style"),"_vod"in e&&(a.display=t)}}const vt=/\s*!important$/;function so(e,n,r){if(oe(r))r.forEach(a=>so(e,n,a));else if(r==null&&(r=""),n.startsWith("--"))e.setProperty(n,r);else{const a=td(e,n);vt.test(r)?e.setProperty(rr(a),r.replace(vt,""),"important"):e[a]=r}}const bt=["Webkit","Moz","ms"],Ma={};function td(e,n){const r=Ma[n];if(r)return r;let a=gn(n);if(a!=="filter"&&a in e)return Ma[n]=a;a=Pa(a);for(let o=0;o<bt.length;o++){const t=bt[o]+a;if(t in e)return Ma[n]=t}return n}const yt="http://www.w3.org/1999/xlink";function sd(e,n,r,a,o){if(a&&n.startsWith("xlink:"))r==null?e.removeAttributeNS(yt,n.slice(6,n.length)):e.setAttributeNS(yt,n,r);else{const t=tl(n);r==null||t&&!us(r)?e.removeAttribute(n):e.setAttribute(n,t?"":r)}}function id(e,n,r,a,o,t,s){if(n==="innerHTML"||n==="textContent"){a&&s(a,o,t),e[n]=r==null?"":r;return}if(n==="value"&&e.tagName!=="PROGRESS"&&!e.tagName.includes("-")){e._value=r;const l=r==null?"":r;(e.value!==l||e.tagName==="OPTION")&&(e.value=l),r==null&&e.removeAttribute(n);return}let i=!1;if(r===""||r==null){const l=typeof e[n];l==="boolean"?r=us(r):r==null&&l==="string"?(r="",i=!0):l==="number"&&(r=0,i=!0)}try{e[n]=r}catch{}i&&e.removeAttribute(n)}const[ci,ld]=(()=>{let e=Date.now,n=!1;if(typeof window<"u"){Date.now()>document.createEvent("Event").timeStamp&&(e=performance.now.bind(performance));const r=navigator.userAgent.match(/firefox\/(\d+)/i);n=!!(r&&Number(r[1])<=53)}return[e,n]})();let io=0;const cd=Promise.resolve(),dd=()=>{io=0},ud=()=>io||(cd.then(dd),io=ci());function md(e,n,r,a){e.addEventListener(n,r,a)}function pd(e,n,r,a){e.removeEventListener(n,r,a)}function hd(e,n,r,a,o=null){const t=e._vei||(e._vei={}),s=t[n];if(a&&s)s.value=a;else{const[i,l]=gd(n);if(a){const c=t[n]=fd(a,o);md(e,i,c,l)}else s&&(pd(e,i,s,l),t[n]=void 0)}}const St=/(?:Once|Passive|Capture)$/;function gd(e){let n;if(St.test(e)){n={};let a;for(;a=e.match(St);)e=e.slice(0,e.length-a[0].length),n[a[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):rr(e.slice(2)),n]}function fd(e,n){const r=a=>{const o=a.timeStamp||ci();(ld||o>=r.attached-1)&&an(vd(a,r.value),n,5,[a])};return r.value=e,r.attached=ud(),r}function vd(e,n){if(oe(n)){const r=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{r.call(e),e._stopped=!0},n.map(a=>o=>!o._stopped&&a&&a(o))}else return n}const wt=/^on[a-z]/,bd=(e,n,r,a,o=!1,t,s,i,l)=>{n==="class"?ad(e,a,o):n==="style"?od(e,r,a):Fr(n)?go(n)||hd(e,n,r,a,s):(n[0]==="."?(n=n.slice(1),!0):n[0]==="^"?(n=n.slice(1),!1):yd(e,n,a,o))?id(e,n,a,t,s,i,l):(n==="true-value"?e._trueValue=a:n==="false-value"&&(e._falseValue=a),sd(e,n,a,o))};function yd(e,n,r,a){return a?!!(n==="innerHTML"||n==="textContent"||n in e&&wt.test(n)&&le(r)):n==="spellcheck"||n==="draggable"||n==="translate"||n==="form"||n==="list"&&e.tagName==="INPUT"||n==="type"&&e.tagName==="TEXTAREA"||wt.test(n)&&Ee(r)?!1:n in e}const In="transition",Er="animation",Jr=(e,{slots:n})=>pe(Ws,Sd(e),n);Jr.displayName="Transition";const di={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String};Jr.props=Ue({},Ws.props,di);const Hn=(e,n=[])=>{oe(e)?e.forEach(r=>r(...n)):e&&e(...n)},Pt=e=>e?oe(e)?e.some(n=>n.length>1):e.length>1:!1;function Sd(e){const n={};for(const y in e)y in di||(n[y]=e[y]);if(e.css===!1)return n;const{name:r="v",type:a,duration:o,enterFromClass:t=`${r}-enter-from`,enterActiveClass:s=`${r}-enter-active`,enterToClass:i=`${r}-enter-to`,appearFromClass:l=t,appearActiveClass:c=s,appearToClass:d=i,leaveFromClass:m=`${r}-leave-from`,leaveActiveClass:u=`${r}-leave-active`,leaveToClass:p=`${r}-leave-to`}=e,b=wd(o),q=b&&b[0],w=b&&b[1],{onBeforeEnter:f,onEnter:S,onEnterCancelled:C,onLeave:R,onLeaveCancelled:U,onBeforeAppear:X=f,onAppear:x=S,onAppearCancelled:g=C}=n,Y=(y,P,j)=>{Wn(y,P?d:i),Wn(y,P?c:s),j&&j()},W=(y,P)=>{y._isLeaving=!1,Wn(y,m),Wn(y,p),Wn(y,u),P&&P()},D=y=>(P,j)=>{const _=y?x:S,I=()=>Y(P,y,j);Hn(_,[P,I]),Et(()=>{Wn(P,y?l:t),_n(P,y?d:i),Pt(_)||qt(P,a,q,I)})};return Ue(n,{onBeforeEnter(y){Hn(f,[y]),_n(y,t),_n(y,s)},onBeforeAppear(y){Hn(X,[y]),_n(y,l),_n(y,c)},onEnter:D(!1),onAppear:D(!0),onLeave(y,P){y._isLeaving=!0;const j=()=>W(y,P);_n(y,m),qd(),_n(y,u),Et(()=>{!y._isLeaving||(Wn(y,m),_n(y,p),Pt(R)||qt(y,a,w,j))}),Hn(R,[y,j])},onEnterCancelled(y){Y(y,!1),Hn(C,[y])},onAppearCancelled(y){Y(y,!0),Hn(g,[y])},onLeaveCancelled(y){W(y),Hn(U,[y])}})}function wd(e){if(e==null)return null;if(_e(e))return[Na(e.enter),Na(e.leave)];{const n=Na(e);return[n,n]}}function Na(e){return vs(e)}function _n(e,n){n.split(/\s+/).forEach(r=>r&&e.classList.add(r)),(e._vtc||(e._vtc=new Set)).add(n)}function Wn(e,n){n.split(/\s+/).forEach(a=>a&&e.classList.remove(a));const{_vtc:r}=e;r&&(r.delete(n),r.size||(e._vtc=void 0))}function Et(e){requestAnimationFrame(()=>{requestAnimationFrame(e)})}let Pd=0;function qt(e,n,r,a){const o=e._endId=++Pd,t=()=>{o===e._endId&&a()};if(r)return setTimeout(t,r);const{type:s,timeout:i,propCount:l}=Ed(e,n);if(!s)return a();const c=s+"end";let d=0;const m=()=>{e.removeEventListener(c,u),t()},u=p=>{p.target===e&&++d>=l&&m()};setTimeout(()=>{d<l&&m()},i+1),e.addEventListener(c,u)}function Ed(e,n){const r=window.getComputedStyle(e),a=b=>(r[b]||"").split(", "),o=a(In+"Delay"),t=a(In+"Duration"),s=Ct(o,t),i=a(Er+"Delay"),l=a(Er+"Duration"),c=Ct(i,l);let d=null,m=0,u=0;n===In?s>0&&(d=In,m=s,u=t.length):n===Er?c>0&&(d=Er,m=c,u=l.length):(m=Math.max(s,c),d=m>0?s>c?In:Er:null,u=d?d===In?t.length:l.length:0);const p=d===In&&/\b(transform|all)(,|$)/.test(r[In+"Property"]);return{type:d,timeout:m,propCount:u,hasTransform:p}}function Ct(e,n){for(;e.length<n.length;)e=e.concat(e);return Math.max(...n.map((r,a)=>kt(r)+kt(e[a])))}function kt(e){return Number(e.slice(0,-1).replace(",","."))*1e3}function qd(){return document.body.offsetHeight}const Cd={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},kd=(e,n)=>r=>{if(!("key"in r))return;const a=rr(r.key);if(n.some(o=>o===a||Cd[o]===a))return e(r)},ga={beforeMount(e,{value:n},{transition:r}){e._vod=e.style.display==="none"?"":e.style.display,r&&n?r.beforeEnter(e):qr(e,n)},mounted(e,{value:n},{transition:r}){r&&n&&r.enter(e)},updated(e,{value:n,oldValue:r},{transition:a}){!n!=!r&&(a?n?(a.beforeEnter(e),qr(e,!0),a.enter(e)):a.leave(e,()=>{qr(e,!1)}):qr(e,n))},beforeUnmount(e,{value:n}){qr(e,n)}};function qr(e,n){e.style.display=n?e._vod:"none"}const jd=Ue({patchProp:bd},rd);let Ba,jt=!1;function xd(){return Ba=jt?Ba:Oc(jd),jt=!0,Ba}const Ad=(...e)=>{const n=xd().createApp(...e),{mount:r}=n;return n.mount=a=>{const o=Id(a);if(o)return r(o,!0,o instanceof SVGElement)},n};function Id(e){return Ee(e)?document.querySelector(e):e}const _d=JSON.parse('{"base":"/psp_pages/","lang":"en-US","title":"PSP","description":"PSP, CFGS DAM, FP, Programacion, Java, IES Doctor Balmis","head":[["meta",{"name":"theme-color","content":"#3eaf7c"}],["meta",{"name":"apple-mobile-web-app-capable","content":"yes"}],["meta",{"name":"apple-mobile-web-app-status-bar-style","content":"black"}],["link",{"rel":"icon","href":"/psp_pages/psp_favicon.png"}]],"locales":{"/en/":{"lang":"en-US","title":"Process and Service Programming","description":"2nd DAM PSP Module"},"/es/":{"lang":"es-ES","title":"Programaci\xF3n de Servicios y Procesos","description":"M\xF3dulo PSP de 2\xBA DAM"}}}');var Td=([e,n,r])=>e==="meta"&&n.name?`${e}.${n.name}`:["title","base"].includes(e)?e:e==="template"&&n.id?`${e}.${n.id}`:JSON.stringify([e,n,r]),Ld=e=>{const n=new Set,r=[];return e.forEach(a=>{const o=Td(a);n.has(o)||(n.add(o),r.push(a))}),r},Gr=e=>/^(https?:)?\/\//.test(e),Dd=e=>/^mailto:/.test(e),Rd=e=>/^tel:/.test(e),To=e=>Object.prototype.toString.call(e)==="[object Object]",ui=e=>e.replace(/\/$/,""),mi=e=>e.replace(/^\//,""),pi=(e,n)=>{const r=Object.keys(e).sort((a,o)=>{const t=o.split("/").length-a.split("/").length;return t!==0?t:o.length-a.length});for(const a of r)if(n.startsWith(a))return a;return"/"};const hi={"v-8daa1a0e":Z(()=>k(()=>import("./index.html.17186379.js"),[])),"v-705d1b76":Z(()=>k(()=>import("./test_page.html.a8519c62.js"),[])),"v-2d0a870d":Z(()=>k(()=>import("./index.html.e746fe20.js"),[])),"v-2d0a87a8":Z(()=>k(()=>import("./index.html.4d0cc65e.js"),[])),"v-5aa74f15":Z(()=>k(()=>import("./concurrency.html.990a223c.js"),["assets/concurrency.html.990a223c.js","assets/gantt_parallel.6004ac09.js"])),"v-b73e5022":Z(()=>k(()=>import("./index.html.d98d9a19.js"),[])),"v-4b0532d0":Z(()=>k(()=>import("./operatingsystem.html.aaa2fb91.js"),["assets/operatingsystem.html.aaa2fb91.js","assets/roundrobin-3.d5817ead.js"])),"v-3f423939":Z(()=>k(()=>import("./process.html.e877d28e.js"),["assets/process.html.e877d28e.js","assets/threads_vs_process.7f2c90ed.js"])),"v-8100edac":Z(()=>k(()=>import("./curl_annex.html.28e382e9.js"),[])),"v-b73e4fe4":Z(()=>k(()=>import("./index.html.02c3d58b.js"),[])),"v-74406b7a":Z(()=>k(()=>import("./iostreams.html.03f7b917.js"),["assets/iostreams.html.03f7b917.js","assets/Java_Stream_Readers_BufferedReaders.170e97e8.js"])),"v-348bab3f":Z(()=>k(()=>import("./processbuilder.html.da129fb7.js"),["assets/processbuilder.html.da129fb7.js","assets/comandotree.fa02cb62.js"])),"v-1daecb0f":Z(()=>k(()=>import("./runtime.html.2bb84d87.js"),[])),"v-5bb12cb4":Z(()=>k(()=>import("./alternatives.html.14973374.js"),[])),"v-10f2297a":Z(()=>k(()=>import("./arraylist_annex.html.7bc8f05d.js"),["assets/arraylist_annex.html.7bc8f05d.js","assets/Collections_class_diagram.8db4bff0.js"])),"v-737de6d4":Z(()=>k(()=>import("./debugger_annex.html.68915369.js"),["assets/debugger_annex.html.68915369.js","assets/NetbeansDebug5.890d9d49.js"])),"v-3714d943":Z(()=>k(()=>import("./hashmap_annex.html.09fe5b15.js"),["assets/hashmap_annex.html.09fe5b15.js","assets/Collections_class_diagram.8db4bff0.js"])),"v-b73e4fa6":Z(()=>k(()=>import("./index.html.f7d4500a.js"),[])),"v-30e3afd6":Z(()=>k(()=>import("./producer-consumer.html.f8b12d15.js"),["assets/producer-consumer.html.f8b12d15.js","assets/ProducerConsumer.8367c5c5.js"])),"v-27271e62":Z(()=>k(()=>import("./runnable.html.2aeca0cc.js"),[])),"v-1dbfca26":Z(()=>k(()=>import("./synchronization.html.3b3310d7.js"),["assets/synchronization.html.3b3310d7.js","assets/Monitor_queues.a0c5134f.js"])),"v-b73e4f68":Z(()=>k(()=>import("./index.html.c6b406db.js"),[])),"v-14f705b1":Z(()=>k(()=>import("./sockets-tcp.html.4fa0c6c3.js"),["assets/sockets-tcp.html.4fa0c6c3.js","assets/multithread_server_sequence.7901f27a.js"])),"v-9c83245e":Z(()=>k(()=>import("./sockets-udp.html.4dc4066e.js"),["assets/sockets-udp.html.4dc4066e.js","assets/udp_process.3be6e717.js"])),"v-17f557b3":Z(()=>k(()=>import("./stateful-protocols.html.069acd61.js"),["assets/stateful-protocols.html.069acd61.js","assets/client_sample_state_protocol.1514f343.js"])),"v-de8e734c":Z(()=>k(()=>import("./tcp-ip.html.6635f769.js"),["assets/tcp-ip.html.6635f769.js","assets/5-Graphic-UDP-Vs-TCP.ef6f7d46.js"])),"v-3af7f8ae":Z(()=>k(()=>import("./urls.html.d6d94d0e.js"),[])),"v-6e11e1d8":Z(()=>k(()=>import("./asymmetric-keys.html.e5c40a89.js"),["assets/asymmetric-keys.html.e5c40a89.js","assets/digital-signature-sign-verify.3b3014a7.js"])),"v-4e4467f3":Z(()=>k(()=>import("./hash-functions.html.0c59e1d3.js"),[])),"v-b73e4eec":Z(()=>k(()=>import("./index.html.6d8a4972.js"),[])),"v-6fa59714":Z(()=>k(()=>import("./jsse.html.6b922699.js"),["assets/jsse.html.6b922699.js","assets/VM_Options.cfaf4215.js"])),"v-2e9c294f":Z(()=>k(()=>import("./security.html.b6edd92c.js"),[])),"v-0b29848c":Z(()=>k(()=>import("./symmetric-key.html.ddb3d790.js"),["assets/symmetric-key.html.ddb3d790.js","assets/symmetric-encryption-primitive.e35e72d2.js"])),"v-46af1970":Z(()=>k(()=>import("./concurrency.html.b93ebba9.js"),["assets/concurrency.html.b93ebba9.js","assets/gantt_parallel.6004ac09.js"])),"v-a8728f6c":Z(()=>k(()=>import("./index.html.82b70994.js"),[])),"v-e2dae91a":Z(()=>k(()=>import("./operatingsystem.html.fda5b010.js"),["assets/operatingsystem.html.fda5b010.js","assets/roundrobin-3.d5817ead.js"])),"v-75292dd8":Z(()=>k(()=>import("./process.html.33f98c70.js"),["assets/process.html.33f98c70.js","assets/threads_vs_process.7f2c90ed.js"])),"v-3277876f":Z(()=>k(()=>import("./curl_annex.html.78584c4b.js"),[])),"v-a8728f2e":Z(()=>k(()=>import("./index.html.8056bbb9.js"),[])),"v-14dd1095":Z(()=>k(()=>import("./iostreams.html.bd4d2ac8.js"),["assets/iostreams.html.bd4d2ac8.js","assets/Java_Stream_Readers_BufferedReaders.170e97e8.js"])),"v-5320ff04":Z(()=>k(()=>import("./processbuilder.html.ff1616f6.js"),["assets/processbuilder.html.ff1616f6.js","assets/comandotree.fa02cb62.js"])),"v-b8500a2c":Z(()=>k(()=>import("./runtime.html.47674217.js"),[])),"v-6718eaab":Z(()=>k(()=>import("./alternatives.html.2e09e209.js"),[])),"v-75f16356":Z(()=>k(()=>import("./arraylist_annex.html.82f52c4a.js"),["assets/arraylist_annex.html.82f52c4a.js","assets/Collections_class_diagram.8db4bff0.js"])),"v-36533f4a":Z(()=>k(()=>import("./debugger_annex.html.907d6bff.js"),["assets/debugger_annex.html.907d6bff.js","assets/NetbeansDebug5.890d9d49.js"])),"v-405378de":Z(()=>k(()=>import("./hashmap_annex.html.8e210246.js"),["assets/hashmap_annex.html.8e210246.js","assets/Collections_class_diagram.8db4bff0.js"])),"v-a8728ef0":Z(()=>k(()=>import("./index.html.e45028a5.js"),[])),"v-2a24fba0":Z(()=>k(()=>import("./producer-consumer.html.6ffcdb2e.js"),["assets/producer-consumer.html.6ffcdb2e.js","assets/ProducerConsumer.8367c5c5.js"])),"v-2b693c54":Z(()=>k(()=>import("./runnable.html.64ebb0a8.js"),[])),"v-5c5621fe":Z(()=>k(()=>import("./synchronization.html.2545fdc3.js"),["assets/synchronization.html.2545fdc3.js","assets/Monitor_queues.a0c5134f.js"])),"v-a8728eb2":Z(()=>k(()=>import("./index.html.a10e0513.js"),[])),"v-00fed00c":Z(()=>k(()=>import("./sockets-tcp.html.0609edd4.js"),["assets/sockets-tcp.html.0609edd4.js","assets/multithread_server_sequence.7901f27a.js"])),"v-c4738fa8":Z(()=>k(()=>import("./sockets-udp.html.eac5e6c6.js"),["assets/sockets-udp.html.eac5e6c6.js","assets/udp_process.3be6e717.js"])),"v-fefd7e10":Z(()=>k(()=>import("./stateful-protocols.html.8d83ce4b.js"),["assets/stateful-protocols.html.8d83ce4b.js","assets/client_sample_state_protocol.1514f343.js"])),"v-d5e6a1c2":Z(()=>k(()=>import("./tcp-ip.html.c671a8f7.js"),["assets/tcp-ip.html.c671a8f7.js","assets/5-Graphic-UDP-Vs-TCP.ef6f7d46.js"])),"v-75d559ae":Z(()=>k(()=>import("./urls.html.a54b43a4.js"),[])),"v-222706b3":Z(()=>k(()=>import("./asymmetric-keys.html.699c70ef.js"),["assets/asymmetric-keys.html.699c70ef.js","assets/digital-signature-sign-verify.3b3014a7.js"])),"v-6cd9bbb8":Z(()=>k(()=>import("./hash-functions.html.24c5b3df.js"),[])),"v-a8728e36":Z(()=>k(()=>import("./index.html.62f06b09.js"),[])),"v-02f6ed19":Z(()=>k(()=>import("./jsse.html.d4994aa7.js"),["assets/jsse.html.d4994aa7.js","assets/VM_Options.cfaf4215.js"])),"v-6d98f4d4":Z(()=>k(()=>import("./security.html.997017fb.js"),[])),"v-03a9dd55":Z(()=>k(()=>import("./symmetric-key.html.baad2191.js"),["assets/symmetric-key.html.baad2191.js","assets/symmetric-encryption-primitive.e35e72d2.js"])),"v-3706649a":Z(()=>k(()=>import("./404.html.50f743eb.js"),[]))};var kn=(e={})=>e;function gi(e,n,r){var a,o,t;n===void 0&&(n=50),r===void 0&&(r={});var s=(a=r.isImmediate)!=null&&a,i=(o=r.callback)!=null&&o,l=r.maxWait,c=Date.now(),d=[];function m(){if(l!==void 0){var p=Date.now()-c;if(p+n>=l)return l-p}return n}var u=function(){var p=[].slice.call(arguments),b=this;return new Promise(function(q,w){var f=s&&t===void 0;if(t!==void 0&&clearTimeout(t),t=setTimeout(function(){if(t=void 0,c=Date.now(),!s){var C=e.apply(b,p);i&&i(C),d.forEach(function(R){return(0,R.resolve)(C)}),d=[]}},m()),f){var S=e.apply(b,p);return i&&i(S),q(S)}d.push({resolve:q,reject:w})})};return u.cancel=function(p){t!==void 0&&clearTimeout(t),d.forEach(function(b){return(0,b.reject)(p)}),d=[]},u}/*!
  * vue-router v4.1.5
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */const ir=typeof window<"u";function zd(e){return e.__esModule||e[Symbol.toStringTag]==="Module"}const Pe=Object.assign;function Fa(e,n){const r={};for(const a in n){const o=n[a];r[a]=un(o)?o.map(e):e(o)}return r}const _r=()=>{},un=Array.isArray,Od=/\/$/,Md=e=>e.replace(Od,"");function Ua(e,n,r="/"){let a,o={},t="",s="";const i=n.indexOf("#");let l=n.indexOf("?");return i<l&&i>=0&&(l=-1),l>-1&&(a=n.slice(0,l),t=n.slice(l+1,i>-1?i:n.length),o=e(t)),i>-1&&(a=a||n.slice(0,i),s=n.slice(i,n.length)),a=Ud(a!=null?a:n,r),{fullPath:a+(t&&"?")+t+s,path:a,query:o,hash:s}}function Nd(e,n){const r=n.query?e(n.query):"";return n.path+(r&&"?")+r+(n.hash||"")}function xt(e,n){return!n||!e.toLowerCase().startsWith(n.toLowerCase())?e:e.slice(n.length)||"/"}function Bd(e,n,r){const a=n.matched.length-1,o=r.matched.length-1;return a>-1&&a===o&&fr(n.matched[a],r.matched[o])&&fi(n.params,r.params)&&e(n.query)===e(r.query)&&n.hash===r.hash}function fr(e,n){return(e.aliasOf||e)===(n.aliasOf||n)}function fi(e,n){if(Object.keys(e).length!==Object.keys(n).length)return!1;for(const r in e)if(!Fd(e[r],n[r]))return!1;return!0}function Fd(e,n){return un(e)?At(e,n):un(n)?At(n,e):e===n}function At(e,n){return un(n)?e.length===n.length&&e.every((r,a)=>r===n[a]):e.length===1&&e[0]===n}function Ud(e,n){if(e.startsWith("/"))return e;if(!e)return n;const r=n.split("/"),a=e.split("/");let o=r.length-1,t,s;for(t=0;t<a.length;t++)if(s=a[t],s!==".")if(s==="..")o>1&&o--;else break;return r.slice(0,o).join("/")+"/"+a.slice(t-(t===a.length?1:0)).join("/")}var Nr;(function(e){e.pop="pop",e.push="push"})(Nr||(Nr={}));var Tr;(function(e){e.back="back",e.forward="forward",e.unknown=""})(Tr||(Tr={}));function Hd(e){if(!e)if(ir){const n=document.querySelector("base");e=n&&n.getAttribute("href")||"/",e=e.replace(/^\w+:\/\/[^\/]+/,"")}else e="/";return e[0]!=="/"&&e[0]!=="#"&&(e="/"+e),Md(e)}const Wd=/^[^#]+#/;function Vd(e,n){return e.replace(Wd,"#")+n}function Jd(e,n){const r=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{behavior:n.behavior,left:a.left-r.left-(n.left||0),top:a.top-r.top-(n.top||0)}}const _a=()=>({left:window.pageXOffset,top:window.pageYOffset});function Gd(e){let n;if("el"in e){const r=e.el,a=typeof r=="string"&&r.startsWith("#"),o=typeof r=="string"?a?document.getElementById(r.slice(1)):document.querySelector(r):r;if(!o)return;n=Jd(o,e)}else n=e;"scrollBehavior"in document.documentElement.style?window.scrollTo(n):window.scrollTo(n.left!=null?n.left:window.pageXOffset,n.top!=null?n.top:window.pageYOffset)}function It(e,n){return(history.state?history.state.position-n:-1)+e}const lo=new Map;function Kd(e,n){lo.set(e,n)}function $d(e){const n=lo.get(e);return lo.delete(e),n}let Yd=()=>location.protocol+"//"+location.host;function vi(e,n){const{pathname:r,search:a,hash:o}=n,t=e.indexOf("#");if(t>-1){let i=o.includes(e.slice(t))?e.slice(t).length:1,l=o.slice(i);return l[0]!=="/"&&(l="/"+l),xt(l,"")}return xt(r,e)+a+o}function Qd(e,n,r,a){let o=[],t=[],s=null;const i=({state:u})=>{const p=vi(e,location),b=r.value,q=n.value;let w=0;if(u){if(r.value=p,n.value=u,s&&s===b){s=null;return}w=q?u.position-q.position:0}else a(p);o.forEach(f=>{f(r.value,b,{delta:w,type:Nr.pop,direction:w?w>0?Tr.forward:Tr.back:Tr.unknown})})};function l(){s=r.value}function c(u){o.push(u);const p=()=>{const b=o.indexOf(u);b>-1&&o.splice(b,1)};return t.push(p),p}function d(){const{history:u}=window;!u.state||u.replaceState(Pe({},u.state,{scroll:_a()}),"")}function m(){for(const u of t)u();t=[],window.removeEventListener("popstate",i),window.removeEventListener("beforeunload",d)}return window.addEventListener("popstate",i),window.addEventListener("beforeunload",d),{pauseListeners:l,listen:c,destroy:m}}function _t(e,n,r,a=!1,o=!1){return{back:e,current:n,forward:r,replaced:a,position:window.history.length,scroll:o?_a():null}}function Xd(e){const{history:n,location:r}=window,a={value:vi(e,r)},o={value:n.state};o.value||t(a.value,{back:null,current:a.value,forward:null,position:n.length-1,replaced:!0,scroll:null},!0);function t(l,c,d){const m=e.indexOf("#"),u=m>-1?(r.host&&document.querySelector("base")?e:e.slice(m))+l:Yd()+e+l;try{n[d?"replaceState":"pushState"](c,"",u),o.value=c}catch(p){console.error(p),r[d?"replace":"assign"](u)}}function s(l,c){const d=Pe({},n.state,_t(o.value.back,l,o.value.forward,!0),c,{position:o.value.position});t(l,d,!0),a.value=l}function i(l,c){const d=Pe({},o.value,n.state,{forward:l,scroll:_a()});t(d.current,d,!0);const m=Pe({},_t(a.value,l,null),{position:d.position+1},c);t(l,m,!1),a.value=l}return{location:a,state:o,push:i,replace:s}}function Zd(e){e=Hd(e);const n=Xd(e),r=Qd(e,n.state,n.location,n.replace);function a(t,s=!0){s||r.pauseListeners(),history.go(t)}const o=Pe({location:"",base:e,go:a,createHref:Vd.bind(null,e)},n,r);return Object.defineProperty(o,"location",{enumerable:!0,get:()=>n.location.value}),Object.defineProperty(o,"state",{enumerable:!0,get:()=>n.state.value}),o}function eu(e){return typeof e=="string"||e&&typeof e=="object"}function bi(e){return typeof e=="string"||typeof e=="symbol"}const vn={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0},yi=Symbol("");var Tt;(function(e){e[e.aborted=4]="aborted",e[e.cancelled=8]="cancelled",e[e.duplicated=16]="duplicated"})(Tt||(Tt={}));function vr(e,n){return Pe(new Error,{type:e,[yi]:!0},n)}function fn(e,n){return e instanceof Error&&yi in e&&(n==null||!!(e.type&n))}const Lt="[^/]+?",nu={sensitive:!1,strict:!1,start:!0,end:!0},ru=/[.+*?^${}()[\]/\\]/g;function au(e,n){const r=Pe({},nu,n),a=[];let o=r.start?"^":"";const t=[];for(const c of e){const d=c.length?[]:[90];r.strict&&!c.length&&(o+="/");for(let m=0;m<c.length;m++){const u=c[m];let p=40+(r.sensitive?.25:0);if(u.type===0)m||(o+="/"),o+=u.value.replace(ru,"\\$&"),p+=40;else if(u.type===1){const{value:b,repeatable:q,optional:w,regexp:f}=u;t.push({name:b,repeatable:q,optional:w});const S=f||Lt;if(S!==Lt){p+=10;try{new RegExp(`(${S})`)}catch(R){throw new Error(`Invalid custom RegExp for param "${b}" (${S}): `+R.message)}}let C=q?`((?:${S})(?:/(?:${S}))*)`:`(${S})`;m||(C=w&&c.length<2?`(?:/${C})`:"/"+C),w&&(C+="?"),o+=C,p+=20,w&&(p+=-8),q&&(p+=-20),S===".*"&&(p+=-50)}d.push(p)}a.push(d)}if(r.strict&&r.end){const c=a.length-1;a[c][a[c].length-1]+=.7000000000000001}r.strict||(o+="/?"),r.end?o+="$":r.strict&&(o+="(?:/|$)");const s=new RegExp(o,r.sensitive?"":"i");function i(c){const d=c.match(s),m={};if(!d)return null;for(let u=1;u<d.length;u++){const p=d[u]||"",b=t[u-1];m[b.name]=p&&b.repeatable?p.split("/"):p}return m}function l(c){let d="",m=!1;for(const u of e){(!m||!d.endsWith("/"))&&(d+="/"),m=!1;for(const p of u)if(p.type===0)d+=p.value;else if(p.type===1){const{value:b,repeatable:q,optional:w}=p,f=b in c?c[b]:"";if(un(f)&&!q)throw new Error(`Provided param "${b}" is an array but it is not repeatable (* or + modifiers)`);const S=un(f)?f.join("/"):f;if(!S)if(w)u.length<2&&(d.endsWith("/")?d=d.slice(0,-1):m=!0);else throw new Error(`Missing required param "${b}"`);d+=S}}return d||"/"}return{re:s,score:a,keys:t,parse:i,stringify:l}}function ou(e,n){let r=0;for(;r<e.length&&r<n.length;){const a=n[r]-e[r];if(a)return a;r++}return e.length<n.length?e.length===1&&e[0]===40+40?-1:1:e.length>n.length?n.length===1&&n[0]===40+40?1:-1:0}function tu(e,n){let r=0;const a=e.score,o=n.score;for(;r<a.length&&r<o.length;){const t=ou(a[r],o[r]);if(t)return t;r++}if(Math.abs(o.length-a.length)===1){if(Dt(a))return 1;if(Dt(o))return-1}return o.length-a.length}function Dt(e){const n=e[e.length-1];return e.length>0&&n[n.length-1]<0}const su={type:0,value:""},iu=/[a-zA-Z0-9_]/;function lu(e){if(!e)return[[]];if(e==="/")return[[su]];if(!e.startsWith("/"))throw new Error(`Invalid path "${e}"`);function n(p){throw new Error(`ERR (${r})/"${c}": ${p}`)}let r=0,a=r;const o=[];let t;function s(){t&&o.push(t),t=[]}let i=0,l,c="",d="";function m(){!c||(r===0?t.push({type:0,value:c}):r===1||r===2||r===3?(t.length>1&&(l==="*"||l==="+")&&n(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),t.push({type:1,value:c,regexp:d,repeatable:l==="*"||l==="+",optional:l==="*"||l==="?"})):n("Invalid state to consume buffer"),c="")}function u(){c+=l}for(;i<e.length;){if(l=e[i++],l==="\\"&&r!==2){a=r,r=4;continue}switch(r){case 0:l==="/"?(c&&m(),s()):l===":"?(m(),r=1):u();break;case 4:u(),r=a;break;case 1:l==="("?r=2:iu.test(l)?u():(m(),r=0,l!=="*"&&l!=="?"&&l!=="+"&&i--);break;case 2:l===")"?d[d.length-1]=="\\"?d=d.slice(0,-1)+l:r=3:d+=l;break;case 3:m(),r=0,l!=="*"&&l!=="?"&&l!=="+"&&i--,d="";break;default:n("Unknown state");break}}return r===2&&n(`Unfinished custom RegExp for param "${c}"`),m(),s(),o}function cu(e,n,r){const a=au(lu(e.path),r),o=Pe(a,{record:e,parent:n,children:[],alias:[]});return n&&!o.record.aliasOf==!n.record.aliasOf&&n.children.push(o),o}function du(e,n){const r=[],a=new Map;n=Ot({strict:!1,end:!0,sensitive:!1},n);function o(d){return a.get(d)}function t(d,m,u){const p=!u,b=uu(d);b.aliasOf=u&&u.record;const q=Ot(n,d),w=[b];if("alias"in d){const C=typeof d.alias=="string"?[d.alias]:d.alias;for(const R of C)w.push(Pe({},b,{components:u?u.record.components:b.components,path:R,aliasOf:u?u.record:b}))}let f,S;for(const C of w){const{path:R}=C;if(m&&R[0]!=="/"){const U=m.record.path,X=U[U.length-1]==="/"?"":"/";C.path=m.record.path+(R&&X+R)}if(f=cu(C,m,q),u?u.alias.push(f):(S=S||f,S!==f&&S.alias.push(f),p&&d.name&&!zt(f)&&s(d.name)),b.children){const U=b.children;for(let X=0;X<U.length;X++)t(U[X],f,u&&u.children[X])}u=u||f,l(f)}return S?()=>{s(S)}:_r}function s(d){if(bi(d)){const m=a.get(d);m&&(a.delete(d),r.splice(r.indexOf(m),1),m.children.forEach(s),m.alias.forEach(s))}else{const m=r.indexOf(d);m>-1&&(r.splice(m,1),d.record.name&&a.delete(d.record.name),d.children.forEach(s),d.alias.forEach(s))}}function i(){return r}function l(d){let m=0;for(;m<r.length&&tu(d,r[m])>=0&&(d.record.path!==r[m].record.path||!Si(d,r[m]));)m++;r.splice(m,0,d),d.record.name&&!zt(d)&&a.set(d.record.name,d)}function c(d,m){let u,p={},b,q;if("name"in d&&d.name){if(u=a.get(d.name),!u)throw vr(1,{location:d});q=u.record.name,p=Pe(Rt(m.params,u.keys.filter(S=>!S.optional).map(S=>S.name)),d.params&&Rt(d.params,u.keys.map(S=>S.name))),b=u.stringify(p)}else if("path"in d)b=d.path,u=r.find(S=>S.re.test(b)),u&&(p=u.parse(b),q=u.record.name);else{if(u=m.name?a.get(m.name):r.find(S=>S.re.test(m.path)),!u)throw vr(1,{location:d,currentLocation:m});q=u.record.name,p=Pe({},m.params,d.params),b=u.stringify(p)}const w=[];let f=u;for(;f;)w.unshift(f.record),f=f.parent;return{name:q,path:b,params:p,matched:w,meta:pu(w)}}return e.forEach(d=>t(d)),{addRoute:t,resolve:c,removeRoute:s,getRoutes:i,getRecordMatcher:o}}function Rt(e,n){const r={};for(const a of n)a in e&&(r[a]=e[a]);return r}function uu(e){return{path:e.path,redirect:e.redirect,name:e.name,meta:e.meta||{},aliasOf:void 0,beforeEnter:e.beforeEnter,props:mu(e),children:e.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in e?e.components||null:e.component&&{default:e.component}}}function mu(e){const n={},r=e.props||!1;if("component"in e)n.default=r;else for(const a in e.components)n[a]=typeof r=="boolean"?r:r[a];return n}function zt(e){for(;e;){if(e.record.aliasOf)return!0;e=e.parent}return!1}function pu(e){return e.reduce((n,r)=>Pe(n,r.meta),{})}function Ot(e,n){const r={};for(const a in e)r[a]=a in n?n[a]:e[a];return r}function Si(e,n){return n.children.some(r=>r===e||Si(e,r))}const wi=/#/g,hu=/&/g,gu=/\//g,fu=/=/g,vu=/\?/g,Pi=/\+/g,bu=/%5B/g,yu=/%5D/g,Ei=/%5E/g,Su=/%60/g,qi=/%7B/g,wu=/%7C/g,Ci=/%7D/g,Pu=/%20/g;function Lo(e){return encodeURI(""+e).replace(wu,"|").replace(bu,"[").replace(yu,"]")}function Eu(e){return Lo(e).replace(qi,"{").replace(Ci,"}").replace(Ei,"^")}function co(e){return Lo(e).replace(Pi,"%2B").replace(Pu,"+").replace(wi,"%23").replace(hu,"%26").replace(Su,"`").replace(qi,"{").replace(Ci,"}").replace(Ei,"^")}function qu(e){return co(e).replace(fu,"%3D")}function Cu(e){return Lo(e).replace(wi,"%23").replace(vu,"%3F")}function ku(e){return e==null?"":Cu(e).replace(gu,"%2F")}function fa(e){try{return decodeURIComponent(""+e)}catch{}return""+e}function ju(e){const n={};if(e===""||e==="?")return n;const a=(e[0]==="?"?e.slice(1):e).split("&");for(let o=0;o<a.length;++o){const t=a[o].replace(Pi," "),s=t.indexOf("="),i=fa(s<0?t:t.slice(0,s)),l=s<0?null:fa(t.slice(s+1));if(i in n){let c=n[i];un(c)||(c=n[i]=[c]),c.push(l)}else n[i]=l}return n}function Mt(e){let n="";for(let r in e){const a=e[r];if(r=qu(r),a==null){a!==void 0&&(n+=(n.length?"&":"")+r);continue}(un(a)?a.map(t=>t&&co(t)):[a&&co(a)]).forEach(t=>{t!==void 0&&(n+=(n.length?"&":"")+r,t!=null&&(n+="="+t))})}return n}function xu(e){const n={};for(const r in e){const a=e[r];a!==void 0&&(n[r]=un(a)?a.map(o=>o==null?null:""+o):a==null?a:""+a)}return n}const Au=Symbol(""),Nt=Symbol(""),Ta=Symbol(""),Do=Symbol(""),uo=Symbol("");function Cr(){let e=[];function n(a){return e.push(a),()=>{const o=e.indexOf(a);o>-1&&e.splice(o,1)}}function r(){e=[]}return{add:n,list:()=>e,reset:r}}function Ln(e,n,r,a,o){const t=a&&(a.enterCallbacks[o]=a.enterCallbacks[o]||[]);return()=>new Promise((s,i)=>{const l=m=>{m===!1?i(vr(4,{from:r,to:n})):m instanceof Error?i(m):eu(m)?i(vr(2,{from:n,to:m})):(t&&a.enterCallbacks[o]===t&&typeof m=="function"&&t.push(m),s())},c=e.call(a&&a.instances[o],n,r,l);let d=Promise.resolve(c);e.length<3&&(d=d.then(l)),d.catch(m=>i(m))})}function Ha(e,n,r,a){const o=[];for(const t of e)for(const s in t.components){let i=t.components[s];if(!(n!=="beforeRouteEnter"&&!t.instances[s]))if(Iu(i)){const c=(i.__vccOpts||i)[n];c&&o.push(Ln(c,r,a,t,s))}else{let l=i();o.push(()=>l.then(c=>{if(!c)return Promise.reject(new Error(`Couldn't resolve component "${s}" at "${t.path}"`));const d=zd(c)?c.default:c;t.components[s]=d;const u=(d.__vccOpts||d)[n];return u&&Ln(u,r,a,t,s)()}))}}return o}function Iu(e){return typeof e=="object"||"displayName"in e||"props"in e||"__vccOpts"in e}function Bt(e){const n=Be(Ta),r=Be(Do),a=J(()=>n.resolve(M(e.to))),o=J(()=>{const{matched:l}=a.value,{length:c}=l,d=l[c-1],m=r.matched;if(!d||!m.length)return-1;const u=m.findIndex(fr.bind(null,d));if(u>-1)return u;const p=Ft(l[c-2]);return c>1&&Ft(d)===p&&m[m.length-1].path!==p?m.findIndex(fr.bind(null,l[c-2])):u}),t=J(()=>o.value>-1&&Du(r.params,a.value.params)),s=J(()=>o.value>-1&&o.value===r.matched.length-1&&fi(r.params,a.value.params));function i(l={}){return Lu(l)?n[M(e.replace)?"replace":"push"](M(e.to)).catch(_r):Promise.resolve()}return{route:a,href:J(()=>a.value.href),isActive:t,isExactActive:s,navigate:i}}const _u=ge({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:Bt,setup(e,{slots:n}){const r=Sr(Bt(e)),{options:a}=Be(Ta),o=J(()=>({[Ut(e.activeClass,a.linkActiveClass,"router-link-active")]:r.isActive,[Ut(e.exactActiveClass,a.linkExactActiveClass,"router-link-exact-active")]:r.isExactActive}));return()=>{const t=n.default&&n.default(r);return e.custom?t:pe("a",{"aria-current":r.isExactActive?e.ariaCurrentValue:null,href:r.href,onClick:r.navigate,class:o.value},t)}}}),Tu=_u;function Lu(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)&&!e.defaultPrevented&&!(e.button!==void 0&&e.button!==0)){if(e.currentTarget&&e.currentTarget.getAttribute){const n=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(n))return}return e.preventDefault&&e.preventDefault(),!0}}function Du(e,n){for(const r in n){const a=n[r],o=e[r];if(typeof a=="string"){if(a!==o)return!1}else if(!un(o)||o.length!==a.length||a.some((t,s)=>t!==o[s]))return!1}return!0}function Ft(e){return e?e.aliasOf?e.aliasOf.path:e.path:""}const Ut=(e,n,r)=>e!=null?e:n!=null?n:r,Ru=ge({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(e,{attrs:n,slots:r}){const a=Be(uo),o=J(()=>e.route||a.value),t=Be(Nt,0),s=J(()=>{let c=M(t);const{matched:d}=o.value;let m;for(;(m=d[c])&&!m.components;)c++;return c}),i=J(()=>o.value.matched[s.value]);er(Nt,J(()=>s.value+1)),er(Au,i),er(uo,o);const l=qe();return dn(()=>[l.value,i.value,e.name],([c,d,m],[u,p,b])=>{d&&(d.instances[m]=c,p&&p!==d&&c&&c===u&&(d.leaveGuards.size||(d.leaveGuards=p.leaveGuards),d.updateGuards.size||(d.updateGuards=p.updateGuards))),c&&d&&(!p||!fr(d,p)||!u)&&(d.enterCallbacks[m]||[]).forEach(q=>q(c))},{flush:"post"}),()=>{const c=o.value,d=e.name,m=i.value,u=m&&m.components[d];if(!u)return Ht(r.default,{Component:u,route:c});const p=m.props[d],b=p?p===!0?c.params:typeof p=="function"?p(c):p:null,w=pe(u,Pe({},b,n,{onVnodeUnmounted:f=>{f.component.isUnmounted&&(m.instances[d]=null)},ref:l}));return Ht(r.default,{Component:w,route:c})||w}}});function Ht(e,n){if(!e)return null;const r=e(n);return r.length===1?r[0]:r}const ki=Ru;function zu(e){const n=du(e.routes,e),r=e.parseQuery||ju,a=e.stringifyQuery||Mt,o=e.history,t=Cr(),s=Cr(),i=Cr(),l=Ts(vn);let c=vn;ir&&e.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const d=Fa.bind(null,A=>""+A),m=Fa.bind(null,ku),u=Fa.bind(null,fa);function p(A,Q){let z,K;return bi(A)?(z=n.getRecordMatcher(A),K=Q):K=A,n.addRoute(K,z)}function b(A){const Q=n.getRecordMatcher(A);Q&&n.removeRoute(Q)}function q(){return n.getRoutes().map(A=>A.record)}function w(A){return!!n.getRecordMatcher(A)}function f(A,Q){if(Q=Pe({},Q||l.value),typeof A=="string"){const te=Ua(r,A,Q.path),h=n.resolve({path:te.path},Q),v=o.createHref(te.fullPath);return Pe(te,h,{params:u(h.params),hash:fa(te.hash),redirectedFrom:void 0,href:v})}let z;if("path"in A)z=Pe({},A,{path:Ua(r,A.path,Q.path).path});else{const te=Pe({},A.params);for(const h in te)te[h]==null&&delete te[h];z=Pe({},A,{params:m(A.params)}),Q.params=m(Q.params)}const K=n.resolve(z,Q),me=A.hash||"";K.params=d(u(K.params));const fe=Nd(a,Pe({},A,{hash:Eu(me),path:K.path})),de=o.createHref(fe);return Pe({fullPath:fe,hash:me,query:a===Mt?xu(A.query):A.query||{}},K,{redirectedFrom:void 0,href:de})}function S(A){return typeof A=="string"?Ua(r,A,l.value.path):Pe({},A)}function C(A,Q){if(c!==A)return vr(8,{from:Q,to:A})}function R(A){return x(A)}function U(A){return R(Pe(S(A),{replace:!0}))}function X(A){const Q=A.matched[A.matched.length-1];if(Q&&Q.redirect){const{redirect:z}=Q;let K=typeof z=="function"?z(A):z;return typeof K=="string"&&(K=K.includes("?")||K.includes("#")?K=S(K):{path:K},K.params={}),Pe({query:A.query,hash:A.hash,params:"path"in K?{}:A.params},K)}}function x(A,Q){const z=c=f(A),K=l.value,me=A.state,fe=A.force,de=A.replace===!0,te=X(z);if(te)return x(Pe(S(te),{state:typeof te=="object"?Pe({},me,te.state):me,force:fe,replace:de}),Q||z);const h=z;h.redirectedFrom=Q;let v;return!fe&&Bd(a,K,z)&&(v=vr(16,{to:h,from:K}),ue(K,K,!0,!1)),(v?Promise.resolve(v):Y(h,K)).catch(E=>fn(E)?fn(E,2)?E:ce(E):N(E,h,K)).then(E=>{if(E){if(fn(E,2))return x(Pe({replace:de},S(E.to),{state:typeof E.to=="object"?Pe({},me,E.to.state):me,force:fe}),Q||h)}else E=D(h,K,!0,de,me);return W(h,K,E),E})}function g(A,Q){const z=C(A,Q);return z?Promise.reject(z):Promise.resolve()}function Y(A,Q){let z;const[K,me,fe]=Ou(A,Q);z=Ha(K.reverse(),"beforeRouteLeave",A,Q);for(const te of K)te.leaveGuards.forEach(h=>{z.push(Ln(h,A,Q))});const de=g.bind(null,A,Q);return z.push(de),tr(z).then(()=>{z=[];for(const te of t.list())z.push(Ln(te,A,Q));return z.push(de),tr(z)}).then(()=>{z=Ha(me,"beforeRouteUpdate",A,Q);for(const te of me)te.updateGuards.forEach(h=>{z.push(Ln(h,A,Q))});return z.push(de),tr(z)}).then(()=>{z=[];for(const te of A.matched)if(te.beforeEnter&&!Q.matched.includes(te))if(un(te.beforeEnter))for(const h of te.beforeEnter)z.push(Ln(h,A,Q));else z.push(Ln(te.beforeEnter,A,Q));return z.push(de),tr(z)}).then(()=>(A.matched.forEach(te=>te.enterCallbacks={}),z=Ha(fe,"beforeRouteEnter",A,Q),z.push(de),tr(z))).then(()=>{z=[];for(const te of s.list())z.push(Ln(te,A,Q));return z.push(de),tr(z)}).catch(te=>fn(te,8)?te:Promise.reject(te))}function W(A,Q,z){for(const K of i.list())K(A,Q,z)}function D(A,Q,z,K,me){const fe=C(A,Q);if(fe)return fe;const de=Q===vn,te=ir?history.state:{};z&&(K||de?o.replace(A.fullPath,Pe({scroll:de&&te&&te.scroll},me)):o.push(A.fullPath,me)),l.value=A,ue(A,Q,z,de),ce()}let y;function P(){y||(y=o.listen((A,Q,z)=>{if(!$e.listening)return;const K=f(A),me=X(K);if(me){x(Pe(me,{replace:!0}),K).catch(_r);return}c=K;const fe=l.value;ir&&Kd(It(fe.fullPath,z.delta),_a()),Y(K,fe).catch(de=>fn(de,12)?de:fn(de,2)?(x(de.to,K).then(te=>{fn(te,20)&&!z.delta&&z.type===Nr.pop&&o.go(-1,!1)}).catch(_r),Promise.reject()):(z.delta&&o.go(-z.delta,!1),N(de,K,fe))).then(de=>{de=de||D(K,fe,!1),de&&(z.delta&&!fn(de,8)?o.go(-z.delta,!1):z.type===Nr.pop&&fn(de,20)&&o.go(-1,!1)),W(K,fe,de)}).catch(_r)}))}let j=Cr(),_=Cr(),I;function N(A,Q,z){ce(A);const K=_.list();return K.length?K.forEach(me=>me(A,Q,z)):console.error(A),Promise.reject(A)}function G(){return I&&l.value!==vn?Promise.resolve():new Promise((A,Q)=>{j.add([A,Q])})}function ce(A){return I||(I=!A,P(),j.list().forEach(([Q,z])=>A?z(A):Q()),j.reset()),A}function ue(A,Q,z,K){const{scrollBehavior:me}=e;if(!ir||!me)return Promise.resolve();const fe=!z&&$d(It(A.fullPath,0))||(K||!z)&&history.state&&history.state.scroll||null;return Hr().then(()=>me(A,Q,fe)).then(de=>de&&Gd(de)).catch(de=>N(de,A,Q))}const we=A=>o.go(A);let De;const Te=new Set,$e={currentRoute:l,listening:!0,addRoute:p,removeRoute:b,hasRoute:w,getRoutes:q,resolve:f,options:e,push:R,replace:U,go:we,back:()=>we(-1),forward:()=>we(1),beforeEach:t.add,beforeResolve:s.add,afterEach:i.add,onError:_.add,isReady:G,install(A){const Q=this;A.component("RouterLink",Tu),A.component("RouterView",ki),A.config.globalProperties.$router=Q,Object.defineProperty(A.config.globalProperties,"$route",{enumerable:!0,get:()=>M(l)}),ir&&!De&&l.value===vn&&(De=!0,R(o.location).catch(me=>{}));const z={};for(const me in vn)z[me]=J(()=>l.value[me]);A.provide(Ta,Q),A.provide(Do,Sr(z)),A.provide(uo,l);const K=A.unmount;Te.add(A),A.unmount=function(){Te.delete(A),Te.size<1&&(c=vn,y&&y(),y=null,l.value=vn,De=!1,I=!1),K()}}};return $e}function tr(e){return e.reduce((n,r)=>n.then(()=>r()),Promise.resolve())}function Ou(e,n){const r=[],a=[],o=[],t=Math.max(n.matched.length,e.matched.length);for(let s=0;s<t;s++){const i=n.matched[s];i&&(e.matched.find(c=>fr(c,i))?a.push(i):r.push(i));const l=e.matched[s];l&&(n.matched.find(c=>fr(c,l))||o.push(l))}return[r,a,o]}function ar(){return Be(Ta)}function jn(){return Be(Do)}const Mu=({headerLinkSelector:e,headerAnchorSelector:n,delay:r,offset:a=5})=>{const o=ar(),s=gi(()=>{var q,w,f,S;const i=Math.max(window.scrollY,document.documentElement.scrollTop,document.body.scrollTop);if(Math.abs(i-0)<a){Wt(o,"");return}const c=window.innerHeight+i,d=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),m=Math.abs(d-c)<a,u=Array.from(document.querySelectorAll(e)),b=Array.from(document.querySelectorAll(n)).filter(C=>u.some(R=>R.hash===C.hash));for(let C=0;C<b.length;C++){const R=b[C],U=b[C+1],X=i>=((w=(q=R.parentElement)==null?void 0:q.offsetTop)!=null?w:0)-a,x=!U||i<((S=(f=U.parentElement)==null?void 0:f.offsetTop)!=null?S:0)-a;if(!(X&&x))continue;const Y=decodeURIComponent(o.currentRoute.value.hash),W=decodeURIComponent(R.hash);if(Y===W)return;if(m){for(let D=C+1;D<b.length;D++)if(Y===decodeURIComponent(b[D].hash))return}Wt(o,W);return}},r);Ke(()=>{window.addEventListener("scroll",s)}),Vr(()=>{window.removeEventListener("scroll",s)})},Wt=async(e,n)=>{const{scrollBehavior:r}=e.options;e.options.scrollBehavior=void 0,await e.replace({query:e.currentRoute.value.query,hash:n,force:!0}).finally(()=>e.options.scrollBehavior=r)},Nu="a.sidebar-item",Bu=".header-anchor",Fu=300,Uu=5,Hu=kn({setup(){Mu({headerLinkSelector:Nu,headerAnchorSelector:Bu,delay:Fu,offset:Uu})}}),Vt=()=>window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,Wu=()=>window.scrollTo({top:0,behavior:"smooth"});const Vu=ge({name:"BackToTop",setup(){const e=qe(0),n=J(()=>e.value>300),r=gi(()=>{e.value=Vt()},100);Ke(()=>{e.value=Vt(),window.addEventListener("scroll",()=>r())});const a=pe("div",{class:"back-to-top",onClick:Wu});return()=>pe(Jr,{name:"back-to-top"},()=>n.value?a:null)}}),Ju=kn({rootComponents:[Vu]});const Gu=pe("svg",{class:"external-link-icon",xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"},[pe("path",{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}),pe("polygon",{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"})]),Ku=ge({name:"ExternalLinkIcon",props:{locales:{type:Object,required:!1,default:()=>({})}},setup(e){const n=wr(),r=J(()=>{var a;return(a=e.locales[n.value])!=null?a:{openInNewWindow:"open in new window"}});return()=>pe("span",[Gu,pe("span",{class:"external-link-icon-sr-only"},r.value.openInNewWindow)])}}),$u={"/en/":{openInNewWindow:"Open in new window"},"/es/":{openInNewWindow:"Abrir en una ventana nueva"},"/":{openInNewWindow:"open in new window"}},Yu=kn({enhance({app:e}){e.component("ExternalLinkIcon",pe(Ku,{locales:$u}))}});/**
 * NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT
 */const be={settings:{minimum:.08,easing:"ease",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,barSelector:'[role="bar"]',parent:"body",template:'<div class="bar" role="bar"></div>'},status:null,set:e=>{const n=be.isStarted();e=Wa(e,be.settings.minimum,1),be.status=e===1?null:e;const r=be.render(!n),a=r.querySelector(be.settings.barSelector),o=be.settings.speed,t=be.settings.easing;return r.offsetWidth,Qu(s=>{na(a,{transform:"translate3d("+Jt(e)+"%,0,0)",transition:"all "+o+"ms "+t}),e===1?(na(r,{transition:"none",opacity:"1"}),r.offsetWidth,setTimeout(function(){na(r,{transition:"all "+o+"ms linear",opacity:"0"}),setTimeout(function(){be.remove(),s()},o)},o)):setTimeout(()=>s(),o)}),be},isStarted:()=>typeof be.status=="number",start:()=>{be.status||be.set(0);const e=()=>{setTimeout(()=>{!be.status||(be.trickle(),e())},be.settings.trickleSpeed)};return be.settings.trickle&&e(),be},done:e=>!e&&!be.status?be:be.inc(.3+.5*Math.random()).set(1),inc:e=>{let n=be.status;return n?(typeof e!="number"&&(e=(1-n)*Wa(Math.random()*n,.1,.95)),n=Wa(n+e,0,.994),be.set(n)):be.start()},trickle:()=>be.inc(Math.random()*be.settings.trickleRate),render:e=>{if(be.isRendered())return document.getElementById("nprogress");Gt(document.documentElement,"nprogress-busy");const n=document.createElement("div");n.id="nprogress",n.innerHTML=be.settings.template;const r=n.querySelector(be.settings.barSelector),a=e?"-100":Jt(be.status||0),o=document.querySelector(be.settings.parent);return na(r,{transition:"all 0 linear",transform:"translate3d("+a+"%,0,0)"}),o!==document.body&&Gt(o,"nprogress-custom-parent"),o==null||o.appendChild(n),n},remove:()=>{Kt(document.documentElement,"nprogress-busy"),Kt(document.querySelector(be.settings.parent),"nprogress-custom-parent");const e=document.getElementById("nprogress");e&&Xu(e)},isRendered:()=>!!document.getElementById("nprogress")},Wa=(e,n,r)=>e<n?n:e>r?r:e,Jt=e=>(-1+e)*100,Qu=function(){const e=[];function n(){const r=e.shift();r&&r(n)}return function(r){e.push(r),e.length===1&&n()}}(),na=function(){const e=["Webkit","O","Moz","ms"],n={};function r(s){return s.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,function(i,l){return l.toUpperCase()})}function a(s){const i=document.body.style;if(s in i)return s;let l=e.length;const c=s.charAt(0).toUpperCase()+s.slice(1);let d;for(;l--;)if(d=e[l]+c,d in i)return d;return s}function o(s){return s=r(s),n[s]||(n[s]=a(s))}function t(s,i,l){i=o(i),s.style[i]=l}return function(s,i){for(const l in i){const c=i[l];c!==void 0&&Object.prototype.hasOwnProperty.call(i,l)&&t(s,l,c)}}}(),ji=(e,n)=>(typeof e=="string"?e:Ro(e)).indexOf(" "+n+" ")>=0,Gt=(e,n)=>{const r=Ro(e),a=r+n;ji(r,n)||(e.className=a.substring(1))},Kt=(e,n)=>{const r=Ro(e);if(!ji(e,n))return;const a=r.replace(" "+n+" "," ");e.className=a.substring(1,a.length-1)},Ro=e=>(" "+(e.className||"")+" ").replace(/\s+/gi," "),Xu=e=>{e&&e.parentNode&&e.parentNode.removeChild(e)};const Zu=()=>{Ke(()=>{const e=ar(),n=new Set;n.add(e.currentRoute.value.path),e.beforeEach(r=>{n.has(r.path)||be.start()}),e.afterEach(r=>{n.add(r.path),be.done()})})},em=kn({setup(){Zu()}}),nm=JSON.parse(`{"logo":"/LogoIES.png","repo":"psp2dam/psp_sources2022","repoLabel":"GitHub","editLink":true,"docsRepo":"https://github.com/psp2dam/psp_sources2022","docsBranch":"main","docsDir":"docs","lastUpdated":true,"sidebarDepth":2,"locales":{"/en/":{"home":"/en/","selectLanguageText":"Languages","selectLanguageName":"English","selectLanguageAriaLabel":"Languages","editLink":false,"editLinkText":"Help us improve this page on GitHub!","lastUpdatedText":"Last updated: ","notFound":["Resource not found in the site"],"backToHome":"Back to home","openInNewWindow":"Open in new window","toggleSidebar":"Hide","serviceWorker":{"updatePopup":{"message":"New content is available.","buttonText":"Refresh"}},"navbar":[{"text":"Aules FP","link":"https://aules.edu.gva.es/fp/"},{"text":"Course Index","children":[{"text":"Unit 1 - Introduction to concurrent programming","link":"/en/unit1/"},{"text":"Unit 2 - Process programming in Java","link":"/en/unit2/"},{"text":"Unit 3 - Multithread programming in Java","link":"/en/unit3/"}]}],"sidebar":{"/en/":[{"text":"PSP > Home","link":"/en/README.md","children":[]}],"/en/unit1/":[{"isGroup":true,"text":"Unit 1 - Introduction to concurrent programming","children":["index.md","process.md","concurrency.md","operatingsystem.md"]}],"/en/unit2/":[{"isGroup":true,"text":"Unit 2 - Process Programming in Java","children":["index.md","runtime.md","processbuilder.md","iostreams.md","curl_annex.md"]}],"/en/unit3/":[{"isGroup":true,"text":"Unit 3 - Multithread Programming in Java","children":["index.md","runnable.md","synchronization.md","producer-consumer.md","alternatives.md","debugger_annex.md","hashmap_annex.md"]}],"/en/unit4/":[{"isGroup":true,"text":"Unit 4 - Network Programming in Java","children":["index.md","tcp-ip.md","urls.md","sockets-tcp.md"]}],"/en/unit6/":[{"isGroup":true,"text":"Unit 6 - Secure programming techniques","children":["index.md"]}]}},"/es/":{"home":"/es/","selectLanguageText":"Idioma","selectLanguageName":"Castellano","selectLanguageAriaLabel":"Idioma","editLink":false,"editLinkText":"Ay\xFAdanos a mejorar esta p\xE1gina en GitHub!","lastUpdatedText":"\xDAltima actualizaci\xF3n: ","contributorsText":"Editores: ","notFound":["No se ha encontrado el recurso solicitado"],"backToHome":"Inicio","openInNewWindow":"Abrir en una ventana nueva","navbar":[{"text":"Aules FP Semi","link":"https://aules.edu.gva.es/semipresencial/"},{"text":"Contenido del curso","children":[{"text":"Tema 1 - Introducci\xF3n a la programaci\xF3n concurrente","link":"/es/unit1/"},{"text":"Tema 2 - Programaci\xF3n de procesos en Java","link":"/es/unit2/"},{"text":"Tema 3 - Programaci\xF3n multihilo en Java","link":"/es/unit3/"}]}],"sidebar":{"/es/":[{"text":"PSP > Inicio","link":"/es/README.md","children":[]}],"/es/unit1/":[{"isGroup":true,"text":"Tema 1 - Introducci\xF3n a la programaci\xF3n concurrente","children":["index.md","process.md","concurrency.md","operatingsystem.md"]}],"/es/unit2/":[{"isGroup":true,"text":"Tema 2 - Programaci\xF3n de procesos en Java","children":["index.md","runtime.md","processbuilder.md","iostreams.md","curl_annex.md"]}],"/es/unit3/":[{"isGroup":true,"text":"Tema 3 - Programaci\xF3n multihilo en Java","children":["index.md","runnable.md","synchronization.md","producer-consumer.md","alternatives.md","debugger_annex.md","hashmap_annex.md"]}],"/es/unit4/":[{"isGroup":true,"text":"Tema 4 - Programaci\xF3n en red en Java","children":["index.md","tcp-ip.md","urls.md","sockets-tcp.md"]}],"/es/unit6/":[{"isGroup":true,"text":"Tema 6 - T\xE9cnicas de programaci\xF3n segura","children":["index.md"]}]}},"/":{"selectLanguageName":"English"}},"colorMode":"auto","colorModeSwitch":true,"navbar":[],"selectLanguageText":"Languages","selectLanguageAriaLabel":"Select language","sidebar":"auto","editLinkText":"Edit this page","lastUpdatedText":"Last Updated","contributors":true,"contributorsText":"Contributors","notFound":["There's nothing here.","How did we get here?","That's a Four-Oh-Four.","Looks like we've got some broken links."],"backToHome":"Take me home","openInNewWindow":"open in new window","toggleColorMode":"toggle color mode","toggleSidebar":"toggle sidebar"}`),xi=qe(nm),rm=()=>xi;import.meta.webpackHot&&(__VUE_HMR_RUNTIME__.updateThemeData=e=>{xi.value=e});const Ai=Symbol(""),am=()=>{const e=Be(Ai);if(!e)throw new Error("useThemeLocaleData() is called without provider.");return e},om=(e,n)=>{var r;return{...e,...(r=e.locales)==null?void 0:r[n]}},tm=kn({enhance({app:e}){const n=rm(),r=e._context.provides[Bo],a=J(()=>om(n.value,r.value));e.provide(Ai,a),Object.defineProperties(e.config.globalProperties,{$theme:{get(){return n.value}},$themeLocale:{get(){return a.value}}})}}),sm=ge({__name:"Badge",props:{type:{type:String,required:!1,default:"tip"},text:{type:String,required:!1,default:""},vertical:{type:String,required:!1,default:void 0}},setup(e){return(n,r)=>(V(),ae("span",{class:Xe(["badge",e.type]),style:Br({verticalAlign:e.vertical})},[xe(n.$slots,"default",{},()=>[Fn(Me(e.text),1)])],6))}}),Le=(e,n)=>{const r=e.__vccOpts||e;for(const[a,o]of n)r[a]=o;return r},im=Le(sm,[["__file","Badge.vue"]]),lm=ge({name:"CodeGroup",setup(e,{slots:n}){const r=qe(-1),a=qe([]),o=(i=r.value)=>{i<a.value.length-1?r.value=i+1:r.value=0,a.value[r.value].focus()},t=(i=r.value)=>{i>0?r.value=i-1:r.value=a.value.length-1,a.value[r.value].focus()},s=(i,l)=>{i.key===" "||i.key==="Enter"?(i.preventDefault(),r.value=l):i.key==="ArrowRight"?(i.preventDefault(),o(l)):i.key==="ArrowLeft"&&(i.preventDefault(),t(l))};return()=>{var l;const i=(((l=n.default)==null?void 0:l.call(n))||[]).filter(c=>c.type.name==="CodeGroupItem").map(c=>(c.props===null&&(c.props={}),c));return i.length===0?null:(r.value<0||r.value>i.length-1?(r.value=i.findIndex(c=>c.props.active===""||c.props.active===!0),r.value===-1&&(r.value=0)):i.forEach((c,d)=>{c.props.active=d===r.value}),pe("div",{class:"code-group"},[pe("div",{class:"code-group__nav"},pe("ul",{class:"code-group__ul"},i.map((c,d)=>{const m=d===r.value;return pe("li",{class:"code-group__li"},pe("button",{ref:u=>{u&&(a.value[d]=u)},class:{"code-group__nav-tab":!0,"code-group__nav-tab-active":m},ariaPressed:m,ariaExpanded:m,onClick:()=>r.value=d,onKeydown:u=>s(u,d)},c.props.title))}))),i]))}}}),cm=["aria-selected"],dm=ge({name:"CodeGroupItem"}),um=ge({...dm,props:{title:{type:String,required:!0},active:{type:Boolean,required:!1,default:!1}},setup(e){return(n,r)=>(V(),ae("div",{class:Xe(["code-group-item",{"code-group-item__active":e.active}]),"aria-selected":e.active},[xe(n.$slots,"default")],10,cm))}}),mm=Le(um,[["__file","CodeGroupItem.vue"]]);var $t;const Ii=typeof window<"u",pm=e=>typeof e=="function",hm=e=>typeof e=="string",Va=()=>{};Ii&&(($t=window==null?void 0:window.navigator)==null?void 0:$t.userAgent)&&/iP(ad|hone|od)/.test(window.navigator.userAgent);function va(e){return typeof e=="function"?e():M(e)}function gm(e,n){function r(...a){e(()=>n.apply(this,a),{fn:n,thisArg:this,args:a})}return r}const _i=e=>e();function fm(e=_i){const n=qe(!0);function r(){n.value=!1}function a(){n.value=!0}return{isActive:n,pause:r,resume:a,eventFilter:(...t)=>{n.value&&e(...t)}}}function vm(e){return e}function Ti(e){return bl()?(yl(e),!0):!1}function bm(e,n=!0){_o()?Ks(e):n?e():Hr(e)}function ym(e,n=!0){_o()?Ke(e):n?e():Hr(e)}function Sm(e=!1,n={}){const{truthyValue:r=!0,falsyValue:a=!1}=n,o=Ne(e),t=qe(e);function s(i){if(arguments.length)return t.value=i,t.value;{const l=va(r);return t.value=t.value===l?va(a):l,t.value}}return o?s:[t,s]}var Yt=Object.getOwnPropertySymbols,wm=Object.prototype.hasOwnProperty,Pm=Object.prototype.propertyIsEnumerable,Em=(e,n)=>{var r={};for(var a in e)wm.call(e,a)&&n.indexOf(a)<0&&(r[a]=e[a]);if(e!=null&&Yt)for(var a of Yt(e))n.indexOf(a)<0&&Pm.call(e,a)&&(r[a]=e[a]);return r};function qm(e,n,r={}){const a=r,{eventFilter:o=_i}=a,t=Em(a,["eventFilter"]);return dn(e,gm(o,n),t)}var Cm=Object.defineProperty,km=Object.defineProperties,jm=Object.getOwnPropertyDescriptors,ba=Object.getOwnPropertySymbols,Li=Object.prototype.hasOwnProperty,Di=Object.prototype.propertyIsEnumerable,Qt=(e,n,r)=>n in e?Cm(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r,xm=(e,n)=>{for(var r in n||(n={}))Li.call(n,r)&&Qt(e,r,n[r]);if(ba)for(var r of ba(n))Di.call(n,r)&&Qt(e,r,n[r]);return e},Am=(e,n)=>km(e,jm(n)),Im=(e,n)=>{var r={};for(var a in e)Li.call(e,a)&&n.indexOf(a)<0&&(r[a]=e[a]);if(e!=null&&ba)for(var a of ba(e))n.indexOf(a)<0&&Di.call(e,a)&&(r[a]=e[a]);return r};function _m(e,n,r={}){const a=r,{eventFilter:o}=a,t=Im(a,["eventFilter"]),{eventFilter:s,pause:i,resume:l,isActive:c}=fm(o);return{stop:qm(e,n,Am(xm({},t),{eventFilter:s})),pause:i,resume:l,isActive:c}}function Tm(e){var n;const r=va(e);return(n=r==null?void 0:r.$el)!=null?n:r}const ya=Ii?window:void 0;function Lm(...e){let n,r,a,o;if(hm(e[0])?([r,a,o]=e,n=ya):[n,r,a,o]=e,!n)return Va;let t=Va;const s=dn(()=>Tm(n),l=>{t(),l&&(l.addEventListener(r,a,o),t=()=>{l.removeEventListener(r,a,o),t=Va})},{immediate:!0,flush:"post"}),i=()=>{s(),t()};return Ti(i),i}function Dm(e,n=!1){const r=qe(),a=()=>r.value=Boolean(e());return a(),ym(a,n),r}function Rm(e,n={}){const{window:r=ya}=n,a=Dm(()=>r&&"matchMedia"in r&&typeof r.matchMedia=="function");let o;const t=qe(!1),s=()=>{!a.value||(o||(o=r.matchMedia(e)),t.value=o.matches)};return bm(()=>{s(),o&&("addEventListener"in o?o.addEventListener("change",s):o.addListener(s),Ti(()=>{"removeEventListener"in o?o.removeEventListener("change",s):o.removeListener(s)}))}),t}const mo=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},po="__vueuse_ssr_handlers__";mo[po]=mo[po]||{};const zm=mo[po];function Om(e,n){return zm[e]||n}function Mm(e){return e==null?"any":e instanceof Set?"set":e instanceof Map?"map":e instanceof Date?"date":typeof e=="boolean"?"boolean":typeof e=="string"?"string":typeof e=="object"||Array.isArray(e)?"object":Number.isNaN(e)?"any":"number"}var Nm=Object.defineProperty,Xt=Object.getOwnPropertySymbols,Bm=Object.prototype.hasOwnProperty,Fm=Object.prototype.propertyIsEnumerable,Zt=(e,n,r)=>n in e?Nm(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r,es=(e,n)=>{for(var r in n||(n={}))Bm.call(n,r)&&Zt(e,r,n[r]);if(Xt)for(var r of Xt(n))Fm.call(n,r)&&Zt(e,r,n[r]);return e};const Um={boolean:{read:e=>e==="true",write:e=>String(e)},object:{read:e=>JSON.parse(e),write:e=>JSON.stringify(e)},number:{read:e=>Number.parseFloat(e),write:e=>String(e)},any:{read:e=>e,write:e=>String(e)},string:{read:e=>e,write:e=>String(e)},map:{read:e=>new Map(JSON.parse(e)),write:e=>JSON.stringify(Array.from(e.entries()))},set:{read:e=>new Set(JSON.parse(e)),write:e=>JSON.stringify(Array.from(e))},date:{read:e=>new Date(e),write:e=>e.toISOString()}};function Hm(e,n,r,a={}){var o;const{flush:t="pre",deep:s=!0,listenToStorageChanges:i=!0,writeDefaults:l=!0,mergeDefaults:c=!1,shallow:d,window:m=ya,eventFilter:u,onError:p=x=>{console.error(x)}}=a,b=(d?Ts:qe)(n);if(!r)try{r=Om("getDefaultStorage",()=>{var x;return(x=ya)==null?void 0:x.localStorage})()}catch(x){p(x)}if(!r)return b;const q=va(n),w=Mm(q),f=(o=a.serializer)!=null?o:Um[w],{pause:S,resume:C}=_m(b,()=>R(b.value),{flush:t,deep:s,eventFilter:u});return m&&i&&Lm(m,"storage",X),X(),b;function R(x){try{x==null?r.removeItem(e):r.setItem(e,f.write(x))}catch(g){p(g)}}function U(x){if(!(x&&x.key!==e)){S();try{const g=x?x.newValue:r.getItem(e);if(g==null)return l&&q!==null&&r.setItem(e,f.write(q)),q;if(!x&&c){const Y=f.read(g);return pm(c)?c(Y,q):w==="object"&&!Array.isArray(Y)?es(es({},q),Y):Y}else return typeof g!="string"?g:f.read(g)}catch(g){p(g)}finally{C()}}}function X(x){x&&x.key!==e||(b.value=U(x))}}function Wm(e){return Rm("(prefers-color-scheme: dark)",e)}var ns;(function(e){e.UP="UP",e.RIGHT="RIGHT",e.DOWN="DOWN",e.LEFT="LEFT",e.NONE="NONE"})(ns||(ns={}));var Vm=Object.defineProperty,rs=Object.getOwnPropertySymbols,Jm=Object.prototype.hasOwnProperty,Gm=Object.prototype.propertyIsEnumerable,as=(e,n,r)=>n in e?Vm(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r,Km=(e,n)=>{for(var r in n||(n={}))Jm.call(n,r)&&as(e,r,n[r]);if(rs)for(var r of rs(n))Gm.call(n,r)&&as(e,r,n[r]);return e};const $m={easeInSine:[.12,0,.39,0],easeOutSine:[.61,1,.88,1],easeInOutSine:[.37,0,.63,1],easeInQuad:[.11,0,.5,0],easeOutQuad:[.5,1,.89,1],easeInOutQuad:[.45,0,.55,1],easeInCubic:[.32,0,.67,0],easeOutCubic:[.33,1,.68,1],easeInOutCubic:[.65,0,.35,1],easeInQuart:[.5,0,.75,0],easeOutQuart:[.25,1,.5,1],easeInOutQuart:[.76,0,.24,1],easeInQuint:[.64,0,.78,0],easeOutQuint:[.22,1,.36,1],easeInOutQuint:[.83,0,.17,1],easeInExpo:[.7,0,.84,0],easeOutExpo:[.16,1,.3,1],easeInOutExpo:[.87,0,.13,1],easeInCirc:[.55,0,1,.45],easeOutCirc:[0,.55,.45,1],easeInOutCirc:[.85,0,.15,1],easeInBack:[.36,0,.66,-.56],easeOutBack:[.34,1.56,.64,1],easeInOutBack:[.68,-.6,.32,1.6]};Km({linear:vm},$m);const Je=()=>am(),Ri=Symbol(""),zo=()=>{const e=Be(Ri);if(!e)throw new Error("useDarkMode() is called without provider.");return e},Ym=()=>{const e=Je(),n=Wm(),r=Hm("vuepress-color-scheme",e.value.colorMode),a=J({get(){return e.value.colorModeSwitch?r.value==="auto"?n.value:r.value==="dark":e.value.colorMode==="dark"},set(o){o===n.value?r.value="auto":r.value=o?"dark":"light"}});er(Ri,a),Qm(a)},Qm=e=>{const n=(r=e.value)=>{const a=window==null?void 0:window.document.querySelector("html");a==null||a.classList.toggle("dark",r)};Ke(()=>{dn(e,n,{immediate:!0})}),xa(()=>n())},zi=(...e)=>{const r=ar().resolve(...e),a=r.matched[r.matched.length-1];if(!(a!=null&&a.redirect))return r;const{redirect:o}=a,t=le(o)?o(r):o,s=Ee(t)?{path:t}:t;return zi({hash:r.hash,query:r.query,params:r.params,...s})},Oo=e=>{const n=zi(encodeURI(e));return{text:n.meta.title||e,link:n.name==="404"?e:n.fullPath}};let Ja=null,kr=null;const Xm={wait:()=>Ja,pending:()=>{Ja=new Promise(e=>kr=e)},resolve:()=>{kr==null||kr(),Ja=null,kr=null}},Oi=()=>Xm,Mi=Symbol("sidebarItems"),Mo=()=>{const e=Be(Mi);if(!e)throw new Error("useSidebarItems() is called without provider.");return e},Zm=()=>{const e=Je(),n=Pn(),r=J(()=>ep(n.value,e.value));er(Mi,r)},ep=(e,n)=>{var o,t,s,i;const r=(t=(o=e.sidebar)!=null?o:n.sidebar)!=null?t:"auto",a=(i=(s=e.sidebarDepth)!=null?s:n.sidebarDepth)!=null?i:2;return e.home||r===!1?[]:r==="auto"?rp(a):oe(r)?Ni(r,a):To(r)?ap(r,a):[]},np=(e,n)=>({text:e.title,link:e.link,children:No(e.children,n)}),No=(e,n)=>n>0?e.map(r=>np(r,n-1)):[],rp=e=>{const n=On();return[{text:n.value.title,children:No(n.value.headers,e)}]},Ni=(e,n)=>{const r=jn(),a=On(),o=t=>{var i;let s;if(Ee(t)?s=Oo(t):s=t,s.children)return{...s,children:s.children.map(l=>o(l))};if(s.link===r.path){const l=((i=a.value.headers[0])==null?void 0:i.level)===1?a.value.headers[0].children:a.value.headers;return{...s,children:No(l,n)}}return s};return e.map(t=>o(t))},ap=(e,n)=>{var t;const r=jn(),a=pi(e,r.path),o=(t=e[a])!=null?t:[];return Ni(o,n)},op={},tp={class:"theme-default-content"};function sp(e,n){const r=qn("Content");return V(),ae("div",tp,[se(r)])}const ip=Le(op,[["render",sp],["__file","HomeContent.vue"]]),lp={key:0,class:"features"},cp=ge({__name:"HomeFeatures",setup(e){const n=Pn(),r=J(()=>oe(n.value.features)?n.value.features:[]);return(a,o)=>M(r).length?(V(),ae("div",lp,[(V(!0),ae(Ae,null,Nn(M(r),t=>(V(),ae("div",{key:t.title,class:"feature"},[ye("h2",null,Me(t.title),1),ye("p",null,Me(t.details),1)]))),128))])):Re("v-if",!0)}}),dp=Le(cp,[["__file","HomeFeatures.vue"]]),up=["innerHTML"],mp=["textContent"],pp=ge({__name:"HomeFooter",setup(e){const n=Pn(),r=J(()=>n.value.footer),a=J(()=>n.value.footerHtml);return(o,t)=>M(r)?(V(),ae(Ae,{key:0},[Re(" eslint-disable-next-line vue/no-v-html "),M(a)?(V(),ae("div",{key:0,class:"footer",innerHTML:M(r)},null,8,up)):(V(),ae("div",{key:1,class:"footer",textContent:Me(M(r))},null,8,mp))],64)):Re("v-if",!0)}}),hp=Le(pp,[["__file","HomeFooter.vue"]]),gp=["href","rel","target","aria-label"],fp=ge({inheritAttrs:!1}),vp=ge({...fp,__name:"AutoLink",props:{item:{type:Object,required:!0}},setup(e){const n=e,r=jn(),a=Zi(),{item:o}=qa(n),t=J(()=>Gr(o.value.link)),s=J(()=>Dd(o.value.link)||Rd(o.value.link)),i=J(()=>{if(!s.value){if(o.value.target)return o.value.target;if(t.value)return"_blank"}}),l=J(()=>i.value==="_blank"),c=J(()=>!t.value&&!s.value&&!l.value),d=J(()=>{if(!s.value){if(o.value.rel)return o.value.rel;if(l.value)return"noopener noreferrer"}}),m=J(()=>o.value.ariaLabel||o.value.text),u=J(()=>{const q=Object.keys(a.value.locales);return q.length?!q.some(w=>w===o.value.link):o.value.link!=="/"}),p=J(()=>u.value?r.path.startsWith(o.value.link):!1),b=J(()=>c.value?o.value.activeMatch?new RegExp(o.value.activeMatch).test(r.path):p.value:!1);return(q,w)=>{const f=qn("RouterLink"),S=qn("AutoLinkExternalIcon");return M(c)?(V(),ze(f,to({key:0,class:{"router-link-active":M(b)},to:M(o).link,"aria-label":M(m)},q.$attrs),{default:Fe(()=>[xe(q.$slots,"before"),Fn(" "+Me(M(o).text)+" ",1),xe(q.$slots,"after")]),_:3},16,["class","to","aria-label"])):(V(),ae("a",to({key:1,class:"external-link",href:M(o).link,rel:M(d),target:M(i),"aria-label":M(m)},q.$attrs),[xe(q.$slots,"before"),Fn(" "+Me(M(o).text)+" ",1),M(l)?(V(),ze(S,{key:0})):Re("v-if",!0),xe(q.$slots,"after")],16,gp))}}}),wn=Le(vp,[["__file","AutoLink.vue"]]),bp={class:"hero"},yp={key:0,id:"main-title"},Sp={key:1,class:"description"},wp={key:2,class:"actions"},Pp=ge({__name:"HomeHero",setup(e){const n=Pn(),r=Fo(),a=zo(),o=J(()=>a.value&&n.value.heroImageDark!==void 0?n.value.heroImageDark:n.value.heroImage),t=J(()=>n.value.heroText===null?null:n.value.heroText||r.value.title||"Hello"),s=J(()=>n.value.heroAlt||t.value||"hero"),i=J(()=>n.value.tagline===null?null:n.value.tagline||r.value.description||"Welcome to your VuePress site"),l=J(()=>oe(n.value.actions)?n.value.actions.map(({text:d,link:m,type:u="primary"})=>({text:d,link:m,type:u})):[]),c=()=>{if(!o.value)return null;const d=pe("img",{src:Ho(o.value),alt:s.value});return n.value.heroImageDark===void 0?d:pe(Uo,()=>d)};return(d,m)=>(V(),ae("header",bp,[se(c),M(t)?(V(),ae("h1",yp,Me(M(t)),1)):Re("v-if",!0),M(i)?(V(),ae("p",Sp,Me(M(i)),1)):Re("v-if",!0),M(l).length?(V(),ae("p",wp,[(V(!0),ae(Ae,null,Nn(M(l),u=>(V(),ze(wn,{key:u.text,class:Xe(["action-button",[u.type]]),item:u},null,8,["class","item"]))),128))])):Re("v-if",!0)]))}}),Ep=Le(Pp,[["__file","HomeHero.vue"]]),qp={class:"home"},Cp=ge({__name:"Home",setup(e){return(n,r)=>(V(),ae("main",qp,[se(Ep),se(dp),se(ip),se(hp)]))}}),kp=Le(Cp,[["__file","Home.vue"]]),jp=ge({__name:"NavbarBrand",setup(e){const n=wr(),r=Fo(),a=Je(),o=zo(),t=J(()=>a.value.home||n.value),s=J(()=>r.value.title),i=J(()=>o.value&&a.value.logoDark!==void 0?a.value.logoDark:a.value.logo),l=()=>{if(!i.value)return null;const c=pe("img",{class:"logo",src:Ho(i.value),alt:s.value});return a.value.logoDark===void 0?c:pe(Uo,()=>c)};return(c,d)=>{const m=qn("RouterLink");return V(),ze(m,{to:M(t)},{default:Fe(()=>[se(l),M(s)?(V(),ae("span",{key:0,class:Xe(["site-name",{"can-hide":M(i)}])},Me(M(s)),3)):Re("v-if",!0)]),_:1},8,["to"])}}}),xp=Le(jp,[["__file","NavbarBrand.vue"]]),Ap=ge({__name:"DropdownTransition",setup(e){const n=a=>{a.style.height=a.scrollHeight+"px"},r=a=>{a.style.height=""};return(a,o)=>(V(),ze(Jr,{name:"dropdown",onEnter:n,onAfterEnter:r,onBeforeLeave:n},{default:Fe(()=>[xe(a.$slots,"default")]),_:3}))}}),Bi=Le(Ap,[["__file","DropdownTransition.vue"]]),Ip=["aria-label"],_p={class:"title"},Tp=ye("span",{class:"arrow down"},null,-1),Lp=["aria-label"],Dp={class:"title"},Rp={class:"navbar-dropdown"},zp={class:"navbar-dropdown-subtitle"},Op={key:1},Mp={class:"navbar-dropdown-subitem-wrapper"},Np=ge({__name:"NavbarDropdown",props:{item:{type:Object,required:!0}},setup(e){const n=e,{item:r}=qa(n),a=J(()=>r.value.ariaLabel||r.value.text),o=qe(!1),t=jn();dn(()=>t.path,()=>{o.value=!1});const s=l=>{l.detail===0?o.value=!o.value:o.value=!1},i=(l,c)=>c[c.length-1]===l;return(l,c)=>(V(),ae("div",{class:Xe(["navbar-dropdown-wrapper",{open:o.value}])},[ye("button",{class:"navbar-dropdown-title",type:"button","aria-label":M(a),onClick:s},[ye("span",_p,Me(M(r).text),1),Tp],8,Ip),ye("button",{class:"navbar-dropdown-title-mobile",type:"button","aria-label":M(a),onClick:c[0]||(c[0]=d=>o.value=!o.value)},[ye("span",Dp,Me(M(r).text),1),ye("span",{class:Xe(["arrow",o.value?"down":"right"])},null,2)],8,Lp),se(Bi,null,{default:Fe(()=>[da(ye("ul",Rp,[(V(!0),ae(Ae,null,Nn(M(r).children,d=>(V(),ae("li",{key:d.text,class:"navbar-dropdown-item"},[d.children?(V(),ae(Ae,{key:0},[ye("h4",zp,[d.link?(V(),ze(wn,{key:0,item:d,onFocusout:m=>i(d,M(r).children)&&d.children.length===0&&(o.value=!1)},null,8,["item","onFocusout"])):(V(),ae("span",Op,Me(d.text),1))]),ye("ul",Mp,[(V(!0),ae(Ae,null,Nn(d.children,m=>(V(),ae("li",{key:m.link,class:"navbar-dropdown-subitem"},[se(wn,{item:m,onFocusout:u=>i(m,d.children)&&i(d,M(r).children)&&(o.value=!1)},null,8,["item","onFocusout"])]))),128))])],64)):(V(),ze(wn,{key:1,item:d,onFocusout:m=>i(d,M(r).children)&&(o.value=!1)},null,8,["item","onFocusout"]))]))),128))],512),[[ga,o.value]])]),_:1})],2))}}),Bp=Le(Np,[["__file","NavbarDropdown.vue"]]),os=e=>decodeURI(e).replace(/#.*$/,"").replace(/(index)?\.(md|html)$/,""),Fp=(e,n)=>{if(n.hash===e)return!0;const r=os(n.path),a=os(e);return r===a},Fi=(e,n)=>e.link&&Fp(e.link,n)?!0:e.children?e.children.some(r=>Fi(r,n)):!1,Ui=e=>!Gr(e)||/github\.com/.test(e)?"GitHub":/bitbucket\.org/.test(e)?"Bitbucket":/gitlab\.com/.test(e)?"GitLab":/gitee\.com/.test(e)?"Gitee":null,Up={GitHub:":repo/edit/:branch/:path",GitLab:":repo/-/edit/:branch/:path",Gitee:":repo/edit/:branch/:path",Bitbucket:":repo/src/:branch/:path?mode=edit&spa=0&at=:branch&fileviewer=file-view-default"},Hp=({docsRepo:e,editLinkPattern:n})=>{if(n)return n;const r=Ui(e);return r!==null?Up[r]:null},Wp=({docsRepo:e,docsBranch:n,docsDir:r,filePathRelative:a,editLinkPattern:o})=>{if(!a)return null;const t=Hp({docsRepo:e,editLinkPattern:o});return t?t.replace(/:repo/,Gr(e)?e:`https://github.com/${e}`).replace(/:branch/,n).replace(/:path/,mi(`${ui(r)}/${a}`)):null},Vp={key:0,class:"navbar-items"},Jp=ge({__name:"NavbarItems",setup(e){const n=()=>{const c=ar(),d=wr(),m=Fo(),u=Je();return J(()=>{var S,C,R;const p=Object.keys(m.value.locales);if(p.length<2)return[];const b=c.currentRoute.value.path,q=c.currentRoute.value.fullPath,w=c.currentRoute.value.hash;return[{text:(S=u.value.selectLanguageText)!=null?S:"unknown language",ariaLabel:(R=(C=u.value.selectLanguageAriaLabel)!=null?C:u.value.selectLanguageText)!=null?R:"unknown language",children:p.map(U=>{var D,y,P,j,_,I;const X=(y=(D=m.value.locales)==null?void 0:D[U])!=null?y:{},x=(j=(P=u.value.locales)==null?void 0:P[U])!=null?j:{},g=`${X.lang}`,Y=(_=x.selectLanguageName)!=null?_:g;let W;if(g===m.value.lang)W=q;else{const N=b.replace(d.value,U);c.getRoutes().some(G=>G.path===N)?W=`${N}${w}`:W=(I=x.home)!=null?I:U}return{text:Y,link:W}})}]})},r=()=>{const c=Je(),d=J(()=>c.value.repo),m=J(()=>d.value?Ui(d.value):null),u=J(()=>d.value&&!Gr(d.value)?`https://github.com/${d.value}`:d.value),p=J(()=>u.value?c.value.repoLabel?c.value.repoLabel:m.value===null?"Source":m.value:null);return J(()=>!u.value||!p.value?[]:[{text:p.value,link:u.value}])},a=c=>Ee(c)?Oo(c):c.children?{...c,children:c.children.map(a)}:c,t=(()=>{const c=Je();return J(()=>(c.value.navbar||[]).map(a))})(),s=n(),i=r(),l=J(()=>[...t.value,...s.value,...i.value]);return(c,d)=>M(l).length?(V(),ae("nav",Vp,[(V(!0),ae(Ae,null,Nn(M(l),m=>(V(),ae("div",{key:m.text,class:"navbar-item"},[m.children?(V(),ze(Bp,{key:0,item:m},null,8,["item"])):(V(),ze(wn,{key:1,item:m},null,8,["item"]))]))),128))])):Re("v-if",!0)}}),Hi=Le(Jp,[["__file","NavbarItems.vue"]]),Gp=["title"],Kp={class:"icon",focusable:"false",viewBox:"0 0 32 32"},$p=Wc('<path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path>',9),Yp=[$p],Qp={class:"icon",focusable:"false",viewBox:"0 0 32 32"},Xp=ye("path",{d:"M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z",fill:"currentColor"},null,-1),Zp=[Xp],eh=ge({__name:"ToggleColorModeButton",setup(e){const n=Je(),r=zo(),a=()=>{r.value=!r.value};return(o,t)=>(V(),ae("button",{class:"toggle-color-mode-button",title:M(n).toggleColorMode,onClick:a},[da((V(),ae("svg",Kp,Yp,512)),[[ga,!M(r)]]),da((V(),ae("svg",Qp,Zp,512)),[[ga,M(r)]])],8,Gp))}}),nh=Le(eh,[["__file","ToggleColorModeButton.vue"]]),rh=["title"],ah=ye("div",{class:"icon","aria-hidden":"true"},[ye("span"),ye("span"),ye("span")],-1),oh=[ah],th=ge({__name:"ToggleSidebarButton",emits:["toggle"],setup(e){const n=Je();return(r,a)=>(V(),ae("div",{class:"toggle-sidebar-button",title:M(n).toggleSidebar,"aria-expanded":"false",role:"button",tabindex:"0",onClick:a[0]||(a[0]=o=>r.$emit("toggle"))},oh,8,rh))}}),sh=Le(th,[["__file","ToggleSidebarButton.vue"]]),ih=ge({__name:"Navbar",emits:["toggle-sidebar"],setup(e){const n=Je(),r=qe(null),a=qe(null),o=qe(0),t=J(()=>o.value?{maxWidth:o.value+"px"}:{});Ke(()=>{const l=s(r.value,"paddingLeft")+s(r.value,"paddingRight"),c=()=>{var d;window.innerWidth<=719?o.value=0:o.value=r.value.offsetWidth-l-(((d=a.value)==null?void 0:d.offsetWidth)||0)};c(),window.addEventListener("resize",c,!1),window.addEventListener("orientationchange",c,!1)});function s(i,l){var m,u,p;const c=(p=(u=(m=i==null?void 0:i.ownerDocument)==null?void 0:m.defaultView)==null?void 0:u.getComputedStyle(i,null))==null?void 0:p[l],d=Number.parseInt(c,10);return Number.isNaN(d)?0:d}return(i,l)=>{const c=qn("NavbarSearch");return V(),ae("header",{ref_key:"navbar",ref:r,class:"navbar"},[se(sh,{onToggle:l[0]||(l[0]=d=>i.$emit("toggle-sidebar"))}),ye("span",{ref_key:"navbarBrand",ref:a},[se(xp)],512),ye("div",{class:"navbar-items-wrapper",style:Br(M(t))},[xe(i.$slots,"before"),se(Hi,{class:"can-hide"}),xe(i.$slots,"after"),M(n).colorModeSwitch?(V(),ze(nh,{key:0})):Re("v-if",!0),se(c)],4)],512)}}}),lh=Le(ih,[["__file","Navbar.vue"]]),ch={class:"page-meta"},dh={key:0,class:"meta-item edit-link"},uh={key:1,class:"meta-item last-updated"},mh={class:"meta-item-label"},ph={class:"meta-item-info"},hh={key:2,class:"meta-item contributors"},gh={class:"meta-item-label"},fh={class:"meta-item-info"},vh=["title"],bh=Fn(", "),yh=ge({__name:"PageMeta",setup(e){const n=()=>{const l=Je(),c=On(),d=Pn();return J(()=>{var S,C,R;if(!((C=(S=d.value.editLink)!=null?S:l.value.editLink)!=null?C:!0))return null;const{repo:u,docsRepo:p=u,docsBranch:b="main",docsDir:q="",editLinkText:w}=l.value;if(!p)return null;const f=Wp({docsRepo:p,docsBranch:b,docsDir:q,filePathRelative:c.value.filePathRelative,editLinkPattern:(R=d.value.editLinkPattern)!=null?R:l.value.editLinkPattern});return f?{text:w!=null?w:"Edit this page",link:f}:null})},r=()=>{const l=Je(),c=On(),d=Pn();return J(()=>{var p,b,q,w;return!((b=(p=d.value.lastUpdated)!=null?p:l.value.lastUpdated)!=null?b:!0)||!((q=c.value.git)!=null&&q.updatedTime)?null:new Date((w=c.value.git)==null?void 0:w.updatedTime).toLocaleString()})},a=()=>{const l=Je(),c=On(),d=Pn();return J(()=>{var u,p,b,q;return((p=(u=d.value.contributors)!=null?u:l.value.contributors)!=null?p:!0)&&(q=(b=c.value.git)==null?void 0:b.contributors)!=null?q:null})},o=Je(),t=n(),s=r(),i=a();return(l,c)=>{const d=qn("ClientOnly");return V(),ae("footer",ch,[M(t)?(V(),ae("div",dh,[se(wn,{class:"meta-item-label",item:M(t)},null,8,["item"])])):Re("v-if",!0),M(s)?(V(),ae("div",uh,[ye("span",mh,Me(M(o).lastUpdatedText)+": ",1),se(d,null,{default:Fe(()=>[ye("span",ph,Me(M(s)),1)]),_:1})])):Re("v-if",!0),M(i)&&M(i).length?(V(),ae("div",hh,[ye("span",gh,Me(M(o).contributorsText)+": ",1),ye("span",fh,[(V(!0),ae(Ae,null,Nn(M(i),(m,u)=>(V(),ae(Ae,{key:u},[ye("span",{class:"contributor",title:`email: ${m.email}`},Me(m.name),9,vh),u!==M(i).length-1?(V(),ae(Ae,{key:0},[bh],64)):Re("v-if",!0)],64))),128))])])):Re("v-if",!0)])}}}),Sh=Le(yh,[["__file","PageMeta.vue"]]),wh={key:0,class:"page-nav"},Ph={class:"inner"},Eh={key:0,class:"prev"},qh={key:1,class:"next"},Ch=ge({__name:"PageNav",setup(e){const n=l=>l===!1?null:Ee(l)?Oo(l):To(l)?l:!1,r=(l,c,d)=>{const m=l.findIndex(u=>u.link===c);if(m!==-1){const u=l[m+d];return u!=null&&u.link?u:null}for(const u of l)if(u.children){const p=r(u.children,c,d);if(p)return p}return null},a=Pn(),o=Mo(),t=jn(),s=J(()=>{const l=n(a.value.prev);return l!==!1?l:r(o.value,t.path,-1)}),i=J(()=>{const l=n(a.value.next);return l!==!1?l:r(o.value,t.path,1)});return(l,c)=>M(s)||M(i)?(V(),ae("nav",wh,[ye("p",Ph,[M(s)?(V(),ae("span",Eh,[se(wn,{item:M(s)},null,8,["item"])])):Re("v-if",!0),M(i)?(V(),ae("span",qh,[se(wn,{item:M(i)},null,8,["item"])])):Re("v-if",!0)])])):Re("v-if",!0)}}),kh=Le(Ch,[["__file","PageNav.vue"]]),jh={class:"page"},xh={class:"theme-default-content"},Ah=ge({__name:"Page",setup(e){return(n,r)=>{const a=qn("Content");return V(),ae("main",jh,[xe(n.$slots,"top"),ye("div",xh,[xe(n.$slots,"content-top"),se(a),xe(n.$slots,"content-bottom")]),se(Sh),se(kh),xe(n.$slots,"bottom")])}}}),Ih=Le(Ah,[["__file","Page.vue"]]),_h=["onKeydown"],Th={class:"sidebar-item-children"},Lh=ge({__name:"SidebarItem",props:{item:{type:Object,required:!0},depth:{type:Number,required:!1,default:0}},setup(e){const n=e,{item:r,depth:a}=qa(n),o=jn(),t=ar(),s=J(()=>Fi(r.value,o)),i=J(()=>({"sidebar-item":!0,"sidebar-heading":a.value===0,active:s.value,collapsible:r.value.collapsible})),l=J(()=>r.value.collapsible?s.value:!0),[c,d]=Sm(l.value),m=p=>{r.value.collapsible&&(p.preventDefault(),d())},u=t.afterEach(p=>{Hr(()=>{c.value=l.value})});return Vr(()=>{u()}),(p,b)=>{var w;const q=qn("SidebarItem",!0);return V(),ae("li",null,[M(r).link?(V(),ze(wn,{key:0,class:Xe(M(i)),item:M(r)},null,8,["class","item"])):(V(),ae("p",{key:1,tabindex:"0",class:Xe(M(i)),onClick:m,onKeydown:kd(m,["enter"])},[Fn(Me(M(r).text)+" ",1),M(r).collapsible?(V(),ae("span",{key:0,class:Xe(["arrow",M(c)?"down":"right"])},null,2)):Re("v-if",!0)],42,_h)),(w=M(r).children)!=null&&w.length?(V(),ze(Bi,{key:2},{default:Fe(()=>[da(ye("ul",Th,[(V(!0),ae(Ae,null,Nn(M(r).children,f=>(V(),ze(q,{key:`${M(a)}${f.text}${f.link}`,item:f,depth:M(a)+1},null,8,["item","depth"]))),128))],512),[[ga,M(c)]])]),_:1})):Re("v-if",!0)])}}}),Dh=Le(Lh,[["__file","SidebarItem.vue"]]),Rh={key:0,class:"sidebar-items"},zh=ge({__name:"SidebarItems",setup(e){const n=jn(),r=Mo();return Ke(()=>{dn(()=>n.hash,a=>{const o=document.querySelector(".sidebar");if(!o)return;const t=document.querySelector(`.sidebar a.sidebar-item[href="${n.path}${a}"]`);if(!t)return;const{top:s,height:i}=o.getBoundingClientRect(),{top:l,height:c}=t.getBoundingClientRect();l<s?t.scrollIntoView(!0):l+c>s+i&&t.scrollIntoView(!1)})}),(a,o)=>M(r).length?(V(),ae("ul",Rh,[(V(!0),ae(Ae,null,Nn(M(r),t=>(V(),ze(Dh,{key:`${t.text}${t.link}`,item:t},null,8,["item"]))),128))])):Re("v-if",!0)}}),Oh=Le(zh,[["__file","SidebarItems.vue"]]),Mh={class:"sidebar"},Nh=ge({__name:"Sidebar",setup(e){return(n,r)=>(V(),ae("aside",Mh,[se(Hi),xe(n.$slots,"top"),se(Oh),xe(n.$slots,"bottom")]))}}),Bh=Le(Nh,[["__file","Sidebar.vue"]]),Fh=ge({__name:"Layout",setup(e){const n=On(),r=Pn(),a=Je(),o=J(()=>r.value.navbar!==!1&&a.value.navbar!==!1),t=Mo(),s=qe(!1),i=w=>{s.value=typeof w=="boolean"?w:!s.value},l={x:0,y:0},c=w=>{l.x=w.changedTouches[0].clientX,l.y=w.changedTouches[0].clientY},d=w=>{const f=w.changedTouches[0].clientX-l.x,S=w.changedTouches[0].clientY-l.y;Math.abs(f)>Math.abs(S)&&Math.abs(f)>40&&(f>0&&l.x<=80?i(!0):i(!1))},m=J(()=>[{"no-navbar":!o.value,"no-sidebar":!t.value.length,"sidebar-open":s.value},r.value.pageClass]);let u;Ke(()=>{u=ar().afterEach(()=>{i(!1)})}),xa(()=>{u()});const p=Oi(),b=p.resolve,q=p.pending;return(w,f)=>(V(),ae("div",{class:Xe(["theme-container",M(m)]),onTouchstart:c,onTouchend:d},[xe(w.$slots,"navbar",{},()=>[M(o)?(V(),ze(lh,{key:0,onToggleSidebar:i},{before:Fe(()=>[xe(w.$slots,"navbar-before")]),after:Fe(()=>[xe(w.$slots,"navbar-after")]),_:3})):Re("v-if",!0)]),ye("div",{class:"sidebar-mask",onClick:f[0]||(f[0]=S=>i(!1))}),xe(w.$slots,"sidebar",{},()=>[se(Bh,null,{top:Fe(()=>[xe(w.$slots,"sidebar-top")]),bottom:Fe(()=>[xe(w.$slots,"sidebar-bottom")]),_:3})]),xe(w.$slots,"page",{},()=>[M(r).home?(V(),ze(kp,{key:0})):(V(),ze(Jr,{key:1,name:"fade-slide-y",mode:"out-in",onBeforeEnter:M(b),onBeforeLeave:M(q)},{default:Fe(()=>[(V(),ze(Ih,{key:M(n).path},{top:Fe(()=>[xe(w.$slots,"page-top")]),"content-top":Fe(()=>[xe(w.$slots,"page-content-top")]),"content-bottom":Fe(()=>[xe(w.$slots,"page-content-bottom")]),bottom:Fe(()=>[xe(w.$slots,"page-bottom")]),_:3}))]),_:3},8,["onBeforeEnter","onBeforeLeave"]))])],34))}}),Uh=Le(Fh,[["__file","Layout.vue"]]),Hh={class:"theme-container"},Wh={class:"page"},Vh={class:"theme-default-content"},Jh=ye("h1",null,"404",-1),Gh=ge({__name:"NotFound",setup(e){var i,l,c;const n=wr(),r=Je(),a=(i=r.value.notFound)!=null?i:["Not Found"],o=()=>a[Math.floor(Math.random()*a.length)],t=(l=r.value.home)!=null?l:n.value,s=(c=r.value.backToHome)!=null?c:"Back to home";return(d,m)=>{const u=qn("RouterLink");return V(),ae("div",Hh,[ye("main",Wh,[ye("div",Vh,[Jh,ye("blockquote",null,Me(o()),1),se(u,{to:M(t)},{default:Fe(()=>[Fn(Me(M(s)),1)]),_:1},8,["to"])])])])}}}),Kh=Le(Gh,[["__file","NotFound.vue"]]);const $h=kn({enhance({app:e,router:n}){e.component("Badge",im),e.component("CodeGroup",lm),e.component("CodeGroupItem",mm),e.component("AutoLinkExternalIcon",()=>{const a=e.component("ExternalLinkIcon");return a?pe(a):null}),e.component("NavbarSearch",()=>{const a=e.component("Docsearch")||e.component("SearchBox");return a?pe(a):null});const r=n.options.scrollBehavior;n.options.scrollBehavior=async(...a)=>(await Oi().wait(),r(...a))},setup(){Ym(),Zm()},layouts:{Layout:Uh,NotFound:Kh}}),Yh={enhance:({app:e})=>{e.component("CCLicense-component",Z(()=>k(()=>import("./CCLicense-component.c212f966.js"),[]))),e.component("DocumentCover-component",Z(()=>k(()=>import("./DocumentCover-component.6277d85e.js"),[]))),e.component("DownloadPDF-component",Z(()=>k(()=>import("./DownloadPDF-component.e2df2691.js"),[])))}};/*! medium-zoom 1.0.6 | MIT License | https://github.com/francoischalifour/medium-zoom */var Gn=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var a in r)Object.prototype.hasOwnProperty.call(r,a)&&(e[a]=r[a])}return e},ra=function(n){return n.tagName==="IMG"},Qh=function(n){return NodeList.prototype.isPrototypeOf(n)},oa=function(n){return n&&n.nodeType===1},ts=function(n){var r=n.currentSrc||n.src;return r.substr(-4).toLowerCase()===".svg"},ss=function(n){try{return Array.isArray(n)?n.filter(ra):Qh(n)?[].slice.call(n).filter(ra):oa(n)?[n].filter(ra):typeof n=="string"?[].slice.call(document.querySelectorAll(n)).filter(ra):[]}catch{throw new TypeError(`The provided selector is invalid.
Expects a CSS selector, a Node element, a NodeList or an array.
See: https://github.com/francoischalifour/medium-zoom`)}},Xh=function(n){var r=document.createElement("div");return r.classList.add("medium-zoom-overlay"),r.style.background=n,r},Zh=function(n){var r=n.getBoundingClientRect(),a=r.top,o=r.left,t=r.width,s=r.height,i=n.cloneNode(),l=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,c=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return i.removeAttribute("id"),i.style.position="absolute",i.style.top=a+l+"px",i.style.left=o+c+"px",i.style.width=t+"px",i.style.height=s+"px",i.style.transform="",i},sr=function(n,r){var a=Gn({bubbles:!1,cancelable:!1,detail:void 0},r);if(typeof window.CustomEvent=="function")return new CustomEvent(n,a);var o=document.createEvent("CustomEvent");return o.initCustomEvent(n,a.bubbles,a.cancelable,a.detail),o},eg=function e(n){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},a=window.Promise||function(y){function P(){}y(P,P)},o=function(y){var P=y.target;if(P===Y){b();return}C.indexOf(P)!==-1&&q({target:P})},t=function(){if(!(U||!g.original)){var y=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(X-y)>x.scrollOffset&&setTimeout(b,150)}},s=function(y){var P=y.key||y.keyCode;(P==="Escape"||P==="Esc"||P===27)&&b()},i=function(){var y=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},P=y;if(y.background&&(Y.style.background=y.background),y.container&&y.container instanceof Object&&(P.container=Gn({},x.container,y.container)),y.template){var j=oa(y.template)?y.template:document.querySelector(y.template);P.template=j}return x=Gn({},x,P),C.forEach(function(_){_.dispatchEvent(sr("medium-zoom:update",{detail:{zoom:W}}))}),W},l=function(){var y=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return e(Gn({},x,y))},c=function(){for(var y=arguments.length,P=Array(y),j=0;j<y;j++)P[j]=arguments[j];var _=P.reduce(function(I,N){return[].concat(I,ss(N))},[]);return _.filter(function(I){return C.indexOf(I)===-1}).forEach(function(I){C.push(I),I.classList.add("medium-zoom-image")}),R.forEach(function(I){var N=I.type,G=I.listener,ce=I.options;_.forEach(function(ue){ue.addEventListener(N,G,ce)})}),W},d=function(){for(var y=arguments.length,P=Array(y),j=0;j<y;j++)P[j]=arguments[j];g.zoomed&&b();var _=P.length>0?P.reduce(function(I,N){return[].concat(I,ss(N))},[]):C;return _.forEach(function(I){I.classList.remove("medium-zoom-image"),I.dispatchEvent(sr("medium-zoom:detach",{detail:{zoom:W}}))}),C=C.filter(function(I){return _.indexOf(I)===-1}),W},m=function(y,P){var j=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return C.forEach(function(_){_.addEventListener("medium-zoom:"+y,P,j)}),R.push({type:"medium-zoom:"+y,listener:P,options:j}),W},u=function(y,P){var j=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return C.forEach(function(_){_.removeEventListener("medium-zoom:"+y,P,j)}),R=R.filter(function(_){return!(_.type==="medium-zoom:"+y&&_.listener.toString()===P.toString())}),W},p=function(){var y=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},P=y.target,j=function(){var I={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},N=void 0,G=void 0;if(x.container)if(x.container instanceof Object)I=Gn({},I,x.container),N=I.width-I.left-I.right-x.margin*2,G=I.height-I.top-I.bottom-x.margin*2;else{var ce=oa(x.container)?x.container:document.querySelector(x.container),ue=ce.getBoundingClientRect(),we=ue.width,De=ue.height,Te=ue.left,$e=ue.top;I=Gn({},I,{width:we,height:De,left:Te,top:$e})}N=N||I.width-x.margin*2,G=G||I.height-x.margin*2;var A=g.zoomedHd||g.original,Q=ts(A)?N:A.naturalWidth||N,z=ts(A)?G:A.naturalHeight||G,K=A.getBoundingClientRect(),me=K.top,fe=K.left,de=K.width,te=K.height,h=Math.min(Q,N)/de,v=Math.min(z,G)/te,E=Math.min(h,v),L=(-fe+(N-de)/2+x.margin+I.left)/E,T=(-me+(G-te)/2+x.margin+I.top)/E,B="scale("+E+") translate3d("+L+"px, "+T+"px, 0)";g.zoomed.style.transform=B,g.zoomedHd&&(g.zoomedHd.style.transform=B)};return new a(function(_){if(P&&C.indexOf(P)===-1){_(W);return}var I=function we(){U=!1,g.zoomed.removeEventListener("transitionend",we),g.original.dispatchEvent(sr("medium-zoom:opened",{detail:{zoom:W}})),_(W)};if(g.zoomed){_(W);return}if(P)g.original=P;else if(C.length>0){var N=C;g.original=N[0]}else{_(W);return}if(g.original.dispatchEvent(sr("medium-zoom:open",{detail:{zoom:W}})),X=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,U=!0,g.zoomed=Zh(g.original),document.body.appendChild(Y),x.template){var G=oa(x.template)?x.template:document.querySelector(x.template);g.template=document.createElement("div"),g.template.appendChild(G.content.cloneNode(!0)),document.body.appendChild(g.template)}if(document.body.appendChild(g.zoomed),window.requestAnimationFrame(function(){document.body.classList.add("medium-zoom--opened")}),g.original.classList.add("medium-zoom-image--hidden"),g.zoomed.classList.add("medium-zoom-image--opened"),g.zoomed.addEventListener("click",b),g.zoomed.addEventListener("transitionend",I),g.original.getAttribute("data-zoom-src")){g.zoomedHd=g.zoomed.cloneNode(),g.zoomedHd.removeAttribute("srcset"),g.zoomedHd.removeAttribute("sizes"),g.zoomedHd.src=g.zoomed.getAttribute("data-zoom-src"),g.zoomedHd.onerror=function(){clearInterval(ce),console.warn("Unable to reach the zoom image target "+g.zoomedHd.src),g.zoomedHd=null,j()};var ce=setInterval(function(){g.zoomedHd.complete&&(clearInterval(ce),g.zoomedHd.classList.add("medium-zoom-image--opened"),g.zoomedHd.addEventListener("click",b),document.body.appendChild(g.zoomedHd),j())},10)}else if(g.original.hasAttribute("srcset")){g.zoomedHd=g.zoomed.cloneNode(),g.zoomedHd.removeAttribute("sizes"),g.zoomedHd.removeAttribute("loading");var ue=g.zoomedHd.addEventListener("load",function(){g.zoomedHd.removeEventListener("load",ue),g.zoomedHd.classList.add("medium-zoom-image--opened"),g.zoomedHd.addEventListener("click",b),document.body.appendChild(g.zoomedHd),j()})}else j()})},b=function(){return new a(function(y){if(U||!g.original){y(W);return}var P=function j(){g.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(g.zoomed),g.zoomedHd&&document.body.removeChild(g.zoomedHd),document.body.removeChild(Y),g.zoomed.classList.remove("medium-zoom-image--opened"),g.template&&document.body.removeChild(g.template),U=!1,g.zoomed.removeEventListener("transitionend",j),g.original.dispatchEvent(sr("medium-zoom:closed",{detail:{zoom:W}})),g.original=null,g.zoomed=null,g.zoomedHd=null,g.template=null,y(W)};U=!0,document.body.classList.remove("medium-zoom--opened"),g.zoomed.style.transform="",g.zoomedHd&&(g.zoomedHd.style.transform=""),g.template&&(g.template.style.transition="opacity 150ms",g.template.style.opacity=0),g.original.dispatchEvent(sr("medium-zoom:close",{detail:{zoom:W}})),g.zoomed.addEventListener("transitionend",P)})},q=function(){var y=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},P=y.target;return g.original?b():p({target:P})},w=function(){return x},f=function(){return C},S=function(){return g.original},C=[],R=[],U=!1,X=0,x=r,g={original:null,zoomed:null,zoomedHd:null,template:null};Object.prototype.toString.call(n)==="[object Object]"?x=n:(n||typeof n=="string")&&c(n),x=Gn({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},x);var Y=Xh(x.background);document.addEventListener("click",o),document.addEventListener("keyup",s),document.addEventListener("scroll",t),window.addEventListener("resize",b);var W={open:p,close:b,toggle:q,update:i,clone:l,attach:c,detach:d,on:m,off:u,getOptions:w,getImages:f,getZoomedImage:S};return W};function ng(e,n){n===void 0&&(n={});var r=n.insertAt;if(!(!e||typeof document>"u")){var a=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css",r==="top"&&a.firstChild?a.insertBefore(o,a.firstChild):a.appendChild(o),o.styleSheet?o.styleSheet.cssText=e:o.appendChild(document.createTextNode(e))}}var rg=".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}";ng(rg);const ag=eg,og=Symbol("mediumZoom");const tg=":not(a) > img",sg={},ig=500,lg=kn({enhance({app:e,router:n}){const r=ag(sg);r.refresh=(a=tg)=>{r.detach(),r.attach(a)},e.provide(og,r),n.afterEach(()=>{setTimeout(()=>r.refresh(),ig)})}}),cg=(e,n)=>n.some(r=>{if(Ee(r))return r===e.key;const{key:a,ctrl:o=!1,shift:t=!1,alt:s=!1}=r;return a===e.key&&o===e.ctrlKey&&t===e.shiftKey&&s===e.altKey}),dg=/[^\x00-\x7F]/,ug=e=>e.split(/\s+/g).map(n=>n.trim()).filter(n=>!!n),is=e=>e.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&"),ls=(e,n)=>{const r=n.join(" "),a=ug(e);if(dg.test(e))return a.some(s=>r.toLowerCase().indexOf(s)>-1);const o=e.endsWith(" ");return new RegExp(a.map((s,i)=>a.length===i+1&&!o?`(?=.*\\b${is(s)})`:`(?=.*\\b${is(s)}\\b)`).join("")+".+","gi").test(r)},mg=({input:e,hotKeys:n})=>{if(n.value.length===0)return;const r=a=>{!e.value||cg(a,n.value)&&!e.value.contains(a.target)&&(a.preventDefault(),e.value.focus())};Ke(()=>{document.addEventListener("keydown",r)}),Vr(()=>{document.removeEventListener("keydown",r)})},pg=[{title:"",headers:[],path:"/",pathLocale:"/",extraFields:[`---\r
home: true\r
title: \r
heroImage: /images/quote.jpg\r
tagline: \r
actions:\r
- text: PSP (English)    \u2192\r
  link: /en/\r
  type: secondary\r
- text: PSP (Castellano) \u2192\r
  link: /es/\r
  type: secondary \r
features:\r
- title: CFGS DAM\r
  details: M\xF3dulo de 2\xBA curso\r
- title: Profesor\r
  details: Vicente Mart\xEDnez Mart\xEDnez\r
- title: Centro\r
  details: IES Doctor Balmis (Alicante)\r
footer: \xA9 2022/2023\r
---\r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Except where otherwise noted, content on this site (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources">PSP class notes</a>) by <span property="cc:attributionName">Vicente Mart\xEDnez</span> is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>    \r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Excepto donde se indique lo contrario, el contenido de este sitio (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources/es/">Apuntes de PSP</a>) creado por <span property="cc:attributionName">Vicente Mart\xEDnez</span> est\xE1 bajo una licencia  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank" rel="license noopener noreferrer" style="display:inline-block;"> CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>\r
`]},{title:"PSP",headers:[{level:2,title:"Acerca de",slug:"acerca-de",link:"#acerca-de",children:[]},{level:2,title:"Segundo apartado",slug:"segundo-apartado",link:"#segundo-apartado",children:[]},{level:2,title:"Segundo apartado",slug:"segundo-apartado-1",link:"#segundo-apartado-1",children:[]}],path:"/test_page.html",pathLocale:"/",extraFields:[`---\r
title: PSP\r
---\r
\r
<div class="pagebreak"></div>\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="PSP" />\r
\r
# PSP\r
\r
[[toc]]\r
\r
## Acerca de\r
\r
::: info\r
["Google"](http://www.google.es)\r
:::\r
\r
::: tip Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: warning Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: danger Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: question Chech your skills\r
\xBFQu\xE9 pasar\xE1 ahora?\r
:::\r
<div class="pagebreak"></div>\r
\r
## Segundo apartado\r
\r
\`\`\`java\r
public static void main() {\r
    return;\r
}\r
\`\`\`\r
\r
::: info\r
["Google"](http://www.google.es)\r
:::\r
\r
::: tip Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: warning Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: danger Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: question Chech your skills\r
\xBFQu\xE9 pasar\xE1 ahora?\r
:::\r
<div class="pagebreak"></div>\r
\r
## Segundo apartado\r
\r
\`\`\`java\r
public static void main() {\r
    return;\r
}\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
\r
<!--\r
## Diagrama de flujo\r
![diagrama de sequencia|, 20%](/media/puml_sequence_test.png)\r
\r
\`\`\`puml {align="center", style="zoom:1"}\r
@startuml\r
skinparam handwritten true\r
title Protocolo validaci\xF3n user/passwd\r
header Prueba\r
footer Prueba\r
hide footbox\r
skinparam sequence {\r
ParticipantBorderColor DeepSkyBlue\r
ParticipantBackgroundColor DodgerBlue\r
} \r
note left of Cliente: El programa cliente lee por teclado\\nun usuario y una contrase\xF1a \r
Cliente->Servidor: Usuario\r
Cliente->Servidor: Password\r
note right of Servidor: El programa servidor comprueba\\n- Si el usuario es "vicente"\\n     contesta "USEROK" \\nsino \\n    contesta "USERERROR"\r
note right of Servidor: El programa servidor comprueba\\n- Si el password es "psp"\\n     contesta "PASSOK" \\nsino \\n    contesta "PASSERROR"\r
Servidor->Cliente: USEROK \xF3 USERERROR\r
Servidor->Cliente: PASSOK \xF3 PASSERROR\r
note left of Cliente: El programa mostrar\xE1 un mensaje\\nen base a la informaci\xF3n recibida\\nIndicando si el usuario y la contrase\xF1a\\nenviadas han diso correctas o no\r
@enduml\r
\`\`\`\r
-->\r
`]},{title:"PSP - Documentation Site",headers:[],path:"/en/",pathLocale:"/en/",extraFields:[`---\r
home: true\r
title: PSP - Documentation Site\r
heroImage: /LogoPSP_en.png\r
tagline: Class notes\r
actions:\r
- text: Unit 1 (  Intro  )    \u2192\r
  link: /en/unit1/\r
  type: secondary\r
- text: Unit 2 (  Processes  )    \u2192\r
  link: /en/unit2/\r
  type: secondary\r
- text: Unit 3 (  Threads  )    \u2192\r
  link: /en/unit3/\r
  type: secondary\r
- text: Unit 4 (  Sockets  )    \u2192\r
  link: /en/unit4/\r
  type: secondary\r
features:\r
- title: \r
  details: \r
- title: \r
  details: \r
- title: \r
  details: \r
footer: \xA9 2022/2023\r
---\r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Except where otherwise noted, content on this site (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources">PSP class notes</a>) by <span property="cc:attributionName">Vicente Mart\xEDnez</span> is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>    \r
`]},{title:"PSP - P\xE1gina  de documentaci\xF3n",headers:[],path:"/es/",pathLocale:"/es/",extraFields:[`---\r
home: true\r
title: PSP - P\xE1gina  de documentaci\xF3n\r
heroImage: /LogoPSP_es.png\r
tagline: Apuntes de clase\r
actions: \r
- text: Tema 1 (  Intro  )       \u2192\r
  link: /es/unit1/\r
  type: secondary\r
- text: Tema 2 (  Procesos  )       \u2192\r
  link: /es/unit2/\r
  type: secondary\r
- text: Tema 3 (  Hilos  )       \u2192\r
  link: /es/unit3/\r
  type: secondary\r
- text: Tema 4 (  Sockets  )    \u2192\r
  link: /es/unit4/\r
  type: secondary\r
features:\r
- title: \r
  details: \r
- title: \r
  details: \r
- title: \r
  details: \r
footer: \xA9 2022 / 2023\r
---\r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Excepto donde se indique lo contrario, el contenido de este sitio (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources/es/">Apuntes de PSP</a>) creado por <span property="cc:attributionName">Vicente Mart\xEDnez</span> est\xE1 bajo una licencia  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank" rel="license noopener noreferrer" style="display:inline-block;"> CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>`]},{title:"1.2 Concurrency",headers:[{level:2,title:"1.2.1. Concurrency vs Parallelism",slug:"_1-2-1-concurrency-vs-parallelism",link:"#_1-2-1-concurrency-vs-parallelism",children:[{level:3,title:"Monoprocess",slug:"monoprocess",link:"#monoprocess",children:[]},{level:3,title:"Multitasking",slug:"multitasking",link:"#multitasking",children:[]},{level:3,title:"Parallelism",slug:"parallelism",link:"#parallelism",children:[]}]},{level:2,title:"1.2.2. Distributed systems",slug:"_1-2-2-distributed-systems",link:"#_1-2-2-distributed-systems",children:[]},{level:2,title:"1.2.3. Advantages and disadvantages",slug:"_1-2-3-advantages-and-disadvantages",link:"#_1-2-3-advantages-and-disadvantages",children:[]},{level:2,title:"1.2.4. Bernstein's conditions",slug:"_1-2-4-bernstein-s-conditions",link:"#_1-2-4-bernstein-s-conditions",children:[]}],path:"/en/unit1/concurrency.html",pathLocale:"/en/",extraFields:[`---\r
title: 1.2 Concurrency\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.2. Concurrency" />\r
\r
# 1.2. Concurrency\r
\r
[[toc]]\r
\r
According to the [Collins dictionary](https://www.collinsdictionary.com/es/diccionario/ingles/concurrency) some of the senses os the word concurrency are\r
> Ccooperation or combination. Simultaneous occurrence; coincidence.\r
\r
If we change occurrence to  \`process\`, we get a definition closer to its sense in the computer science.\r
\r
This is not the first time the word  \`process\` appears, that is because they are one of the most important concepts in programming.\r
\r
## 1.2.1. Concurrency vs Parallelism\r
\r
Now that we already know what a process is, let's look at its relationship with the hardware where they are run.\r
\r
### Monoprocess\r
\r
Maybe we want to run many processes at the same time, but if we only have one processor unit, it's absolutely impossible to have more than one task running at the same time.\r
\r
One possibility is to run the tasks in sequence. The system starts running one process and it doesn't start with the next one until the current task has completely finished. That is what happens in systems that are able to do one task at a time, something really strange nowadays.\r
\r
![Sequential execution of tasks (monoprocessor system)](./../../media/unit1/gantt_sequential.svg)\r
\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Sequential execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1       :done, t1, 0, 4s\r
Process 2     : active, t2, after t1, 5s\r
Process 3     : crit, t3, after t2, 2s\r
Process 4    : t4, after t3, 5s\r
\`\`\`\r
-->\r
\r
### Multitasking\r
\r
In a multiprogramming system there are one or more programs loaded in main memory which are ready to execute. Only one program at a time is able to get the CPU for executing its instructions while all the others are waiting their turn.\r
\r
The main idea of multiprogramming is to maximize the use of CPU time. Indeed, suppose the currently running process is performing an I/O task (which, by definition, does not need the CPU to be accomplished). Then, the OS may interrupt that process and give the control to one of the other in-main-memory programs that are ready to execute (i.e. process context switching).  It is said that running processes are multiplexed on time.\r
\r
This way, the OS gives as the illusion that many processes are running simultaneously. That is commonly called \`multitasking\`.\r
\r
![Concurrent execution of tasks (monoprocessor system)](./../../media/unit1/gantt_concurrent.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Concurrent execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 3  :crit, t3, after t2, 2s\r
Process 4  : t4, after t3, 1s\r
Process 1  :done, t5, after t4, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 4  : t7, after t6, 3s\r
Process 2  :active, t8, after t7, 2s\r
Process 4  : t9, after t8, 1s\r
\`\`\`\r
-->\r
\r
On both previous images can be observed how the total CPU time to complete all processes is the same in both models. Nonetheless, on the second model the user has the sensation that all tasks are running at the same time.\r
\r
### Parallelism\r
\r
Multiprocessing sometimes refers to executing multiple processes (programs) at the same time. This might be misleading because we have already introduced the term \u201Cmultiprogramming\u201D to describe that before.\r
In fact, multiprocessing refers to the hardware (i.e., the CPU units) rather than the software (i.e., running processes). If the underlying hardware provides more than one processor then that is multiprocessing. Several variations on the basic scheme exist, e.g., multiple cores on one die or multiple dies in one package or multiple packages in one system.\r
Anyway, a system can be both multiprogrammed by having multiple programs running at the same time and multiprocessing by having more than one physical processor.\r
\r
Nowadays most devices, from desktop to laptops through mobile devices and IoT, all of them offer multiprocess capabilities, that is, they have mor than one processing unit to really do many tasks at the same time, no simulate it.\r
This kind of execution is called \`parallelism\`.\r
\r
![Parallel execution of tasks (dual processor system)](./../../media/unit1/gantt_parallel.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Parallel execution of tasks (dual processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 1  :done, t5, after t2, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 2  :active, t8, after t6, 2s\r
section Processor 2\r
Process 3  :crit, t3, 0, 2s\r
Process 4  : t4, after t3, 1s\r
Process 4  : t7, after t4, 3s\r
Process 4  : t9, after t7, 1s\r
\`\`\`\r
-->\r
\r
The bigger the processor units number is, the less time the tasks it takes to run and the user will have a better experience. This is one of the goals of operating systems, schedule properly the tasks to minimize running times, wait times and to maximize the resources use , mainly the processors.\r
\r
::: question cores vs threads\r
have you bought a microprocessor recently? Are you up-to-date in the state of the art of hardware? Then, you'll probably know that one of the main characteristics of a microprocessor are its  **cores number** (4, 8, 16).\r
\r
Moreover, the number of cores is completed with another configuration, **treads number**, that usually is twice the number of cores.\r
\r
\xBFWhat is the relationship between processor threads and concurrency? \xBFA computer system with 8 cores / 16 threads means that it can run up to 16 process in parallel?\r
:::\r
\r
## 1.2.2. Distributed systems\r
\r
> "A collection of independent computers that appears to its users as a single. coherent system"\r
>\r
> "Andrew S. Tanembaum"\r
\r
This definition has several important aspects:\r
\r
- The first one is that a distributed system consists of components (i.e., computers) that are autonomous.\r
- A second aspect is that users (people or programs) think they are dealing with a single system. This means that one way or the other the autonomous components need to collaborate. How to establish this collaboration lies at the heart of developing distributed systems\r
\r
The most known and famous example of distributed system is \`the Internet\`. The Internet is seen by the users as a single huge documents repository, that is, a single system able to provide almost any information or service. Notwithstanding the above, we know that is made up of millions of devices located all over the world and interconnected.\r
\r
It began with the need to share resources. Actually the state-of-the-art on these systems are \`Cloud Computing\` or cloud services. It's said that a distributed system is where software components are distributed on a network and they communicate and coordinate with each other by using message passing.\r
\r
Let's concentrate on important characteristics of distributed systems:\r
\r
- Concurrency. Allows running multiple process in parallel.\r
- Global watch independency. Implies synchronization using messaging.\r
- Scalability: distributed systems should also be relatively easy to expand or scale. This characteristic is a direct consequence of having independent computers, but at the same time, hiding how these computers actually take part in the system as a whole.\r
- Fault tolerance: A distributed system will normally be continuously available, although perhaps some parts may be temporarily out of order.\r
\r
## 1.2.3. Advantages and disadvantages\r
\r
Pros of parallel processing:\r
\r
- Simultaneous running of tasks\r
- Reduce total running time\r
- Helps to solve big and complex problems\r
- Use of non local resources on the network\r
- Reduce expenses by taking advantage of shared resources. It's not necessary to invest on a supercomputer because it's possible to have the same processing power with smaller computers distributed\r
\r
Cons of parallel processing:\r
\r
- Compilers and development environments are more complex to develop.\r
- Parallel programs are more difficult to write\r
- Higher power consumption\r
- Bigger data access complexity\r
- High communication and synchronization complexity on subtasks <Badge type="danger" text="warning" vertical="middle" />\r
\r
Pros of distributed programming\r
\r
- Resource & data sharing\r
- Scale under demand\r
- Bigger flexibility to distribute processing load\r
- High availability\r
- Support for distributed applications\r
- Open philosophy and heterogeneous development\r
\r
::: question Scalability\r
Scalability means the possibility of increase the processing, storage, and capabilities of a system\r
\r
Research about differences, pros and cons of  \`vertical scaling\` vs \`horizontal scaling\`.\r
:::\r
\r
Cons of distributed programming\r
\r
- Increase system complexity\r
- New specialized software is needed\r
- Communication problems (data lost, overflows, saturation, etc.)\r
- Security problems, DDoS attacks\r
\r
Distributed and parallel programming examples\r
\r
- Weather forecast analysis and research\r
- Human genome research\r
- Biosphere modelling\r
- Seismic predictions\r
- Molecule simulation\r
\r
::: info Example of parallel and distributed programming\r
[Allien intelligence research- SETI Project](https://setiathome.berkeley.edu/sah_about.php)\r
:::\r
\r
## 1.2.4. Bernstein's conditions\r
\r
Once we know what a concurrent program is and the different hardware architectures that support them, let's try to identify which program parts can be executed concurrently.\r
\r
If we look at the following code we can determine that the first sentence must be run before the second one in order to get always the same result (for the same input data set).\r
\r
\`\`\`java\r
x = x + 1;\r
y = x + 1;\r
\`\`\`\r
\r
Though in the following code the order isn't important at all and doesn't change the final result (output data set). In this situation all of them cam be run at the same time increasing processing speed.\r
\r
\`\`\`java\r
x = 1;\r
y = 2;\r
z = 3;\r
\`\`\`\r
\r
A.J. Bernstein\u2019s Conditions are the conditions applied on two statements S1 and S2 that are to be executed in the processor. It states that three conditions that are explained below must be satisfied for two successive statements S<sub>i</sub> y S<sub>j</sub> to be executed concurrently and still produce the same result\r
\r
Bernstein conditions are rely on the subsequent two sets of variables:\r
\r
- R(S<sub>k</sub>) = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ...} read set consists of all variables that are read during exceution of k statements set\r
- W(S<sub>k</sub>) = {b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>, ...} write set consists of all variables that are written (updated) during execution of k statements set.\r
\r
To run concurrently both statement sets  S<sub>i</sub> y S<sub>j</sub> these three conditions must be matched simultaneously:\r
\r
- R(S<sub>i</sub>) \u2229 W(S<sub>j</sub>)\r
- W(S<sub>i</sub>) \u2229 R(S<sub>j</sub>)\r
- W(S<sub>i</sub>) \u2229 W(S<sub>j</sub>)\r
  \r
::: question Which of these instructions can be run concurrently?\r
\r
\`\`\`java\r
a = x + y;\r
b = z - 1;\r
c = a - b;\r
w = c + 1;\r
\`\`\`\r
\r
:::\r
\r
First of all we must get L & E sets for each sentence\r
\r
> R(S<sub>1</sub>) = {x, y}\r
> \r
> W(S<sub>1</sub>) = {a}\r
\r
> R(S<sub>2</sub>) = {z}  \r
> \r
> W(S<sub>2</sub>) = {b}\r
\r
> R(S<sub>3</sub>) = {a, b}\r
> \r
> W(S<sub>3</sub>) = {c}\r
\r
> R(S<sub>4</sub>) = {c}\r
> \r
> W(S<sub>4</sub>) = {w}\r
\r
And now let's apply the rules for each pair of sentences\r
\r
>R(S<sub>1</sub>) \u2229 W(S<sub>2</sub>) = \u2205\r
>\r
>W(S<sub>1</sub>) \u2229 R(S<sub>2</sub>) = \u2205\r
>\r
>W(S<sub>1</sub>) \u2229 W(S<sub>2</sub>) = \u2205         // They can be run simultaneously\r
\r
>R(S<sub>1</sub>) \u2229 W(S<sub>3</sub>) = \u2205\r
>\r
>W(S<sub>1</sub>) \u2229 R(S<sub>3</sub>) = {a} \u2260 \u2205\r
>\r
>W(S<sub>1</sub>) \u2229 W(S<sub>3</sub>) = \u2205         // NO parallelism without problems\r
\r
>R(S<sub>1</sub>) \u2229 W(S<sub>4</sub>) = \u2205\r
>\r
>W(S<sub>1</sub>) \u2229 R(S<sub>4</sub>) = \u2205\r
>\r
>W(S<sub>1</sub>) \u2229 W(S<sub>4</sub>) = \u2205         // They can be run simultaneously\r
\r
>R(S<sub>2</sub>) \u2229 W(S<sub>3</sub>) = \u2205\r
>\r
>W(S<sub>2</sub>) \u2229 R(S<sub>3</sub>) = {b] \u2260 \u2205\r
>\r
>W(S<sub>2</sub>) \u2229 W(S<sub>3</sub>) = \u2205         // NO parallelism without problems\r
\r
>R(S<sub>2</sub>) \u2229 W(S<sub>4</sub>) = \u2205\r
>\r
>W(S<sub>2</sub>) \u2229 R(S<sub>4</sub>) = \u2205\r
>\r
>W(S<sub>2</sub>) \u2229 W(S<sub>4</sub>) = \u2205         // They can be run simultaneously\r
\r
>R(S<sub>3</sub>) \u2229 W(S<sub>4</sub>) = \u2205\r
>\r
>W(S<sub>3</sub>) \u2229 R(S<sub>4</sub>) = {c} \u2260 \u2205\r
>\r
>W(S<sub>3</sub>) \u2229 W(S<sub>4</sub>) = \u2205         // NO parallelism without problems\r
`]},{title:"1 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit1/",pathLocale:"/en/",extraFields:[`---\r
title: 1 Introduction\r
---\r
\r
# Unit 1. Concurrent programming\r
\r
In this first unit we will learn about topic keys related to concurrent programming together with most of the vocabulary that we are going to use in this course.\r
\r
Digital technology has transformed nearly every aspect of modern life. Travel, work, shopping, entertainment, and communications are just some of the areas that have been revolutionized in recent decades. It's now rare to find an electronic device or piece of machinery that doesn't incorporate digital technology in some way.\r
\r
Digital technology means that devices can be more compact, faster, lighter, and more versatile. Huge amounts of information can be stored locally or remotely and moved around virtually instantaneously. Even the term "information" has expanded to include media such as photos, audio, and video, and no longer refers to just words and numbers.\r
\r
As programmers we should be capable of getting the maximum from software and hardware in our applications.\r
\r
There are a lot of tasks that need higher processing power to consume a huge amount of data. Two examples of this are \`Big Data\` and \`AI\` applications. These computing fields are rising in importance and require all the power the concurrent programming and the underlying hardware can offer.\r
\r
::: details What dou you think concurrency is?\r
We are gonna discuss it at class.\r
We will define the concept bit by bit throughout this course\r
:::\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To differentiate process and program\r
- To understand what concurrency is\r
- To know about relationship and differences between the two basic execution units: processes and threads.\r
- To know the basics about concurrent programming\r
- To know how concurrency performs on OS and hardware.\r
`]},{title:"1.3 Processes in the OS",headers:[{level:2,title:"1.3.1. The OS kernel",slug:"_1-3-1-the-os-kernel",link:"#_1-3-1-the-os-kernel",children:[]},{level:2,title:"1.3.2. Process conntrol in GNU/Linux",slug:"_1-3-2-process-conntrol-in-gnu-linux",link:"#_1-3-2-process-conntrol-in-gnu-linux",children:[{level:3,title:"Command to get the process PiD",slug:"command-to-get-the-process-pid",link:"#command-to-get-the-process-pid",children:[]},{level:3,title:"Commands to view active processes in GNU/Linux",slug:"commands-to-view-active-processes-in-gnu-linux",link:"#commands-to-view-active-processes-in-gnu-linux",children:[]},{level:3,title:"Process control",slug:"process-control",link:"#process-control",children:[]}]},{level:2,title:"1.3.3. Process states",slug:"_1-3-3-process-states",link:"#_1-3-3-process-states",children:[]},{level:2,title:"1.3.4 Process scheduler",slug:"_1-3-4-process-scheduler",link:"#_1-3-4-process-scheduler",children:[]},{level:2,title:"1.3.5. Process scheduling algorithms",slug:"_1-3-5-process-scheduling-algorithms",link:"#_1-3-5-process-scheduling-algorithms",children:[{level:3,title:"FCFS - First Come First Served",slug:"fcfs-first-come-first-served",link:"#fcfs-first-come-first-served",children:[]},{level:3,title:"SJF - Shortest Job First",slug:"sjf-shortest-job-first",link:"#sjf-shortest-job-first",children:[]},{level:3,title:"Priority scheduling",slug:"priority-scheduling",link:"#priority-scheduling",children:[]},{level:3,title:"Round Robin",slug:"round-robin",link:"#round-robin",children:[]},{level:3,title:"Scheduler with I/O operations or locks",slug:"scheduler-with-i-o-operations-or-locks",link:"#scheduler-with-i-o-operations-or-locks",children:[]}]}],path:"/en/unit1/operatingsystem.html",pathLocale:"/en/",extraFields:[`---\r
title: 1.3 Processes in the OS\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.3. Processes in the OS" />\r
\r
# 1.3. Processes in the Operating System\r
\r
[[toc]]\r
\r
## 1.3.1. The OS kernel\r
\r
The \`kernel or OS core\` is the responsible of the basic functions on the system and the resources management. It's accessed by systems calls. it is the smaller part of the OS and usually it's coded in low-level languages to improve its performance. The rest of the OS is call system apps.\r
\r
Essentially, a process is what a program becomes when it is loaded into memory from a secondary storage medium like a hard disk drive or an removable drive. Each process has its own address space, which typically contains both program instructions and data. Despite the fact that an individual processor or processor core can only execute one program instruction at a time, a large number of processes can be executed over a relatively short period of time by briefly assigning each process to the processor in turn.\r
\r
When a user starts an application program, the operating system's \`high-level scheduler (HLS)\` loads all or part of the program code from secondary storage into memory. It then creates a data structure in memory called a process control block (PCB) that will be used to hold information about the process, such as its current status and where in memory it is located.\r
\r
The operating system also maintains a separate process table in memory that lists all the user processes currently loaded. When a new process is created, it is given a unique process identification number (PID) and a new record is created for it in the process table which includes the address of the process control block in memory.\r
\r
As well as allocating memory space, loading the process, and creating the necessary data structures, the operating system must also allocate resources such as access to I/O devices and disk space if the process requires them. Information about the resources allocated to a process is also held within the process control block. The operating system's \`low-level scheduler (LLS)\` is **responsible for allocating CPU time to each process in turn**.\r
\r
When a process makes the transition from one state to another, the operating system updates the information in its PCB. When the process is terminated, the operating system removes it from the process table and frees the memory and any other resources allocated to the process so that they become available to other processes. The diagram below illustrates the relationship between the process table and the various process control blocks.\r
\r
These \`context changes\` are time and resource consuming. We will talk about this later, with a smaller running unit \`threads\`, that solve this problem partially.\r
\r
![Process Control Block](./../../media/unit1/process_control_blocks.gif)\r
\r
The process control block (PCB) maintains information that the operating system needs in order to manage a process. PCBs typically include information such as the process ID, the current state of the process (e.g. running, ready, blocked, etc.), the number of the next program instruction to be executed, and the starting address of the process in memory. The PCB also stores the contents of various processor registers (the execution context), which are saved when a process leaves the running state and which are restored to the processor when the process returns to the running state.\r
\r
## 1.3.2. Process conntrol in GNU/Linux\r
\r
Because Linux is a multi-user system, meaning different users can be running various programs on the system, each running instance of a program must be identified uniquely by the kernel.\r
\r
And a program is identified by its process ID (PID) as well as it\u2019s parent processes ID (PPID), therefore processes can further be categorized into:\r
\r
- Parent processes \u2013 these are processes that create other processes during run-time.\r
- Child processes \u2013 these processes are created by other processes during run-time.\r
\r
Init process is the mother (parent) of all processes on the system, it\u2019s the first program that is executed when the Linux system boots up; it manages all other processes on the system. It is started by the kernel itself, so in principle it does not have a parent process.\r
\r
::: info proceso init\r
The init process always has process ID of 1.\r
\r
It functions as an adoptive parent for all orphaned processes.\r
:::\r
\r
### Command to get the process PiD\r
\r
In Linux every process on a system has a PID (Process Identification Number) which can be used to kill the process. The command \`pidof cmdname\` shows all processes related to that command. Remember that every time we start a command or application a nes process is created.\r
\r
Shell variables \`$$\` and \`$PPID\` show the actual process PID and its PPID respectively.\r
\r
\`\`\`bash\r
# pidof systemd\r
1\r
# pidof top\r
2060\r
# pidof httpd\r
2103 2102 2101 2100 2099 1076\r
# Process pid\r
echo $$\r
2109\r
# Process parent pid\r
echo $PPID\r
2106\r
\`\`\`\r
\r
### Commands to view active processes in GNU/Linux\r
\r
There are several Linux tools for viewing/listing running processes on the system, the two traditional and well known are \`ps\` and \`top\` commands:\r
\r
The \`ps\` command displays information about a selection of the active processes on the system, along with some process information,  as shown below:\r
\r
This command offers many options to show more or less information about the processes, as well as our user's processes ot others' processes, including statistics about resource usage, etc.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
UID        PID  PPID  C    SZ   RSS PSR STIME TTY          TIME CMD\r
root         1     0  0   223   576   5 11:00 ?        00:00:00 /init\r
root         7     1  0   223    80   3 11:00 ?        00:00:00 /init\r
root         8     7  0   223    80   1 11:00 ?        00:00:00 /init\r
vicente      9     8  0  2508  5032   4 11:00 pts/0    00:00:00 -bash\r
vicente     70     9  0  2650  3224   5 11:06 pts/0    00:00:00 ps -AF\r
vicente@Desktop-Vicente:~$ ps -auxf\r
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\r
root         1  0.0  0.0    892   576 ?        Sl   11:00   0:00 /init\r
root         7  0.0  0.0    892    80 ?        Ss   11:00   0:00 /init\r
root         8  0.0  0.0    892    80 ?        S    11:00   0:00  \\_ /init\r
vicente      9  0.0  0.0  10032  5032 pts/0    Ss   11:00   0:00      \\_ -bash\r
vicente     72  0.0  0.0  10832  3408 pts/0    R+   11:09   0:00          \\_ ps -auxf\r
\`\`\`\r
\r
::: info Useful \u2018ps\u2019 examples for Linux process monitoring\r
[https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/](https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/)\r
:::\r
\r
The \`top\`command  is a powerful tool that offers you a dynamic real-time view of a running system as shown in the screenshot below:\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
top - 11:14:52 up 14 min,  0 users,  load average: 0.00, 0.00, 0.00\r
Tasks:   5 total,   1 running,   4 sleeping,   0 stopped,   0 zombie\r
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\r
MiB Mem :  12677.3 total,  12556.4 free,     70.6 used,     50.3 buff/cache\r
MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.  12433.8 avail Mem\r
\r
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\r
    1 root      20   0     892    576    516 S   0.0   0.0   0:00.04 init\r
    7 root      20   0     892     80     20 S   0.0   0.0   0:00.00 init\r
    8 root      20   0     892     80     20 S   0.0   0.0   0:00.01 init\r
    9 vicente   20   0   10032   5032   3324 S   0.0   0.0   0:00.11 bash\r
   73 vicente   20   0   10856   3664   3148 R   0.0   0.0   0:00.00 top\r
\`\`\`\r
\r
::: info \u2018top\u2019 examples in Linux\r
[https://www.tecmint.com/12-top-command-examples-in-linux/](https://www.tecmint.com/12-top-command-examples-in-linux/)\r
:::\r
\r
### Process control\r
\r
Process management is one of the important aspects of System Administration in Linux, and it includes killing of processes using the \`kill\` command.\r
\r
When killing processes, the kill command is used to send a named signal to a named process or groups of processes. The default signal is the TERM signal.\r
\r
A waiting process that can be interrupted by signals is called \`Interruptible\`, while a waiting process that is directly waiting on hardware conditions and cannot be interrupted under any conditions is called \`uninterruptible\`.\r
\r
\`\`\`bash\r
# Get Firefox PID after it freezes\r
$ pidof firefox\r
2687\r
# Send the SIGKILL (9) signal to end the process immediately\r
$ kill 9 2687\r
\`\`\`\r
\r
::: info How to control Linux process Using kill, pkill and kilall\r
[https://www.tecmint.com/how-to-kill-a-process-in-linux/](https://www.tecmint.com/how-to-kill-a-process-in-linux/)\r
:::\r
\r
The kernel stores a great deal of information about processes including process priority which is simply the scheduling priority attached to a process. Processes with a higher priority will be executed before those with a lower priority, while processes with the same priority are scheduled one after the next, repeatedly.\r
\r
A user with *root* privileges can modify processes priority. This value can be seen in the NI (nice) columns of \`top\`output. This value also influences the PRI (priority) column, meaning the priority the OS gives to a process.\r
\r
The priority is a nice value (niceness) which ranges from -20 (highest priority value) to 19 (lowest priority value) and the default is 0. Using the \`nice\` command we can guarantee that in high load CPU periods some processes will make a priority use of the CPU\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ nice\r
0\r
vicente@Desktop-Vicente:~$ nice -n 10 bash\r
vicente@Desktop-Vicente:~$ nice\r
10\r
vicente@Desktop-Vicente:~$\r
\`\`\`\r
\r
::: tip Process control in Windows\r
In Windows systems most of previous actions can be performed from the task manager, though commands **tasklist** and **taskkill** can be used in console mode..\r
\r
*tasklist /svc /fi \u201Cimagename eq svchost.exe\u201D*\r
Will display you the result with Image name, PID and Service name to know which services are being run under the process svchost.exe, generic host services for services run from dynamic link libraries (DLL). There are so many processes for security reasons in order to avoid risks just in case one fails, not to hang the whole system.\r
:::\r
\r
## 1.3.3. Process states\r
\r
The simple process state diagram below shows three main states for a process. They are shown as ready (the process is ready to execute when a processor becomes available), running (the process is currently being executed by a processor) and waiting (the process is waiting for a specific event to occur before it can proceed). The lines connecting the states represent possible transitions from one state to another.\r
\r
At any instant, a process will exist in one of these three states. On a single-processor computer, only one process can be in the running state at any one time. The remaining processes will either be ready or blocked, and for each of these states there will be a queue of processes waiting for some event.\r
\r
![Process states](./../../media/unit1/process_state.png)\r
\r
- **Created**. The process is created from a program and loaded into the system\r
- **Ready**. The process is not running but it is ready to do so. The OS still hasn't assigned a processor to run. and the OS scheduler will be responsible of selecting the process to start running.\r
- **Running**. While a process is executing it has complete control of the processor, but at some point the operating system needs to regain control, such as when it must assign the processor to the next process. Execution of a particular process will be suspended if that process requests an I/O operation, if an interrupt occurs, or if the process times out.\r
- **Waiting**. The process is blocked waiting for an event to happen. For instance it can be waiting for an I/O operation to finish or a synchronization operation with another process. When the event occurs the process goes back to ready state until the OS scheduler decides to move it to running state.\r
- **Terminated**. The process ends its processing and frees its resources and all memory space (PCB). The process is the responsible to do a system call to tell the OS it has finished although the OS can interrupt it forcing its termination by using an exception (special interruption).\r
\r
States transitions:\r
\r
- **Running to waiting**: a process changes from running to waiting when it depends on an external event or operation.\r
- **De Waiting to ready**: a process changes from waiting to ready when the external event or operation it was waiting for occurs.\r
- **Ready to running**: a process changes from ready to running when the OS scheduler gives it CPU time.\r
- **Running to ready**: a process changes from running to ready when the CPU time given by the OS scheduler runs out.\r
\r
## 1.3.4 Process scheduler\r
\r
Process scheduling is a major element in process management, since the efficiency with which processes are assigned to the processor will affect the overall performance of the system. It is essentially a matter of managing queues, with the aim of minimizing delay while making the most effective use of the processor's time. The operating system carries out four types of process scheduling:\r
\r
- Process queue: contains all system processes\r
- Ready queue: contains all processes ready to be run.\r
- Devices queues: contains processes waiting for an IO operation to finish.\r
\r
![Scheduler process queues](./../../media/unit1/process_queues.gif)\r
\r
Scheduler is the one who manages processes movements into the queues.There's a short-term and a long-term scheduling:\r
\r
- The task of the \`short-term scheduler\` (sometimes referred to as the dispatcher) is to determine which process to execute next. This will occur each time the currently running process is halted. A process may cease execution because it requests an I/O operation, or because it times out, or because a hardware interrupt has occurred. The objectives of short-term scheduling are to ensure efficient utilization of the processor and to provide an acceptable response time to users.\r
  - Non-Preemptive Scheduling: a process only changes its state if it has finished or it gets locked.\r
  - Preemptive Scheduling: a process only changes its state if it has finished, it gets locked or a higher priority process is waiting.\r
  - Shared time: every amount of clock cicles (quantum), a process is moved to waiting and a new process changes from ready to running. All processes are considered to have the same priority\r
- The \`long-term scheduler\` determines which programs are admitted to the system for processing, and as such controls the degree of multiprogramming.\r
  - Before accepting a new program, the long-term scheduler must first decide whether the processor is able to cope effectively with another process. The more active processes there are, the smaller the percentage of the processor's time that can be allocated to each process.\r
\r
::: warning Context switch\r
The changeover from one process to the next is called a **context switch**. During a context switch, the processor obviously cannot perform any useful computation, and because of the frequency with which context switches occur, operating systems must minimize the context-switching time in order to reduce system overhead.\r
:::\r
\r
## 1.3.5. Process scheduling algorithms\r
\r
Scheduling algorithms are use to improve system performance and thus user experience.\r
\r
To set objective parameters and be able to compare different scenarios, a CPU scheduling algorithm tries to maximize and minimize the following:\r
\r
- **Waiting time**: Waiting time is an amount of time a process waits in the ready queue or in the waiting queue.\r
- **Turnaround Time**: Turnaround time is the amount of time to execute a specific process. It is the calculation of the total time spent waiting to get into the memory, waiting in the queue, locked for I/O operations and executing on the CPU. The period between the time of process submission to the completion time is the turnaround time.\r
- **CPU utilization**: CPU usage is the main task in which the operating system needs to make sure that CPU remains as busy as possible. It can range from 0 to 100 percent.\r
  \r
> In 1 processor systems\r
> ![1 CPU usage](./../../media/unit1/usage1cpu.gif)\r
<!--$\\frac{\\#\\ instants\\ of\\ time\\ the\\ processor\\ is\\ busy}{time\\ last\\ process\\ ends}$\\ \\ x \\ 100-->\r
>In N processor systems\r
![2 CPU usage](./../../media/unit1/usage2cpu.gif)\r
<!--$\\frac{\\sum_{n=1}^{N}\\#\\ instants\\ of\\ time\\ the\\ processor_n\\ is\\ busy}{instant\\ of\\ time\\ when\\ the\\ last\\ process\\ ends\\ *\\ N}$\\ \\ x\\  100-->\r
\r
- **Throughput**: The number of processes that finish their execution per unit time is known as \`throughput\`. So, when the CPU is busy executing the process, at that time, work is being done, and the work completed per unit time is called throughput.\r
![Throughput](./../../media/unit1/throughput.gif)\r
<!-- $\\frac{\\# \\ of\\ processes}{instant\\ of\\ time\\ when\\ the\\ last\\ process\\ ends}$-->\r
\r
| Process | Arrival | CPU time | Priority |\r
| :-----: | :-----: | :------: | :------: |\r
|   P1    |    0    |    10    |    5     |\r
|   P2    |    1    |    6     |    10    |\r
|   P3    |    2    |    3     |    7     |\r
\r
With this parameters let's compare the scheduling algorithms performance.\r
\r
### FCFS - First Come First Served\r
\r
First Come First Serve is the full form of FCFS. It is the easiest and most simple CPU scheduling algorithm. In this type of algorithm, the process which requests the CPU gets the CPU allocation first. This scheduling method can be managed with a FIFO queue.\r
\r
As the process enters the ready queue, its PCB (Process Control Block) is linked with the tail of the queue. So, when CPU becomes free, it should be assigned to the process at the beginning of the queue.\r
\r
Characteristics of FCFS method:\r
\r
- It offers non-preemptive and pre-emptive scheduling algorithm.\r
- Jobs are always executed on a first-come, first-serve basis\r
- It is easy to implement and use.\r
- However, this method is poor in performance, and the general wait time is quite high.\r
\r
![FCFS monoprocessor](./../../media/unit1/fcfs-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 2     : active,t2, after t1, 6s\r
Process 3     : crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      9       |       15        |             |\r
|   P3    |      14      |       17        |             |\r
|         |\r
|  Mean   |     7,6      |       14        |    100%     |    0,15    |\r
\r
![FCFS dual processor](./../../media/unit1/fcfs-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      5       |        8        |             |\r
|         |\r
|  Mean   |     1,6      |        6        |     95%     |    0,3     |\r
\r
### SJF - Shortest Job First\r
\r
SJF is a full form of (Shortest job first) is a scheduling algorithm in which the process with the shortest execution time should be selected for execution next. This scheduling method can be preemptive or non-preemptive. It significantly reduces the average waiting time for other processes awaiting execution.\r
\r
Characteristics of SJF Scheduling\r
\r
- It is associated with each job as a unit of time to complete.\r
- In this method, when the CPU is available, the next process or job with the shortest completion time will be executed first.\r
- It is Implemented with non-preemptive policy.\r
- This algorithm method is useful for batch-type processing, where waiting for jobs to complete is not critical.\r
- It improves job output by offering shorter jobs, which should be executed first, which mostly have a shorter turnaround time. There can be situations where longer jobs would never been run, that's called \`starvation\`.\r
\r
![SJF monoprocessor](./../../media/unit1/sjf-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title SJF (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      12      |       18        |             |\r
|   P3    |      8       |       11        |             |\r
|         |\r
|  Mean   |     7,3      |       13        |    100%     |    0,15    |\r
\r
![SJF dual processor](./../../media/unit1/sjf-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      5       |        8        |             |\r
|         |\r
|  Mean   |     1,6      |        6        |     95%     |    0,3     |\r
\r
### Priority scheduling\r
\r
Priority scheduling is a method of scheduling processes based on priority. In this method, the scheduler selects the tasks to work as per the priority.\r
\r
Priority scheduling also helps OS to involve priority assignments. The processes with higher priority should be carried out first, whereas jobs with equal priorities are carried out on a round-robin or FCFS basis. Priority can be decided based on memory requirements, time requirements, etc.\r
\r
As with SJF, with this algorithm low priority processes are in risk of starvation.\r
\r
![Prioridad monoprocessor](./../../media/unit1/prioridad-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      12      |       18        |             |\r
|   P3    |      8       |       11        |             |\r
|         |\r
|  Mean   |     6,6      |       13        |    100%     |    0,15    |\r
\r
![Prioridad dual processor](./../../media/unit1/prioridad-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      5       |        8        |             |\r
|         |\r
|  Mean   |     1,6      |        6        |     95%     |    0,3     |\r
\r
### Round Robin\r
\r
Round robin is the oldest, simplest scheduling algorithm. The name of this algorithm comes from the round-robin principle, where each person gets an equal share of something in turn (\`quantum\`). It is mostly used for scheduling algorithms in multitasking. This algorithm method helps for starvation free execution of processes.\r
\r
Characteristics of Round-Robin Scheduling\r
\r
- Round robin is a hybrid model which is clock-driven\r
- Time slice should be minimum, which is assigned for a specific task to be processed. However, it may vary for different processes.\r
- It is a real time system which responds to the event within a specific time limit.\r
\r
We can find two situations with this method:\r
\r
- The process, or its remaining time, is less than the quantum. So, when the process finishes, a new process is run.\r
- The process, or its remaining time, is greater than the quantum. So, when the quantum times out the process is moved to ready and next scheduled process is moved to running.\r
\r
![RR monoprocessor](./../../media/unit1/roundrobin-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 2s\r
Process 2     : active,t2, after t1, 2s\r
Process 3     : crit, t3, after t2, 2s\r
Process 1      :done, t4, after t3, 2s\r
Process 2     : active,t5, after t4, 2s\r
Process 3     : crit, t6, after t5, 1s\r
Process 1      :done, t7, after t6, 2s\r
Process 2     : active,t8, after t7, 2s\r
Process 1      :done, t9, after t8, 2s\r
Process 1      :done, t10, after t9, 2s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      9       |       19        |             |\r
|   P2    |      8       |       14        |             |\r
|   P3    |      6       |        9        |             |\r
|         |\r
|  Mean   |     7,6      |       14        |    100%     |    0,15    |\r
\r
![RR dual processor](./../../media/unit1/roundrobin-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1_1, 0, 2s\r
Process 3     :crit, t3_1, after t1_1, 2s\r
Process 1     :done, t1_2, after t3_1, 2s\r
Process 3     :crit, t3_2, after t1_2, 1s\r
Process 1     :done, t1_3, after t3_2, 2s\r
Process 1     :done, t1_4, after t1_3, 2s\r
Process 1     :done, t1_5, after t1_4, 2s\r
section Processor 2\r
.     :active, ., 0, 0s\r
Process 2     :active, t2_1, 1, 2s\r
Process 2     :active, t2_2, after t2_1, 2s\r
Process 2     :active, t2_3, after t2_2, 2s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      3       |       13        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      2       |        5        |             |\r
|         |\r
|  Mean   |     1,6      |       7,6       |     73%     |    0,23    |\r
\r
::: question Combined scheduling\r
As a matter of fact, not only one scheduling algorithm is used but more than one are combined to improve performance and avoid problems like starvation. We have done so, in Round-Robin we have also used FCFS.\r
\r
\xBFDo you dare to plan the previous sample using Round-Robin with priority? Keep in mind that it will work mainly with the quantum and, the priority will be used to select the next process to change from ready to running.\r
:::\r
\r
### Scheduler with I/O operations or locks\r
\r
In previous examples all processes have expend all their time in CPU, the have not made any IO operation nor any interruption, but that behavior is far away from reality. Processes sometimes have to get locked to wait for a user input, read or store information on any storage or simply wait for another process to finish an operation and send to it a data before it can go on (synchronization).\r
\r
As we have already comment, when a process leaves the running state another one can start running and make use of the CPU. Once the process finishes its lock, it can go back to ready state to keep on executing its sentences.\r
\r
The next graph has a two activities specification in which before running their last sentence block, process 1 last IO operation must have finished.\r
\r
![Procesos con E/S](./../../media/unit1/operaciones_es.svg)\r
<!--\r
\`\`\`mermaid\r
graph LR\r
\r
subgraph Process 2\r
    p2_1["run for 2"]--p2_2["E/S for 3"]--p2_3["run for 4"]--p2_5["run for 3"]\r
end\r
subgraph Process 1\r
    p1_1["run for 3"]--p1_2["E/S for 1"]--p1_3["run for 5"]--p1_4["E/S for 2"]--p1_5["run for 4"]\r
    p1_4--p2_5\r
end\r
\`\`\`\r
-->\r
\r
Let's see how this affects the scheduling, guessing both processes arrive at the same time.\r
\r
![RR dual processor](./../../media/unit1/roundrobin-3.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Task 1\r
P1 runs 2 (exits because of q expiration)      :done, t1_1, 0, 2s\r
P1 runs 1 (exits and has to wait 1 for E/S)      :done, t1_2, after t2_1, 1s\r
E/S :crit, es1_1, after t1_2, 1s\r
P1 runs 2 (exits because of q expiration)      :done, t1_3, after es1_1, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_4, after t2_2, 2s\r
P1 runs 2 (exits and has to wait 1 for E/S)      :done, t1_5, after t2_3, 1s\r
E/S :crit, es1_2, after t1_5, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_6, after es1_2, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_7, after t2_4, 2s\r
\r
section Task 2 \r
P2 runs 2 (exits and has to wait 3 for E/S) :active, t2_1, after t1_1, 2s\r
E/S :crit, es2_1, after t2_1, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_2, after t1_3, 2s\r
P2 runs 2 (exits because of q expiration)      :active, t2_3, after t1_4, 2s\r
Locked waiting :crit, es2_2, after t2_3, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_4, after t1_6, 2s\r
P2 runs 2 (ends execution)      :active, t2_5, after t1_7, 1s\r
'''\r
-->\r
`]},{title:"1.1 Processes, programs, threads",headers:[{level:2,title:"1.1.1. Processes and programs",slug:"_1-1-1-processes-and-programs",link:"#_1-1-1-processes-and-programs",children:[]},{level:2,title:"1.1.2. Concurrent programming",slug:"_1-1-2-concurrent-programming",link:"#_1-1-2-concurrent-programming",children:[{level:3,title:"What for?",slug:"what-for",link:"#what-for",children:[]},{level:3,title:"Process communication and synchronization",slug:"process-communication-and-synchronization",link:"#process-communication-and-synchronization",children:[]}]},{level:2,title:"1.1.3. Services and threads",slug:"_1-1-3-services-and-threads",link:"#_1-1-3-services-and-threads",children:[{level:3,title:"Sequential program (Von Newmann architecture)",slug:"sequential-program-von-newmann-architecture",link:"#sequential-program-von-newmann-architecture",children:[]},{level:3,title:"Concurrent program",slug:"concurrent-program",link:"#concurrent-program",children:[]},{level:3,title:"Threads vs processes",slug:"threads-vs-processes",link:"#threads-vs-processes",children:[]}]}],path:"/en/unit1/process.html",pathLocale:"/en/",extraFields:[`---\r
title: 1.1 Processes, programs, threads\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.1. Processes, programs, threads" />\r
\r
# 1.1. Processes, programs, threads\r
\r
[[toc]]\r
\r
## 1.1.1. Processes and programs\r
\r
A program and a process are related terms. A \`program\` is a group of instructions to carry out a specified task with some input data.\r
\r
::: tip Black box\r
Black-box testing is a method of software testing that examines the functionality of an application without peering into its internal structures or workings, just by setting some input data set and checking if the output data set meets the expected one.\r
:::\r
\r
While a \`process\` can be described as an instance of a program running on a computer. A program becomes a process when loaded into memory and thus is an active entity While  a program is considered to be a passive one.\r
\r
A process has a high resource requirement, it needs resources like CPU, memory address, I/O during its lifetime. It has its own control block called Process Control Block where relevant information as program counter, registers, stack, *executable code*, state, ... and all it needs to be run by the OS is stored.\r
\r
![Process in memory](./../../media/unit1/proceso_memoria.png)\r
\r
Each process is an independent entity. There exist a many-to-one relationship between process and program, which means one program can be invoked multiple times getting several processes in memory running the same copy of the program.\r
\r
## 1.1.2. Concurrent programming\r
\r
In computer science, concurrency is the ability of different parts or units of a program to be executed out-of-order or at the same time simultaneously.\r
\r
This allows for \`parallel\` execution of the concurrent units, which can significantly improve overall speed of the execution in \`multi-processor and multi-core\` machines.\r
\r
The concept of concurrent computing is frequently confused with the related but distinct concept of parallel computing, although both can be described as *multiple processes executing during the same period of time*.\r
\r
- In parallel computing, execution occurs at the same physical instant: for example, on separate processors of a multi-processor machine, with the goal of speeding up computations.\r
- This parallel computing is impossible on a \`one-core single processor\`, as only one computation can occur at any instant (during any single clock cycle). By contrast, concurrent computing consists of process lifetimes overlapping, but execution need not happen at the same instant. The goal here is to model processes in the outside world that happen concurrently using \`multitask\`.\r
\r
![Concurrency vs parallelism](./../../media/unit1/concurrencia_vs_paralelismo.jpg)\r
\r
::: tip Concurrency\r
By and large, both previously described scenarios are gonna be referred to as **concurrency**.\r
:::\r
\r
### What for?\r
\r
The Real World is Massively Complex\r
\r
- In the natural world, many complex, interrelated events are happening at the same time, yet within a temporal sequence.\r
- Compared to serial computing, parallel computing is much better suited for modeling, simulating and understanding complex, real world phenomena.\r
\r
Imagine modeling these serially: climate change, rush hour traffic, weather forecast, galaxy formation, ...\r
\r
Main Reasons for Using Parallel Programming\r
\r
- Save time and money. In theory, throwing more resources at a task will shorten its time to completion, with potential cost savings.\r
  - Parallel computers can be built from cheap, commodity components.\r
- Solve larger and more complex problems.  Many problems are so large and/or complex that it is impractical or impossible to solve them using a serial program, especially given limited computer memory.\r
  - *Grand Challenge Problems* (en.wikipedia.org/wiki/Grand_Challenge) requiring petaflops and petabytes of computing resources.\r
  - Web search engines/databases processing millions of transactions every second\r
- Take advantage of non-local resources. Using compute resources on a wide area network, or even the Internet when local compute resources are scarce or insufficient.\r
  - *SETI@home* (setiathome.berkeley.edu) has over 1.7 million users in nearly every country in the world. (May, 2018).\r
- Make better use of underlying parallel hardware. Modern computers, even laptops, are parallel in architecture with multiple processors/cores.\r
  - Parallel software is specifically intended for parallel hardware with multiple cores, threads, etc.\r
  - In most cases, serial programs run on modern computers "waste" potential computing power.\r
- Increase security. Each task can be isolated in a different process, so debug and check the security, even finishing it when it's not working properly, can be done without hanging the whole system.\r
\r
Historically, parallel computing has been considered to be "the high end of computing", and has been used to model difficult problems in many areas of science and engineering.\r
Today, commercial applications provide an equal or greater driving force in the development of faster computers. These applications require the processing of large amounts of data in sophisticated ways. For example:\r
\r
New hardware environments can be classified in terms of:\r
\r
- Microprocessor with many cores sharing system memory.\r
- Multiprocessor systems with shared memory\r
- Distributed systems and cloud services.\r
\r
### Process communication and synchronization\r
\r
The concurrent running of many processes may suppose the collaboration of some of them in order to complete a common task, while there can also be competing for system resources.\r
\r
In both cases it is compulsory to add communication and synchronization techniques for the processes.\r
\r
:::info Concurrent programming\r
Concurrent programming and PSP is just about that, the knowledge of these **communication and synchronization techniques**.\r
:::\r
\r
When thinking about the way a process can communicate with each other, three are two main options:\r
\r
- Message passing: It's commonly used when processes are running on different devices. They exchange information following a protocol previously set and agreed by the parts.\r
- Shared resources / memory: It's only available when both processes are running on the same device and allows process synchronization based on a shared resource value or state.\r
\r
We can also classify the communication by the syncrhonization the processes use during the message passing process:\r
\r
- Synchronous communication happens when messages can only be exchanged in real time. It requires that the transmitter and receiver are present in the same time and/or space. Sender is blocked until receiver gets the message. Both processes are synchronized at the reception time.\r
  - Examples of synchronous communication are phone calls or video meetings.\r
- Asynchronous communication happens when information can be exchanged independent of time. It doesn\u2019t require the recipient\u2019s immediate attention, allowing them to respond to the message at their convenience. Sender continues with it processing just after delivering the message to the receiver, not being blocked.\r
  - Examples of asynchronous communication are emails, online forums, and collaborative documents.\r
\r
## 1.1.3. Services and threads\r
\r
A program, as previously said, is a group of sentences (actions and checks) and a running workflow. The workflow line determines the execution order for the sentences, with dependency of the program structure and it's data.\r
\r
Based on the number of workflow lines a program can have, processes are classified in terms of::\r
\r
- Sequential: The have only one control workflow (monothread)\r
- Concurrent: They have multiple control workflows (multithread).\r
\r
### Sequential program (Von Newmann architecture)\r
\r
The classical von Neumann model of computation4 is a familiar model of sequential behavior. According to this, when we start learning to code we learn the classical way, following Von Neummann's conceptual model.\r
\r
Sequential programs have a single workflow line. instructions on these applications are strictly sorted as a lineal time sequence.\r
\r
The program's behavior is a function of the kind of instructions it is made of and the order they are run (set by its input data)\r
\r
In sequential programs the time every sentence takes to complete has no consequences on the final result.\r
\r
![Sequential flowchart example](./../../media/unit1/sequential_flowchart.png)\r
\r
The way to test a sequential program (\`verify\` or \`debug\`) is so easy:\r
\r
- Every sentence gives the right output.\r
- The sentences are executed in the expected order.\r
\r
That's the basis of many basic test methods, as the "white-box" model.\r
\r
### Concurrent program\r
\r
In concurrent programs there are many workflow lines. The sentences are not run following the same order as in a sequential program the would do.\r
\r
In concurrent programs sequential order between sentences is still relevant. Nevertheless, in concurrent programs the order is only partial while in sequential programs the order is strict.\r
\r
![Concurrent flowchart example](./../../media/unit1/concurrent_flowchart.png)\r
\r
In concurrent programs the *sequencing* for concurrent processes is called **synchronization**.\r
\r
The partial order implies that concurrent programs does not have to be deterministic, that is, the application results with the same input data will not always be equal.\r
\r
::: danger Indeterminism\r
Having different outputs for the same inputs does not means that a concurrent program has any bug or malfunction.\r
:::\r
\r
Look at the following pseudo code example\r
\r
\`\`\`java {16-17,25-28}\r
public class TestClass {\r
    int x;\r
\r
    public void testMethod1() {\r
        for (int i=1; i <= 5; i++) {\r
            x++;\r
        }\r
    }\r
    public void testMethod2() {\r
        for (int j=1; j <= 5; j++) {\r
            x++;\r
        }\r
    }\r
    public void sequential() {\r
        x = 0;\r
        testMethod1();\r
        testMethod2();\r
        System.out.println(x);\r
    }\r
    public void parallel() {\r
        x = 0;\r
        // cobegin-coend means that both methods are run simultaneously\r
        // These sentences doesn't exist in Java. They are used for \r
        // sample purposes\r
        cobegin\r
            testMethod1();\r
            testMethod2();\r
        coend\r
        System.out.println(x);\r
    }\r
}\r
\`\`\`\r
\r
::: question\r
\xBFWhich is the value for variable x after sequential method is run?\r
\r
\xBFWhich is the value for variable x after parallel method is run?\r
:::\r
\r
::: info Historical review\r
The nature and models of interaction between processes of a concurrent program were studied and described by  **Dijkstra** (1968), Brinch **Hansen** (1973) and **Hoare** (1974).\r
\r
The academic study of concurrent algorithms started in the 1960s and they are the foundation for multiprocess operating systems in the 70's and 80's.\r
:::\r
\r
Concurrent programs inherent indeterminism makes its analysis and validation more complex. However, to test a concurrent program (\`verify\` or \`debug\`) the same techniques as for sequential ones are needed, adding these new ones:\r
\r
- Sentences can be validated individually only if the are not engaged to shared variables.\r
- If shared variables are used there can be many interference effects for concurrent sentences and testing can also become very difficult. <Badge type="danger" text="warning" vertical="middle" />\r
- Only when sequencing between tasks is made by using explicit **synchronization** sentences, time is not relevant on the result.\r
\r
::: warning Important\r
Three previous topics described above are the basis of concurrent programming.\r
\r
:eye: To know them, to understand them and to apply them in the right way is all about what we are gonna learn all this course.\r
:::\r
\r
### Threads vs processes\r
\r
A thread is the unit of execution within a process. A thread is just one of the workflow lines a concurrent process can have. A process is a heavyweight running unit.\r
\r
 A process can have anywhere from just one thread (the main thread) to many threads. If a process has more than one thread, every thread is a lightweight running unit.\r
\r
| Processes                        | Threads                                 |\r
| :------------------------------- | :-------------------------------------- |\r
| Have more than one thread        | A thread always exists within a process |\r
| They are independent from others | They share the process resources        |\r
| The OS manages them              | The process manages them                |\r
| they can communicate on the OS  | The process manages their communication |\r
\r
![Threads vs Processes](./../../media/unit1/threads_vs_process.jpg)\r
\r
In the above image you can see the relationship in the way a thread is created and its related process.\r
\r
- The process resides in its memory address space. Threads share that memory area. In the process's address space every thread has its reserved area, but all of them can share the process's global memory and his open resources (files, sockets, etc.)..\r
- We have already described a process PCD with the process information..\r
- In a similar way, have their TCB (Thread Control Block) where the threads store their specific information (program counter, stack pointer, thread status, registers and a PCB pointer).\r
\r
::: info Services\r
A service is a process commonly started during OS boot. As it does not need user interaction services are run as **daemons** run in *background mode*.\r
\r
They are called services because once started they are waiting for a process to ask them to do a taks.  As they have to manage request from several processes they usually are multithread programs.\r
:::\r
`]},{title:"2.4 Annex I - Curl",headers:[{level:2,title:"2.4.1 Get curl",slug:"_2-4-1-get-curl",link:"#_2-4-1-get-curl",children:[]},{level:2,title:"2.4.2 Calling a GET method",slug:"_2-4-2-calling-a-get-method",link:"#_2-4-2-calling-a-get-method",children:[]},{level:2,title:"2.4.2 Endpoints and routes",slug:"_2-4-2-endpoints-and-routes",link:"#_2-4-2-endpoints-and-routes",children:[]},{level:2,title:"2.4.3 HTTP methods and headers",slug:"_2-4-3-http-methods-and-headers",link:"#_2-4-3-http-methods-and-headers",children:[]},{level:2,title:"2.4.4 Authentication",slug:"_2-4-4-authentication",link:"#_2-4-4-authentication",children:[]},{level:2,title:"2.4.5 References",slug:"_2-4-5-references",link:"#_2-4-5-references",children:[]}],path:"/en/unit2/curl_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.4 Annex I - Curl\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.4 Annex I - Curl" />\r
\r
# 2.4 Annex I - Curl\r
\r
[[toc]]\r
\r
Whether it\u2019s testing the output of a REST API on development or before deploying it to production, simply fetching a response from a website (for instance, to check it\u2019s not down), or getting response times from a site / API Curl is practically omnipresent.\r
\r
Curl is a command-line tool that allows us to do HTTP requests from shell. This is its main use.\r
\r
::: info\r
The tool was about uploading and downloading data specified with a URL. It was a client-side program (the 'c'), a URL client, and would show the data (by default). So 'c' for Client and URL: cURL.\r
\r
Most of us pronounce "curl" with an initial k sound, just like the English word curl. It rhymes with words like girl.\r
\r
But it can also be spelled as c-URL which means see-URL, that is also a good definition about what the tool does.\r
:::\r
\r
Curl supports protocols that allow "data transfers" in either or both directions. It supports protocols which have a "URI format" and are described in an RFC, as curl works primarily with URLs (URIs really) as the input key that specifies the transfer.\r
\r
Curl actually supports these protocols:\r
\r
>DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP.\r
\r
## 2.4.1 Get curl\r
\r
curl is totally free, open and available. There are numerous ways to get it and install it for most operating systems and architecture. Some operating systems include curl by default.\r
\r
You can always download the source from [CURL official site](http://curl.se) or find binary packages to download from there.\r
\r
- Linux (Ubuntu / Debian). curl is installed by default. Anyway, you can add with the APT package manager\r
  > apt install curl\r
- Windows 10 comes with the curl tool bundled with the operating system since version 1804\r
    > download the latest official curl release for Windows from [curl windows binaries](http://curl.se/windows) and install that.\r
- MacOS comes with the curl tool bundled with the operating system since many years. If you want to upgrade to the latest version shipped by the curl project, we recommend installing homebrew (a macOS software package manager)\r
    > brew install curl\r
\r
## 2.4.2 Calling a GET method\r
\r
In its most basic form, a curl command will look like this:\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl http://www.net.net\r
<head><title>Document Moved</title></head>\r
<body><h1>Object Moved</h1>This document may be found <a HREF="http://net.net">here</a></body>\r
\r
\`\`\`\r
\r
The default behavior for curl is to invoke an HTTP GET method on the given URL. This way, the program\u2019s output for that command will be the whole HTTP response\u2019s body (in this case, HTML which will be written as given on stdout.\r
\r
Many times we\u2019ll wish to direct the response\u2019s contents into a file. This is done with the \`-o (--output)\` argument, like this:\r
\r
> curl -o output.html www.net.net\r
> \r
> // Equivalent to \r
> \r
> curl www.net.net > output.html \r
\r
The URL must be in the last place, but optionally, you can specify the URL of the site you wish to call curl on with a \`-s (--silent) \`argument , allowing you to change the order of your arguments.\r
\r
curl -s http://www.net.net -o output.html\r
\r
In the previous example we are not getting the desired resource, because it has been moved or redirected to another URI. Using the \`-L (--location)\` mode, we can follow redirects and get the destination resource\r
\r
\`\`\`bash:no-line-numbers{1,3,5}\r
$> curl http://www.dataden.tech\r
Redirecting\r
$> curl -L http://www.dataden.tech\r
<html><head><title>Loading...</title></head><body><script type='text/javascript'>window.location.replace('http://www.dataden.tech/?js=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJKb2tlbiIsImV4cCI6MTYzMzM4OTE3OSwiaWF0IjoxNjMzMzgxOTc5LCJpc3MiOiJKb2tlbiIsImpzIjoxLCJqdGkiOiIycWxmMGdkZmg2YWlzaHMxdjgwdWx0aTQiLCJuYmYiOjE2MzMzODE5NzksInRzIjoxNjMzMzgxOTc5NzgzNzQ1fQ.y5LwDoSoZCpe2tzro_FbX7cSGIw4nx1XweNBqjpLXoo&sid=da601018-2557-11ec-a001-58f389072b17');<\/script></body></html>\r
$> curl -L http://www.net.net\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        <body>\r
                <!-- Begin: Google Analytics -->\r
                <script>\r
                  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r
                  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r
                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r
                  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\r
                  ga('create', 'UA-32196-28', 'auto');\r
                  ga('send', 'pageview');\r
                <\/script>\r
                <!-- End: Google Analytics -->\r
                <center>\r
                        <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />\r
                        <font face="impact, Arial, Helvetica, sans-serif" size="14">\r
                                NET.NET\r
                        </font>\r
                        <br /><br /><br /><br />\r
                        <font face="Arial, Helvetica, sans-serif" size="1">\r
                                <a href="http://who.godaddy.com/whoischeck.aspx?domain=NET.NET" target="_blank">NET.NET</a> is the first and the best domain name on the Internet!\r
                                <br />\r
                                Coming Soon...\r
                        </font>\r
                </center>\r
        </body>\r
</html>\r
\`\`\`\r
\r
So far we have only get the html page. If we want to see also the headers of our GET request and response headers, we have to user the \`-v (--verbose)\` option  to get full information about the HTTP protocol.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl -v  http://www.net.net\r
*   Trying 34.250.90.28:80...\r
* TCP_NODELAY set\r
* Connected to net.net (34.250.90.28) port 80 (#0)\r
> GET / HTTP/1.1\r
> Host: net.net\r
> User-Agent: curl/7.68.0\r
> Accept: */*\r
>\r
* Mark bundle as not supporting multiuse\r
< HTTP/1.1 200 OK\r
< Cache-Control: private\r
< Content-Type: text/html\r
< Server: Microsoft-IIS/10.0\r
< Set-Cookie: ASPSESSIONIDASRSRRAR=IMFFLMBBBIFJNLNDHLOACDAI; path=/\r
< X-Powered-By: ASP.NET\r
< Date: Mon, 04 Oct 2021 21:40:49 GMT\r
< Content-Length: 1080\r
<\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        ...\r
\`\`\`\r
\r
In the previous output requests header are marked with \`>\` while response header are marked with \`<\`.\r
\r
::: info short and long command line options\r
Command line options pass on information to curl about how you want it to behave.\r
\r
Single-letter options are convenient since they are quick to write and use, but as there are a limited number of letters and not all options are available like that.\r
Long option names are therefore provided for those. Also, as a convenience and to allow scripts to become more readable, most short options have longer name aliases.\r
\r
Short options are preceded by the minus symbol and a single letter immediately following it. They can be used with just that option name. You can then also combine several single-letter options after the minus.\r
\r
> $> curl -v -L http://example.com\r
> $> curl -vL http://example.com\r
\r
Long options are always written with two dashes and then the name, and you can only write one option name per double-dash.\r
\r
> $> curl --verbose --location http://example.com\r
\r
:::\r
\r
Finally, we can access partially the verbose mode information using the \`-i (--include)\` or \`-I (--head)\` to get the complete answer from the server (headers & data) or just the headers, respectively.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$>  curl -I https://jsonplaceholder.typicode.com/todos/1\r
HTTP/2 200\r
date: Mon, 04 Oct 2021 21:57:55 GMT\r
content-type: application/json; charset=utf-8\r
content-length: 83\r
x-powered-by: Express\r
x-ratelimit-limit: 1000\r
x-ratelimit-remaining: 999\r
x-ratelimit-reset: 1631546224\r
vary: Origin, Accept-Encoding\r
access-control-allow-credentials: true\r
cache-control: max-age=43200\r
pragma: no-cache\r
expires: -1\r
x-content-type-options: nosniff\r
etag: W/"53-hfEnumeNh6YirfjyjaujcOPPT+s"\r
via: 1.1 vegur\r
cf-cache-status: HIT\r
age: 10926\r
accept-ranges: bytes\r
expect-ct: max-age=604800, report-uri="https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"\r
report-to: {"endpoints":[{"url":"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=LxJlkSosQdWmBFBOx1fB6zrbjSbU0iStl7jjtlVL27CtOEPxem%2Ffl9y%2BCajMUopcZINOEsaufiU8A2glOLEmNpO5a40%2FyWb%2B4dBuspS8VGWnCRW4jxBBmh%2F3FbupAEaxy66TUPariKJLqe3PL5iq"}],"group":"cf-nel","max_age":604800}\r
nel: {"success_fraction":0,"report_to":"cf-nel","max_age":604800}\r
server: cloudflare\r
cf-ray: 6991ab2c1a5037c7-MAD\r
alt-svc: h3=":443"; ma=86400, h3-29=":443"; ma=86400, h3-28=":443"; ma=86400, h3-27=":443"; ma=86400\r
\`\`\`\r
\r
Finally, adding the \`-w "%{time_total}\\n"\` will simply output the total time it took to fetch the response from the given domain.\r
\r
## 2.4.2 Endpoints and routes\r
\r
The term endpoint is focused on the URL that is used to make a request.\r
\r
For a typical web API, endpoints are URLs, and they are described in the API's documentation so programmers know how to use/consume them. For example, a particular web API may have this endpoint:\r
\r
> GET https://my-api.com/Library/Books\r
\r
This would return a list of all books in the library.\r
\r
A "route" is typically a part of URL endpoint that routes the pages to different components.\r
\r
> GET https://my-api.com/Library/Books/341 \r
\r
This would access book with id 341 using the Library/Books endpoint\r
\r
For instance, for [SWAPI (Star Wars API)](https://swapi.dev/) the endpoint is \`https://swapi.dev/api/\`. That's the entry point for all requests.\r
\r
Thus there are many routes depending on the information we want to access/add/modify/delete.\r
\r
\`\`\`java:no-line-numbers\r
$> curl https://swapi.dev/api/people/1\r
$> curl https://swapi.dev/api/planet/3\r
$> curl https://swapi.dev/api/vehicles\r
\`\`\`\r
\r
## 2.4.3 HTTP methods and headers\r
\r
In every HTTP request, there's a method. Sometimes called a verb. The most commonly used ones are GET, POST, HEAD and PUT.\r
\r
POST is the HTTP method that was invented to send data to a receiving web application, and it is how most common HTML forms on the web works.\r
\r
When the data is sent by a browser it will send it URL encoded, as a serialized name=value pairs separated with ampersand symbols (&).\r
\r
You send such data with curl's \`-d (--data)\` option like this:\r
\r
> curl -d 'name=admin&shoesize=12' http://example.com/\r
\r
Curl selects which methods to use on its own depending on what action to ask for. -d will do POST, -I will do HEAD and so on. If you use the \`-X (--request)\` option you can change the method keyword curl selects.\r
\r
> curl -X POST -d 'imageSize=big&imageType=jpg' http://example.org/\r
\r
POSTing with curl's -d option will make it include a default header that looks like \`Content-Type: application/x-www-form-urlencoded\`. That's what your typical browser will use for a plain POST.\r
\r
If that header is not good enough for you, you should, of course, replace that and instead provide the correct one. Such as if you POST JSON to a server and want to more accurately tell the server about what the content is:\r
\r
> curl -X "POST" -d '{"imageSize":"big","imageType":"jpg","scale":"false"}' -H 'Content-Type: application/json' https://example.com\r
\r
## 2.4.4 Authentication\r
\r
Each HTTP request can be made authenticated. If a server or a proxy wants the user to provide proof that they have the correct credentials to access a URL or perform an action, it can send back a HTTP response code that informs the client that it needs to provide a correct HTTP authentication header in the request to be allowed.\r
\r
To tell curl to do an authenticated HTTP request, you use the \`-u (--user)\` option to provide user name and password (separated with a colon). Like this:\r
\r
> curl --user daniel:secret http://example.com/\r
\r
This will make curl use the default "Basic" HTTP authentication method.\r
\r
Many applications and services make use of a secret key or an Authorization token provided by the service provider when you create the service.\r
\r
[Trello API Introduction](https://developer.atlassian.com/cloud/trello/guides/rest-api/api-introduction/)\r
\r
[Azure Translator API Reference](https://docs.microsoft.com/es-es/azure/cognitive-services/translator/reference/v3-0-translate)\r
\r
If we want to use the Azure service for translate text, first we need to obtain the secret key and send it with each call to identify the user and get the permission to use the service.\r
\r
\`\`\`java:no-line-numbers\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Ocp-Apim-Subscription-Key: <here goes your susbcription key>" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
\r
Sometimes we can get a temporal authorization by getting an Authorization token, that later must be provided to access the service during a short period of time. Once the time expires, another token must be requested.\r
The \`Authorization: Bearer <token>\` header is used.\r
\r
\`\`\`java:no-line-numbers{1,3,5}\r
$> curl -X POST "https://api.cognitive.microsoft.com/sts/v1.0/issueToken" -H "Ocp-Apim-Subscription-Key: <here goes the secret key>" -d {}\r
eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzMwMTUxNywiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.0hyyBNr22E2sIO_ZBlTiBePXM_KE_5hQOCeHxz3US44" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
{"error":{"code":401000,"message":"The request is not authorized because credentials are missing or invalid."}}\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
## 2.4.5 References\r
\r
[Everything curl](https://everything.curl.dev/) is a detailed and totally free book available that explains basically everything there is to know about curl.\r
\r
[freecodecamp.org](https://www.freecodecamp.org/news/how-to-start-using-curl-and-why-a-hands-on-introduction-ea1c913caaaa/)\r
\r
[curl official site](https://curl.se/)\r
`]},{title:"2 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit2/",pathLocale:"/en/",extraFields:[`---\r
title: 2 Introduction\r
---\r
\r
# Unit 2. Process programming\r
\r
Once we know about key concepts in concurrency, we can also differentiate programs and processes. In this second unit we will learn how we can launch a program from our own code, that is, how to create a process from a running process.\r
\r
In addition to launch programs and create new processes, there's a relationship between the parent process and its children that allow them to communicate exchanging information. This is the way our programs will be able to launch other applications, os command or even applications developed by us. Furthermore, parent-child processes allow synchronization and communication among them.\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To know Java classes for process management\r
- To monitor and control process lifecycle\r
- To control parent-child communications\r
- To use synchronization methods for processes and sub-processes\r
- To learn how pipes communications works\r
- To learn curl syntax and use it for API REST testing purposes\r
- To create applications that run parallel tasks\r
`]},{title:"2.3 Handling Process Streams",headers:[{level:2,title:"2.3.1  Redirecting Standard Input and Output",slug:"_2-3-1-redirecting-standard-input-and-output",link:"#_2-3-1-redirecting-standard-input-and-output",children:[{level:3,title:"getInputStream()",slug:"getinputstream",link:"#getinputstream",children:[]},{level:3,title:"getErrorStream()",slug:"geterrorstream",link:"#geterrorstream",children:[]},{level:3,title:"getOutputStream()",slug:"getoutputstream",link:"#getoutputstream",children:[]},{level:3,title:"Inheriting the I/O of the parent process",slug:"inheriting-the-i-o-of-the-parent-process",link:"#inheriting-the-i-o-of-the-parent-process",children:[]},{level:3,title:"Pipelines",slug:"pipelines",link:"#pipelines",children:[]}]},{level:2,title:"2.3.2 Redirecting Standard Input and Output",slug:"_2-3-2-redirecting-standard-input-and-output",link:"#_2-3-2-redirecting-standard-input-and-output",children:[]},{level:2,title:"2.3.3 Current Java Process Information",slug:"_2-3-3-current-java-process-information",link:"#_2-3-3-current-java-process-information",children:[]}],path:"/en/unit2/iostreams.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.3 Handling Process Streams\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.3 Handling Process Streams" />\r
\r
# 2.3 Handling Process Streams\r
\r
[[toc]]\r
\r
## 2.3.1  Redirecting Standard Input and Output\r
\r
By default, the created subprocess does not have its terminal or console. All its standard I/O (i.e., stdin, stdout, stderr) operations will be sent to the parent process. Thereby the parent process can use these streams to feed input to and get output from the subprocess.\r
\r
Consequently, this gives us a huge amount of flexibility as it gives us control over the input/output of our sub-process.\r
\r
::: info OS I/O streams and pipes\r
Streams in Linux, like almost everything else, are treated as though they were files.\r
\r
Each file associated with a process is allocated a unique number to identify it. These values are always used for stdin, stdout, and stderr:\r
\r
- 0: stdin\r
- 1: stdout\r
- 2: stderr\r
\r
So we can manage these three streams in different ways. We can redirect a command\u2019s output (stdout) to a file and still see any error messages (stderr) in the terminal window, or we can get input to a command from another command or file. Let's look at some examples:\r
\r
\`\`\`bash:no-line-numbers\r
# Redirects ls output to a file\r
ls > capture.txt  \r
# Redirects ls output to cat input\r
ls | cat  \r
# Redirects program.sh output to capture.txt and its errors to error.txt\r
./program.sh 1> capture.txt 2> error.txt \r
# Redirects program.sh output and its errors to the same file, capture.txt\r
./program.sh > capture.txt 2>&1\r
# Redirects program.sh input from dummy.txt contents\r
./program.sh < dummy.txt\r
# Redirects output form first command to program.sh input\r
cat dummy.txt | ./program.sh\r
\`\`\`\r
\r
[Introduction to Linux I/O Redirection](https://www.digitalocean.com/community/tutorials/an-introduction-to-linux-i-o-redirection)\r
:::\r
\r
In a parent-child process relationship I/O streams are also redirected from child process to parent, using 3 pipes, one per each standard stream. Those pipes  can be used like in a Linux system.\r
\r
![alt_text](./../../media/unit2/pipe_with_two.jpg)\r
\r
### getInputStream()\r
\r
We can fetch the output generated by a subprocess and consume within the parent process thus allowing share information between the processes\r
\r
\`\`\`java\r
Process p = pbuilder.start();\r
BufferedReader processOutput = \r
    new BufferedReader(new InputStreamReader(p.getInputStream()));\r
\r
String linea;    \r
while ((linea = processOutput.readLine()) != null) {\r
    System.out.println("> " + linea);        \r
}            \r
processOutput.close();    \r
\`\`\`\r
\r
![alt_text](./../../media/unit2/Java_Stream_Readers_BufferedReaders.jpg)\r
\r
::: warning Charset and encodings\r
From the time being computer science started we've been in trouble with encodings and charsets. And windows console is not an exception.\r
\r
Terminal in Windows was also known as "DOS prompt": so a way to run DOS programs in Windows, so they keep the code page of DOS. Microsoft dislikes non-backward compatible changes, so your DOS program should works also on Windows terminal without problem.\r
\r
Wikipedia indicates that **CP850** has theoretically been "largely replaced" by **Windows-1252** and, later, Unicode, but yet it's here, right in the OS's terminal.\r
\r
Then, if we want to print information from the console in our applications we must deal with the right charset and encoding, that is, CP-850.\r
\r
Fortunately, InputStreamReader has a constructor to manage streams with any encoding, so we must use it when working with console commands or applications.\r
\r
\`\`\`java:no-line-numbers\r
new InputStreamReader(p.getInputStream(), "CP850");\r
\`\`\`\r
\r
> We can force Netbeans to use a UTF-8 as default encoding. To do so we must modify its config file \`C:/Program Files/Netbeeans-xx.x/netbeans/etc/netbeans.conf\`, changing directive \`netbeans_default_option\` and adding **-J-Dfile.encoding=UTF-8** to the end.\r
\r
:::\r
\r
### getErrorStream()\r
\r
Interestingly we can also fetch the errors generated from the subprocess and thereon perform some processing.\r
\r
if error output has been redirected by calling method  \`ProcessBuilder.redirectErrorStream(true)\` then, the error stream and the output stream will be shown using the same stream.\r
\r
If we want to have it differentiated from the output, then we can use asimilar schema than before\r
\r
\`\`\`java\r
Process p = pbuilder.start();\r
BufferedReader processError = \r
    new BufferedReader(new InputStreamReader(p.getErrorStream()));\r
int value = Integer.parseInt(processError.readLine());\r
processError.close();\r
\`\`\`\r
\r
::: info Decorator or Wrapper design pattern\r
In both input and error streams we are getting information from a BufferedReader. Although we are not aware of using a design pattern, we are using the **decorator design pattern"* or the so called **wrapper**.\r
\r
> Decorator is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the required behaviors.\r
\r
[Refactoring.Guru design patterns](https://refactoring.guru/design-patterns/java)\r
:::\r
\r
Let's look at a complete example code using all the above operations\r
\r
\`\`\`java\r
import java.io.*;\r
public class Ejercicio2 {\r
    public static void main(String[] args) {\r
        String comando = "notepad";\r
        ProcessBuilder pbuilder = new ProcessBuilder (comando);\r
        Process p = null;\r
        try {\r
            p = pbuilder.start();\r
            // 1- Procedemos a leer lo que devuelve el proceso hijo\r
            InputStream is = p.getInputStream();\r
            // 2- Lo convertimos en un InputStreamReader\r
            // De esta forma podemos leer caracteres en vez de bytes\r
            // El InputStreamReader nos permite gestionar diferentes codificaciones\r
            InputStreamReader isr = new InputStreamReader(is);\r
            // 2- Para mejorar el rendimiento hacemos un wrapper sobre un BufferedReader\r
            // De esta forma podemos leer enteros, cadenas o incluso l\xEDneas.\r
            BufferedReader br = new BufferedReader(isr);\r
\r
            // A Continuaci\xF3n leemos todo como una cadena, l\xEDnea a l\xEDnea\r
            String linea;\r
            while ((linea = br.readLine()) != null) \r
                System.out.println(linea);\r
        } catch (Exception e) {\r
            System.out.println("Error en: "+comando);\r
            e.printStackTrace();\r
        } finally {\r
            // Para finalizar, cerramos los recursos abiertos\r
            br.close();\r
            isr.close();\r
            is.close();\r
        }    \r
    }\r
}\r
\`\`\`\r
\r
### getOutputStream()\r
\r
We can even send input to a subprocess from a parent process\r
\r
There are three different ways of sending information to a child process. The first one is based on an OutputStream. Here no wrapper is used and the programmer has to manage all elements of the stream flow. From newline characters and type conversions to force sending information over the stream.\r
\r
\`\`\`java\r
// Low-level objects. We have to manage all elements of communication\r
OutputStream toProcess = p.getOutputStream();\r
toProcess.write((String.valueOf(number1)).getBytes("UTF-8"));\r
toProcess.write("\\n".getBytes());\r
toProcess.flush();\r
\`\`\`\r
\r
The next one is based on a Writer object as a wrapper for the OutputStream, where communication management is easier, but the programmer still has to manage elements as new lines.\r
\r
\`\`\`java\r
Writer w = new OutputStreamWriter(p.getOutputStream(), "UTF-8");\r
w.write("send to child\\n");\r
\`\`\`\r
\r
Finally, the top-level wrapper for using the OutputStream is the PrintWriter object, where we can use the wrapper with the same methods as the System.out to handle child communication flow.\r
\r
\`\`\`java\r
PrintWriter toProcess = new PrintWriter(\r
    new BufferedWriter(\r
        new OutputStreamWriter(\r
            p.getOutputStream(), "UTF-8")), true);\r
toProcess.println("sent to child");\r
\`\`\`\r
\r
### Inheriting the I/O of the parent process\r
\r
With the inheritIO() method We can redirect the sub-process I/O to the standard I/O of the current process (parent process)\r
\r
\`\`\`java\r
ProcessBuilder processBuilder = new ProcessBuilder("/bin/sh", "-c", "echo hello");\r
\r
processBuilder.inheritIO();\r
Process process = processBuilder.start();\r
\r
int exitCode = process.waitFor();\r
\`\`\`\r
\r
In the above example, by using the inheritIO() method we see the output of a simple command in the console in our IDE.\r
\r
### Pipelines\r
\r
Java 9 introduced the concept of pipelines to the ProcessBuilder API:\r
\r
\`\`\`java:no-line-numbers\r
public static List<Process> startPipeline\u200B(List<ProcessBuilder> builders)\r
\`\`\`\r
\r
Using the startPipeline method we can pass a list of ProcessBuilder objects. This static method will then start a Process for each ProcessBuilder. Thus, creating a pipeline of processes which are linked by their standard output and standard input streams.\r
\r
For example, if we want to run something like this:\r
\r
> find . -name *.java -type f | wc -l\r
\r
What we'd do is create a process builder for each isolated command and compose them into a pipeline\r
\r
\`\`\`java\r
List builders = Arrays.asList(\r
    new ProcessBuilder("find", "src", "-name", "*.java", "-type", "f"), \r
    new ProcessBuilder("wc", "-l"));\r
\r
List processes = ProcessBuilder.startPipeline(builders);\r
Process last = processes.get(processes.size() - 1);\r
\r
// We can get lats process output to get the final results\r
\`\`\`\r
\r
In the example, we're searching for all the java files inside the src directory and piping the results into another process to count them.\r
\r
## 2.3.2 Redirecting Standard Input and Output\r
\r
In the real world, we will probably want to capture the results of our running processes inside a log file for further analysis. Luckily the ProcessBuilder API has built-in support for exactly this.\r
\r
By default, our process reads input from a pipe. We can access this pipe via the output stream returned by Process.getOutputStream().\r
\r
However, as we'll see shortly, the standard output may be redirected to another source such as a file using the method \`redirectOutput(File)\`. In this case, getOutputStream() will return a ProcessBuilder.NullOutputStream.\r
\r
Let's prepare an example to print out the version of Java. But this time let's redirect the output to a log file instead of the standard output pipe:\r
\r
\`\`\`java\r
ProcessBuilder processBuilder = new ProcessBuilder("java", "-version");\r
\r
processBuilder.redirectErrorStream(true);\r
File log = folder.newFile("java-version.log");\r
processBuilder.redirectOutput(log);\r
\r
Process process = processBuilder.start();\r
\`\`\`\r
\r
In the above example, we create a new temporary file called log and tell our ProcessBuilder to redirect output to this file destination.\r
\r
Now let's take a look at a slight variation on this example. For instance when we wish to \`append to\` a log file rather than create a new one each time:\r
\r
\`\`\`java\r
File log = tempFolder.newFile("java-version-append.log");\r
processBuilder.redirectErrorStream(true);\r
processBuilder.redirectOutput(Redirect.appendTo(log));\r
\`\`\`\r
\r
It's also important to mention the call to \`redirectErrorStream(true)\`. In case of any errors, the error output will be merged into the normal process output file.\r
\r
We can also redirect error stream an input stream for the subprocess with methods\r
\r
- redirectError(File)\r
- redirectInput(File)\r
\r
And for each of them we can also set the following redirections\r
\r
- Redirect.to(File);\r
- Redirect.from(File);\r
- Redirect.appendTo(File);\r
- Redirect.DISCARD\r
\r
## 2.3.3 Current Java Process Information\r
\r
We can now obtain a lot of information about the process via the API \`java.lang.ProcessHandle.Info\` API:\r
\r
- the command used to start the process\r
- the arguments of the command\r
- time instant when the process was started\r
- total time spent by it and the user who created it\r
\r
Here's how we can do that\r
\r
\`\`\`java\r
ProcessHandle processHandle = ProcessHandle.current();\r
ProcessHandle.Info processInfo = processHandle.info();\r
\r
System.out.println("PID: " + processHandle.pid());\r
System.out.println("Arguments: " + processInfo.arguments());\r
System.out.println("Command: " + processInfo.command());\r
System.out.println("Instant: " + processInfo.startInstant());\r
System.out.println("Total CPU duration: " + processInfo.totalCpuDuration());\r
System.out.println("User: " + processInfo.user());\r
\`\`\`\r
\r
It is also possible to get the process information of a newly spawned process. In this case, after we spawn the process and get an instance of the \`java.lang.Process\`, we invoke the \`toHandle()\` method on it to get an instance of java.lang.ProcessHandle.\r
\r
\`\`\`java\r
Process process = processBuilder.inheritIO().start();\r
ProcessHandle processHandle = process.toHandle();\r
\`\`\`\r
\r
The rest of the details remain the same as in the section above\r
`]},{title:"2.2 Process management in Java - ProcessBuilder and Process",headers:[{level:2,title:"2.2.1 Preparation and setting of a process",slug:"_2-2-1-preparation-and-setting-of-a-process",link:"#_2-2-1-preparation-and-setting-of-a-process",children:[{level:3,title:"Setting the command at runtime",slug:"setting-the-command-at-runtime",link:"#setting-the-command-at-runtime",children:[]},{level:3,title:"Additional settings for a process",slug:"additional-settings-for-a-process",link:"#additional-settings-for-a-process",children:[]}]},{level:2,title:"2.2.2 Process control from parent",slug:"_2-2-2-process-control-from-parent",link:"#_2-2-2-process-control-from-parent",children:[{level:3,title:"Spawn a java application from a class into the same project",slug:"spawn-a-java-application-from-a-class-into-the-same-project",link:"#spawn-a-java-application-from-a-class-into-the-same-project",children:[]}]}],path:"/en/unit2/processbuilder.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.2 Process management in Java - ProcessBuilder and Process\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.2 Process management in Java - ProcessBuilder and Process" />\r
\r
# 2.2 Process management in Java ProcessBuilder and Process\r
\r
[[toc]]\r
\r
## 2.2.1 Preparation and setting of a process\r
\r
The class to set the running attributes for a new process, before it is being run, is the \`ProcessBuilder\` class.\r
\r
> [Specification java.lang.ProcessBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ProcessBuilder.html)\r
\r
This is an auxiliary class for the Process and is instantiated to manage a collection of process attributes. We can invoke the \`start\` method to create a new process with the attributes defined by the instance of the ProcessBuilder class.\r
\r
Repeated calls to the start method would create a new process with the same attributes.\r
\r
The ProcessBuilder class defines two constructors, such as:\r
\r
\`\`\`java:no-line-numbers\r
ProcessBuilder(List<String> command)\r
ProcessBuilder(String... command)\r
\`\`\`\r
\r
The meaning implied by the parameters passed to both constructors is same. In the first constructor, the command to be executed, along with command line arguments, is passed in a list of strings. And, in the second constructor, the command and the command line arguments are specified through the varargs parameter. We can use either of the constructors, depending upon the way to pass the parameter.\r
\r
::: danger Arguments vs Parameters\r
If we want to launch a command with parameters, the command cannot be sent to ProcessBuilder in raw mode, it must be processed and converted into a List in order to make it work.\r
\r
\`\`\`java\r
// Different modes to pass the command to ProcessBuilder constructors\r
// 1st mode: using a string. It fails with parameters, \r
// Only works with commands having arguments\r
String command1 = "notepad.exe prueba1.txt"\r
ProcessBuilder pb = new ProcessBuilder(command1);\r
\r
// 2nd mode: using an array of strings. It also works with parameters\r
String[] command2 = {"cmd", "/c", "dir", "/o"};\r
ProcessBuilder pb = new ProcessBuilder(command2);\r
\r
// 3rd mode: using a string and splitting it to convert into a List\r
String command3 =  "c:/windows/system32/shutdown -s -t 0";  \r
// Regular expresion \\s means splitting the string by blank spaces\r
ProcessBuilder pb = new ProcessBuilder(command3.split("\\\\s"));\r
\`\`\`\r
\r
:::\r
\r
::: warning OS shutdown\r
You can use shutdown -s command to shutdown system. For windows OS, you need to provide full path of shutdown command e.g. C:\\Windows\\System32\\shutdown.\r
\r
Here you can use -s switch to shutdown system, -r switch to restart system, -h to put the system into hibernation, and -t switch to specify time delay.\r
\r
[Windows shutdown reference](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/shutdown)\r
:::\r
\r
::: question Activity psp.activities.U2A1_Shutdowner\r
Create a new Java application project (package psp.activities & main class U2A1_Shutdowner)\r
Using the command line, ask the user for the action he wants to do with the computer (shutdown ,restart or suspend) and how much time he needs before shutting down the system.\r
\r
Find information about the shutdown command in GNU/Linux and make your app work in both systems.\r
\r
Your app has to prepare the right command for the answers the user has given and for the OS it is running on.\r
\r
Get the ProcessBuilder.command() result and show it on the console in a readable format.\r
:::\r
\r
:::details U2A1_Shutdowner solution\r
\r
\`\`\`java\r
public class U2A1_Shutdowner {\r
\r
    public static void main(String[] args) throws IOException {\r
        // Ask for the required information to prepare the command\r
        Scanner keyboard = new Scanner(System.in);\r
        \r
        System.out.print("Select your option (s-shutdown / r-reboot / h-hibernate): ");\r
        String shutdownOption = keyboard.nextLine();        \r
        \r
        System.out.print("How much seconds will the command wait to be run? (0 means immediately): ");\r
        String shutdownTime = keyboard.nextLine();        \r
        \r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "C:/Windows/System32/shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        } else {\r
            command = "shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        }\r
        \r
        // Prepare the process and launch it\r
        ProcessBuilder shutdowner = new ProcessBuilder(command.split("\\\\s"));\r
        //shutdowner.start();\r
        \r
        // Show the command to be run\r
        System.out.print("El comando a ejecutar es:  ");\r
        for (String commandPart: shutdowner.command()) {\r
            System.out.print(commandPart + " ");\r
        }\r
        System.out.println("");\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
### Setting the command at runtime\r
\r
If we want to set the command to be run at runtime, or at the time the ProcessBuilder instance is created we still don't know the command, it can be set later by using the command(String).\r
\r
The same way as the constructors, we have two versions of command method\r
\r
\`\`\`java:no-line-numbers\r
    command(List<String> command)\r
    command(String... command)\r
\`\`\`\r
\r
and there's also another command method, without parameters, to retrieve the command and parameters already set for the ProcessBuilder instance. Once we have the parameters list, we can modify it using List methods.\r
\r
\`\`\`java\r
// Sets and modifies the command after ProcessBuilder object is created\r
String command = "java -jar install.jar -install"; // tmp dir is missing\r
ProcessBuilder pbuilder = new ProcessBuilder(command.split("\\\\s"));\r
if (isWindows) {\r
    pbuilder.command().add(0, "cmd"); // Sets the 1st element\r
    pbuilder.command().add(1, "/c"); // Sets the 2nd element\r
    pbuilder.command().add("c:/temp"); // Sets the last element\r
    // Command to run cmd /c java -jar install.jar -install c:/temp\r
} else {\r
    pbuilder.command().add(0, "sh"); // Sets the 1st element\r
    pbuilder.command().add(1, "-c"); // Sets the 2nd element\r
    pbuilder.command().add("/tmp"); // Sets the last element\r
    // Command to run: sh -c java -jar install.jar -install /tmp\r
}\r
\r
// Starts the process\r
pbuilder.start();\r
\`\`\`\r
\r
### Additional settings for a process\r
\r
Some of the settings that can be changed for a process are:\r
\r
- Set the working directory where the process will be run\r
  We can override the default working directory of the current process by calling the directory method and passing a File object. **By default, the current working directory is set to the value returned by the user.dir system property**.\r
\r
    \`\`\`java\r
    // Change working directory for the running process\r
    pbuilder.directory(new File(System.getProperty("user.home")));\r
    \`\`\`\r
\r
- Set-up a custom key-value map and modify an existing one using builder.environment()\r
\r
    \`\`\`java\r
    // Retrieve and modify the process environment\r
    Map<String, String> environment = pbuilder.environment();\r
    // Get the PATH environment variable and add a new directory\r
    String systemPath = environment.get("path") + ";c:/users/public";\r
    environment.replace("path", systemPath);\r
    // Add a new environment variable and use it as a part of the command\r
    environment.put("GREETING", "Hola Mundo");\r
    processBuilder.command("/bin/bash", "-c", "echo $GREETING");\r
    \`\`\`\r
\r
    ::: info Environment variables vs System properties\r
    With Runtime we also accessed System properties, that are different from this environment ones.\r
    :::\r
\r
- Redirect input and output streams to custom replacements\r
- Inherit both of them to the streams of the current JVM process using builder.inheritIO()\r
  \r
  *This two settings will be covered later in this unit*.\r
\r
::: question Activity psp.activities.U2A2_WorkingDirectory\r
Create a new Java application project (package psp.activities & main class U2A2_WorkingDirectory    )\r
Prepare a process to run the dir/ls command to check that the directory listing is for the directory pointed by the user.dir property.\r
In the same application, change the value for the user.dir property.\r
Finally, set a working directory for the process.\r
\r
Print the user.dir environment value for the three scenarios after being changed.\r
:::\r
\r
::: details U2A2_WorkingDirectory solution\r
\r
\`\`\`java\r
public class U2A2_WorkingDirectory {\r
\r
    public static void main(String[] args) throws IOException {\r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "cmd /c dir";\r
        } else {\r
            command = "sh -c ls";\r
        }\r
        \r
        // Prepare the process and launch it\r
        ProcessBuilder commander = new ProcessBuilder(command.split("\\\\s"));\r
        \r
        //1st - Default working directory\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        //2nd - Set the user.dir\r
        System.setProperty("user.dir", System.getProperty("user.home"));\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        // 3rd - Change the working directory\r
        commander.directory(new File(System.getProperty("user.home")));\r
        System.out.println("Working directory: " + commander.directory().toString());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        commander.start();        \r
    }\r
}\r
\`\`\`\r
\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.2 Process control from parent\r
\r
The \`Process\` is an abstract class defined in the java.lang package that encapsulates the runtime information of a program in execution. The \`start\` method invoked by the ProcessBuilder class returns a reference to this class instance. There is an another way to create an instance of this class, through the \`exec\` method of the Runtime instance.\r
\r
The methods defined by the Process class can be used to perform input/output operations from the process, check the exit status of the process, wait for it to complete, and terminate the process. These methods, however, are not built to work on special processes of the native platform like daemon processes, shell scripts, and so on.\r
\r
> [Specification java.lang.Process](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Process.html)\r
\r
::: warning Input/ output from the child process\r
Intriguingly, **the process created by the start() method does not own a console**. Instead, it redirects (stdin, stdout, stderr) to the parent process. If need be, we can access them via streams obtained using methods defined in the class, such as getInputStream(), getOutputStream() and getErrorSteam(). These are the ways we can feed input to and get results from the sub processes.\r
:::\r
\r
Some of the common methods defined in this class are:\r
\r
| method                                       | Description                                                                                                                                                |\r
| :------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| int exitValue()                              | Exit code returned from the process executed                                                                                                              |\r
| Boolean isAlive()                            | Checks if the invoking process is still running.                                                                                                    |\r
| int waitFor()                                | Parent process waits for the child process to end. The integer value returned by the method is the exit code by the process.                                           |\r
| Boolean waitFor(long timeOut, TimeUnit unit) | Overloaded method of previous one. We can specify the wait time. This method returns true if the process has terminated and false if timeout has occurred. |\r
| void destroy()                               | These two methods are used to kill or terminate the process. One, the second, just does it forcibly.                                                       |\r
| Process destroyForcibly()                    |\r
\r
 Let\u2019s write a simple Java program to open an application as a separate process. After it is opened, the program would wait for, say, 10 seconds and then destroy the process, which will immediately close the application.\r
\r
\`\`\`java\r
public class ProcessDemo {\r
\r
   public static void main(String[] args) throws Exception {\r
\r
      ProcessBuilder pb = new ProcessBuilder("firefox");\r
      // Effectively launch the process\r
      Process p = pb.start();\r
      // Check is process is alive or not\r
      boolean alive = p.isAlive();\r
      // Wait for the process to end for 10 seconds.\r
      if (p.waitFor(10, TimeUnit.SECONDS)) {\r
          System.out.println("Process has finished");\r
      } else {\r
          System.out.println("Timeout. Process hasn't finished");\r
      }\r
      // Force process termination.\r
      p.destroy();\r
      // Check again if process remains alive\r
      boolean alive = p.isAlive();\r
      // Get the process exit value\r
      int status = p.exitValue();        \r
   }\r
}\r
\`\`\`\r
\r
::: info Exit codes\r
An exit code, or sometimes known as a return code, is the code returned to a parent process by an executable. The standard exit code is 0 for success and any number from 1 to 255 for anything else.\r
:::\r
\r
::: question Activity psp.activities.U2A3_ExitValue\r
Create a new Java application project (package psp.activities & main class U2A3_ExitValue)\r
Prepare a process to run different commands (notepad, calc, shell commands) one after each other, and make your application get their exit code. Print it.\r
\r
Commands can be hardcoded. As an **optional** improvement for this activity you can ask the user for the command and make your app interactive. There must be an option to exit the app (empty command for instance).\r
\r
Try with non-existing applications or using wrong arguments/parameters for commands.\r
\r
Can you force a process not to be successful?\r
\r
How can you know your own process exit code?\r
:::\r
\r
::: details U2A3_ExitValue solution\r
\r
\`\`\`java\r
public class U2A3_ExitValue {\r
\r
    public static void main(String[] args) {\r
        do {\r
            // C\xF3digo para pedir un programa/comando a ejecutar\r
            Scanner teclado = new Scanner(System.in);\r
            System.out.println("Introduce el programa / comando que quieres ejecutar (intro para acabar): ");\r
            String comando = teclado.nextLine();\r
            \r
            if (comando.equals("")) System.exit(0);\r
\r
            try {\r
                // Preparamos el entrono de ejecuci\xF3n del proceso\r
                // Como no sabemos el contenido del comando, forzamos su conversi\xF3n\r
                // a una lista para que no haya problemas con su ejecuci\xF3n\r
                ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
\r
                // Lanzamos el proceso hijo\r
                Process p = pb.start();          \r
\r
                // Esperamos a que acabe para recoger el valor de salida\r
                int exitValue = p.waitFor();\r
\r
                if (exitValue == 0) {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
                } else {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. C\xF3digo (" + exitValue + ")");\r
                }\r
\r
            } catch (InterruptedException | IOException ex) {\r
                System.err.println(ex.getLocalizedMessage());\r
                ex.printStackTrace();\r
            }                       \r
        } while (true);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
\r
::: danger Exceptions management\r
Call to method **waitFor** implies that the parent process gets locked until child process ends, or until a signal from the system (Exception) is received.\r
\r
It's better to handle exceptions than to throw them to upper levels.\r
:::\r
\r
### Spawn a java application from a class into the same project\r
\r
For some activities you'll be required to create the parent and the child processes as Java applications. Then, from one the classes you will need to launch the other one.\r
\r
This implies that both classes are gonna have a main method. So, in the project properties we'll need to set which is the main class that will be run first, usually the \`Launcher\` class (parent process).\r
\r
![Main class](../../media/unit2/seleccionmain.png)\r
\r
Before one class can run the other, at least the second one (child process) must be compiled, that is, the .class file has to be generated into the build/classes directory.\r
\r
![Working directory](../../media/unit2/comandotree.png)\r
\r
Them and only then we can set the process environment to spawn a new process from an existing class. Here is the sample code\r
\r
\`\`\`java\r
// Prepare the environment and the command\r
ProcessBuilder pb = new ProcessBuilder("java", "psp.u2.actividad10.Sumador");\r
pb.directory(new File("build/classes"));\r
Process p = pb.start();\r
\`\`\`\r
\r
::: question Activity psp.activities.U2A4_Launcher\r
Create a new Java application project (package psp.activities & main class U2A4_Launcher).\r
\r
Into the project create another class, U2A4_Commander with a main method that receives a program name as a unique parameter in the main. Make this application to create and run a process for the program and wait until that process has finished.\r
\r
This class will return always the same value the launched program did.\r
\r
> System.exit() method\r
>\r
> - Zero. The zero status code should be used when the program execution went fine, i.e., the program is terminated successfully.\r
> - Non-Zero. A nonzero status code indicates abnormal termination. Java allows us to use different values for different kinds of errors.\r
\r
Now, make the U2A4_Launcher class ask the user for an application name and launch the Commander class passing it the name of the application entered by the user.\r
\r
Get the exitValue from Commander and show it's value, telling if the process worked fine or if it failed.\r
:::\r
\r
::: details U2A4_Launcher solution\r
\r
\`\`\`java\r
public class U2A4_Launcher {\r
\r
    public static void main(String[] args) {\r
\r
        // C\xF3digo para pedir un programa/comando a ejecutar\r
        Scanner teclado = new Scanner(System.in);\r
        System.out.println("Introduce el programa / comando que quieres ejecutar: ");\r
        String comando = teclado.nextLine();\r
\r
        try {\r
            // Preparamos el entrono de ejecuci\xF3n del proceso\r
            // Como no sabemos el contenido del comando, forzamos su conversi\xF3n\r
            // a una lista para que no haya problemas con su ejecuci\xF3n\r
            comando = "java psp.activities.U2A4_Commander " + comando;\r
            ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
            pb.directory(new File("build/classes"));\r
\r
            // Lanzamos el proceso hijo\r
            Process p = pb.start();          \r
\r
            // Esperamos a que acabe para recoger el valor de salida\r
            int exitValue = p.waitFor();\r
\r
            if (exitValue == 0) {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
            } else {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. C\xF3digo (" + exitValue + ")");                \r
            }\r
        } catch (InterruptedException | IOException ex) {\r
            System.err.println(ex.getLocalizedMessage());\r
            ex.printStackTrace();\r
        }                       \r
    }\r
}\r
\r
public class U2A4_Commander {\r
\r
    public static void main(String[] args) throws Exception {       \r
        // Lectura de informaci\xF3n desde los par\xE1metros de entrada \r
        // Se supone que recibimos: args[0] args[1] args[2] ..... args[args.length-1 --> comando a ejecutar\r
        String comando = "";\r
        for (int i = 0; i < args.length; i++) {\r
            comando += args[i] + " ";\r
        }\r
        comando.trim();\r
                \r
        ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));            \r
\r
        // Lanzamos el proceso hijo\r
        Process p = pb.start();          \r
\r
        // Esperamos a que acabe para recoger el valor de salida\r
        int exitValue = p.waitFor();\r
\r
        System.exit(exitValue);\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
::: warning Child classes programming\r
Every class must be coded to be run independently or just as a child process. Think that in Netbeans all classes are run as child classes from the IDE.\r
\r
That's why the code, child or parent, needs to be done without thinking how they are gonna be called. The code must be  **independent** just like processes are one from each other.\r
:::\r
`]},{title:"2.1 Running processes in Java with Runtime",headers:[{level:2,title:"2.1.1. Quick process launch",slug:"_2-1-1-quick-process-launch",link:"#_2-1-1-quick-process-launch",children:[]},{level:2,title:"2.1.2 System properties and command shells",slug:"_2-1-2-system-properties-and-command-shells",link:"#_2-1-2-system-properties-and-command-shells",children:[]}],path:"/en/unit2/runtime.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.1 Running processes in Java with Runtime\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.1. Running processes in Java with Runtime" />\r
\r
# 2.1. Running processes in Java with Runtime\r
\r
[[toc]]\r
\r
## 2.1.1. Quick process launch\r
\r
 There are several methods defined in the Runtime class. These methods can be invoked to get the information about the runtime environment such as number of processors available to the JVM, about of memory available, loading native library, explicitly call garbage collector, and so forth.\r
\r
> [Specification java.lang.Runtime](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html)\r
\r
Every Java program has an instance of the Runtime class, which encapsulates the runtime environment of the program. This class cannot be instantiated, but we can get a reference **singleton instance** to the Runtime of the currently running program with the help of the static method **java.lang.Runtime.getRuntime()**.\r
\r
::: question Design patterns: Singleton\r
\xBFWhat are design patterns? \xBFWhat is and what is used for the singleton pattern?\r
\r
Look how to implement a class with the singleton pattern.\r
\r
[Refactoring.Guru design patterns](https://refactoring.guru/design-patterns/java)\r
:::\r
\r
The Runtime class method we are interested in, to create a new processes is\r
\r
> public Process exec(String command) throws IOException\r
\r
This is a simple, not yet customizable, way to spawn a new sub-process.\r
\r
\`\`\`java\r
public static void main(String[] args) throws IOException {\r
    // Launch notepad app\r
    Runtime.getRuntime().exec("notepad.exe");\r
\r
    // This way always works\r
    // String separator = System.getProperty("file.separator");\r
    // Runtime.getRuntime()\r
    //    .exec("c:"+separator+"windows"+separator+"notepad.exe");\r
\r
    // This way used to work (UNIX style paths)\r
    // Runtime.getRuntime().exec("c:/windows/notepad.exe");\r
}\r
\`\`\`\r
\r
As you can see the argument to  \`exec\` method is just the program we want to run. In this example, as *notepad* is in the system PATH it's not necessary to tell the path to the program. Otherwise, the path must be specified with the program name.\r
\r
<div class="pagebreak"></div>\r
\r
## 2.1.2 System properties and command shells\r
\r
If we plan to code platform independent applications, we have to deal with many issues because of differences between OS. So sometimes we need to deal with specific OS information. A useful way to get that information is by getting System properties.\r
\r
[Specification System.getProperties](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#getProperties())\r
\r
Some examples are provided here using System properties. Similar solutions can be used for other issues.\r
\r
::: danger File separator\r
For file path or directory separator, the Unix system introduced the slash character / as directory separator, and the Microsoft Windows introduced backslash character \\ as the directory separator. In a nutshell, this is / on UNIX and \\ on Windows.\r
\r
Then, \xBFhow can we code OS independent applications??\r
\r
In Java, we can use the following three methods to get the platform-independent file path separator.\r
\r
- System.getProperty("file.separator")\r
- FileSystems.getDefault().getSeparator() (Java NIO)\r
- File.separator Java IO\r
\r
From now on, we are gonna use System properties in our applications for several situations using \`System.getProperty(String propName)\`. These properties are configured by the OS and the JVM, though we can modify them by setting the JVM running setting\r
\r
> String separator = System.getProperty("file.separator");\r
\r
or\r
\r
> -Dfile.separator\r
\r
Nevertheless is always a good practice to use slash character **/** in paths as Java is able to convert them to the system it is running on.\r
:::\r
\r
If we want to run an OS command we have to do it as we usually do, by using the command shell, where once again we find the troubleshot with UNIX / Windows.\r
\r
Let's take a look at the way we can use the system properties, once again, to get a list of files in the user personal folder.\r
\r
\`\`\`java\r
// First we get the user folder path\r
String homeDirectory = System.getProperty("user.home");\r
// And then we set which OS are we running on\r
boolean isWindows = System.getProperty("os.name")\r
  .toLowerCase().startsWith("windows");\r
\r
if (isWindows) {\r
    Runtime.getRuntime()\r
      .exec(String.format("cmd.exe /c dir %s", homeDirectory));\r
} else {\r
    Runtime.getRuntime()\r
      .exec(String.format("sh -c ls %s", homeDirectory));\r
}\r
\`\`\`\r
\r
::: info non-interactive shell mode\r
In the previous code example, both for Windows and UNIX modifier **c** is used for command shells. This modifier tells the system to open a command shell, to run the companion command and close the shell after it has finished.\r
:::\r
\r
Next you can look at a handler event manager for a mouse clic, into a graphic application, to open a web site in a browser. The code shows how to do it in  *X like operating system and one way to do it in Windows systems is commented.\r
\r
\`\`\`java\r
// Calling app example\r
public void mouseClicked(MouseEvent e) {\r
  // Launch Page\r
  try {\r
    // Linux version\r
    Runtime.getRuntime().exec("open http://localhost:8153/go");\r
    // Windows version\r
    // Runtime.getRuntime().exec("explorer http://localhost:8153/go");\r
  } catch (IOException e1) {\r
    // Don't care\r
  }\r
}\r
\`\`\`\r
\r
::: question System properties\r
Our first applications in java is not gonna be an easy one.\r
\r
Using methods from System class and Runtime class, write the code for an app that shows\r
\r
- all the system properties configured in your OS\r
- total memory, free memory, used memory and processors available\r
\r
Make a research into Runtime class methods. For System properties try to get a list or iterable data estructure to show each of the system properties and their values.\r
:::\r
\r
::: details Proposed solution to previous activiy\r
\r
\`\`\`java{22,25,32,38,44}\r
long freeMemory = Runtime.getRuntime().freeMemory();\r
long availableMemory = Runtime.getRuntime().totalMemory();\r
long usedMemory = availableMemory - freeMemory;\r
\r
/*** Runtime.getRuntime() usage ***/\r
// Show system information\r
// Memory will be shown in MBytes formatted with 2-decimal places\r
DecimalFormat megabytes = new DecimalFormat("#.00");\r
System.out.println("Available memory in JVM(Mbytes): " + \r
        megabytes.format((double)availableMemory/(1024*1024)));\r
System.out.println("Free memory in JVM(Mbytes): " + \r
        megabytes.format((double)freeMemory/(1024*1024)));\r
System.out.println("Used memory in JVM(Mbytes): " + \r
        megabytes.format((double)usedMemory/(1024*1024)));\r
\r
System.out.println ("Processors in the system: " \r
        + Runtime.getRuntime().availableProcessors());\r
\r
/*** System.getProperties() usage ***/\r
// Show each pair of property:value from System properties\r
\r
// 1st. As a lambda expression using anonymous classes\r
System.getProperties().forEach((k,v) -> System.out.println(k + " => " + v));\r
\r
// 2nd. As a Map.entrySet \r
for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\r
    Object key = entry.getKey();\r
    Object val = entry.getValue();\r
    System.out.println("> " + key + " => " + val);\r
}\r
\r
// 3rd. As a Map.keySet\r
for (Object key : System.getProperties().keySet().toArray())\r
{\r
    System.out.println(">> " + key+":"+System.getProperty(key.toString()));\r
}\r
\r
// Other methods found by students, based on a Properties object methods.\r
Properties prop = System.getProperties();\r
for (String propName: prop.stringPropertyNames()) {\r
  System.out.println(propName +  ":" + System.getProperty(propName));\r
}\r
        \r
// Or directly to the console using \r
prop.list(System.out);\r
\`\`\`\r
\r
:::\r
\r
::: info Number format\r
In any programming language we have many different ways to format the information shown to the user. As in this first applications we are using the console as the system output, let's check the two main techniques we can use in Java\r
\r
- [NumberFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DecimalFormat.html)\r
\r
Using NumberFormat class or any of its descendants we can get control on how the numbers are shown with high precision, using numeric patterns.\r
\r
\`\`\`java:no-line-numbers\r
DecimalFormat numberFormat = new DecimalFormat("#.00");\r
// Hashes can be used instead of zeros to allow .30 to be shown as 0.3\r
// (additional digits are optional)\r
System.out.println(numberFormat.format(number));\r
\`\`\`\r
\r
- [System.out.printf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html)\r
\r
Similar to C's printf syntax, we can use the java.util.Formatter syntax to set how data is visualized.\r
\r
\`\`\`java:no-line-numbers\r
System.out.printf("\\n$%10.2f",shippingCost);\r
// numbers after % print preceding spaces to fill \r
// and justify numbers.\r
System.out.printf("%n$%.2f",shippingCost);\r
\`\`\`\r
\r
:::\r
\r
::: info Colours in console applications\r
\r
There is a way to print in different colours when using the console. Here you have got an example code with some colours and the way to use it.\r
\r
\`\`\`java:no-line-numbers\r
public class UsingColoursInConsole {\r
\r
public static final String ANSI_RESET = "\\u001B[0m";\r
public static final String ANSI_BLACK = "\\u001B[30m";\r
public static final String ANSI_RED = "\\u001B[31m";\r
public static final String ANSI_GREEN = "\\u001B[32m";\r
public static final String ANSI_YELLOW = "\\u001B[33m";\r
public static final String ANSI_BLUE = "\\u001B[34m";\r
public static final String ANSI_PURPLE = "\\u001B[35m";\r
public static final String ANSI_CYAN = "\\u001B[36m";\r
public static final String ANSI_WHITE = "\\u001B[37m";\r
\r
public static final String ANSI_BLACK_BACKGROUND = "\\u001B[40m";\r
public static final String ANSI_RED_BACKGROUND = "\\u001B[41m";\r
public static final String ANSI_GREEN_BACKGROUND = "\\u001B[42m";\r
public static final String ANSI_YELLOW_BACKGROUND = "\\u001B[43m";\r
public static final String ANSI_BLUE_BACKGROUND = "\\u001B[44m";\r
public static final String ANSI_PURPLE_BACKGROUND = "\\u001B[45m";\r
public static final String ANSI_CYAN_BACKGROUND = "\\u001B[46m";\r
public static final String ANSI_WHITE_BACKGROUND = "\\u001B[47m";\r
\r
    public static void main(String[] args) {\r
        System.out.println(ANSI_GREEN + ANSI_WHITE_BACKGROUND + "Hello" + ANSI_BLUE + ANSI_YELLOW_BACKGROUND + " Bye bye" + ANSI_RESET);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
`]},{title:"3.4 Alternative synchronization techniques",headers:[{level:2,title:"3.4.1. Semaphores",slug:"_3-4-1-semaphores",link:"#_3-4-1-semaphores",children:[]},{level:2,title:"3.4.2. High level synchronization techniques",slug:"_3-4-2-high-level-synchronization-techniques",link:"#_3-4-2-high-level-synchronization-techniques",children:[{level:3,title:"Concurrent Queues",slug:"concurrent-queues",link:"#concurrent-queues",children:[]},{level:3,title:"Concurrent Collections",slug:"concurrent-collections",link:"#concurrent-collections",children:[]},{level:3,title:"Atomic variables",slug:"atomic-variables",link:"#atomic-variables",children:[]}]},{level:2,title:"3.4.3 Executors, Callables & Future",slug:"_3-4-3-executors-callables-future",link:"#_3-4-3-executors-callables-future",children:[]}],path:"/en/unit3/alternatives.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.4 Alternative synchronization techniques\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.4 Alternative synchronization techniques" />\r
\r
# 3.4 Alternative synchronization techniques\r
\r
[[toc]]\r
\r
## 3.4.1. Semaphores\r
\r
There are many other ways to synchronize threads, one of the low-level ones ar \`semaphores\`. A semaphore controls access to a shared resource through the use of a counter. If the counter is greater than zero, then access is allowed. If it is zero, then access is denied. What the counter is counting are permits that allow access to the shared resource. Thus, to access the resource, a thread must be granted a permit from the semaphore.\r
\r
> [java.util.concurrent.Semaphore](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Semaphore.html) specification.\r
\r
Semaphores control access to \`critical sections\` where shared resources or variables are handled in a special way. Depending on thi initial value of the semaphore, a number of concurrent threads can access simultaneously to a shared resource.\r
\r
Semaphores can be manages with two methods and their initial value \`permits\`:\r
\r
- release(): When thread no longer needs access to a shared resource, it releases the permit, incrementing the semaphore count. By default the semaphore counter \`permits\` is incremented by 1, though it can get a value and increment the count in that value.\r
- acquire(): If a thread needs to access a shared resource or critical section, then it must get control over the semaphore. If semaphore count > 0, the thread acquires a permit, decrementing the semaphore\u2019s count. Else, the thread is blocked until a permit can be acquired. Other value than 1 can be used to get the semaphore, having \`permits\` to be bigger than that value in order to get semaphore's control\r
- permits: The value of a counting semaphore at any point indicates the maximum number of processes that can enter the critical section at the exact same time. Each thread asks for a permit. if value is bigger than 0 that means free resources are available, so the thread will enter the semaphore and reduce the permit count\r
When the semaphore's permit count reaches to 0 that means no more shared resources are available and threads will be locked waiting for another thread to perform a release action on the semaphore.\r
\r
:::info Mutex\r
Binary semaphore: A binary semaphore only takes only 0 and 1 as values and is used to implement mutual exclusion as well as synchronize concurrent processes.\r
\r
The work similar to synchronized, providing **mut**ual **ex**clusion.\r
:::\r
\r
Let's take a look at this example\r
\r
\`\`\`java {class="line-numbers",5-7,13,15,20,27,37,39,44,51}\r
public class Almacen {\r
\r
  private final int MAX_LIMITE = 20;\r
  private int producto = 0;\r
  private Semaphore productor = new Semaphore(MAX_LIMITE);\r
  private Semaphore consumidor = new Semaphore(0);\r
  private Semaphore mutex = new Semaphore(1);\r
\r
  public void producir(String nombreProductor) {\r
    System.out.println(nombreProductor + " intentando almacenar un producto");\r
    try {\r
        // up to 20 producers can enter at the same time\r
        productor.acquire();\r
        // But only 1 (consumer/producer) at a time can update\r
        mutex.acquire();\r
\r
        producto++;\r
        System.out.println(nombreProductor + " almacena un producto. "\r
            + "Almac\xE9n con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
      \r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // Producers allow (notify) consumers to access\r
      consumidor.release();\r
    }\r
\r
  }\r
\r
  public void consumir(String nombreConsumidor) {\r
    System.out.println(nombreConsumidor + " intentando retirar un producto");\r
    try {\r
        // A producer must be run first, before any consumer\r
        consumidor.acquire();\r
        // But only 1 (consumer/producer) at a time can update\r
        mutex.acquire();\r
\r
        producto--;\r
        System.out.println(nombreConsumidor + " retira un producto. "\r
            + "Almac\xE9n con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // Consumers allow (notify) producers to add more products\r
      productor.release();\r
\r
    }\r
  }\r
\r
}\r
\`\`\`\r
\r
## 3.4.2. High level synchronization techniques\r
\r
The \`java.util.concurrent\` package provides tools for creating concurrent applications. There are some  \`thread-safe\` classes que to use Collections and basic data types without worrying about concurrent access.\r
\r
Using these classes in our code we can reduce out apps complexity.\r
\r
### Concurrent Queues\r
\r
The **BlockingQueue** interface defines a \`FIFO\` queue that locks threads trying to get elementos from an empty queue until there will be elements in the queue. it can set a maximum number of elements in the queue so that thread are blocked if they try to add elements over that number, having to wait until elements are extracted form the queue.\r
\r
Classes LinkedBlockingQueue, ArrayBlockingQueue, SynchronousQueue, PriorityBlockingQueue and DelayQueue implement interface BlockingQueue.\r
\r
### Concurrent Collections\r
\r
Besides Queues, this package supplies Collection implementations designed for use in multithreaded contexts: ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArrayList, and CopyOnWriteArraySet. When many threads are expected to access a given collection, a ConcurrentHashMap is normally preferable to a synchronized HashMap, and a ConcurrentSkipListMap is normally preferable to a synchronized TreeMap. A CopyOnWriteArrayList is preferable to a synchronized ArrayList when the expected number of reads and traversals greatly outnumber the number of updates to a list.\r
\r
**ConcurrentMap** is a subinterface of \`java.util.Map\` con with atomic operations to add / replace existing key,value pairs or to add non existing key,value pairs. ConcurrentHashMap is the thread-safe version for HashMap.\r
\r
### Atomic variables\r
\r
Package \`java.util.concurrent.atomic\` contains a small toolkit of classes that support lock-free thread-safe programming on single variables. Instances of Atomic classes maintain values that are accessed and updated using methods otherwise available for fields using associated atomic VarHandle operations.\r
\r
Instances of classes AtomicBoolean, AtomicInteger, AtomicLong, and AtomicReference each provide access and updates to a single variable of the corresponding type. Each class also provides appropriate utility methods for that type. For example, classes AtomicLong and AtomicInteger provide atomic increment methods.\r
\r
## 3.4.3 Executors, Callables & Future\r
\r
Executors is an interface to manage thread pools. Thread pools manage a pool of worker threads. The thread pools contain a work queue which holds tasks waiting to get executed.\r
\r
A thread pool can be described as a collection of Runnable/Callable objects (work queue) and a connection of running threads.\r
\r
These threads are constantly running and are checking the work query for new work. If there is new work to be done they execute this Runnable/Callable.\r
\r
Here you can check an illustrative example on how to use Executors\r
\r
[Executors: Ejemplo supermercado](https://jarroba.com/multitarea-e-hilos-en-java-con-ejemplos-ii-runnable-executors/)\r
\r
We have used a Runnable object to define the tasks that are executed inside a thread. While defining tasks using Runnable is very convenient, it is limited by the fact that the tasks can not return a result.\r
\r
What if you want to return a result from your tasks?\r
\r
Well, Java provides a \`Callable\` interface to define tasks that return a result. A Callable is similar to Runnable except that it can return a result and throw a checked exception.\r
\r
Callable interface has a single method call() which is meant to contain the code that is executed by a thread.\r
\r
\`Future\` interface has methods to obtain the result generated by a Callable object and manage its state. It represents the result of an asynchronous computation.\r
\r
The result can only be retrieved using method get() when the computation has completed, blocking if necessary until it is ready.\r
`]},{title:"3.6 Annex III - ArrayList cheat sheet by students",headers:[{level:2,title:"A. Definici\xF3n y creaci\xF3n",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de ArrayList",slug:"a-1-constructores-de-arraylist",link:"#a-1-constructores-de-arraylist",children:[]}]},{level:2,title:"B. M\xE9todos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creaci\xF3n de un ArrayList",slug:"b-1-creacion-de-un-arraylist",link:"#b-1-creacion-de-un-arraylist",children:[]},{level:3,title:"B.2. A\xF1adir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si un elemento ya existe",slug:"b-3-comprobar-si-un-elemento-ya-existe",link:"#b-3-comprobar-si-un-elemento-ya-existe",children:[]},{level:3,title:"B.4. Acceder a un elemento del ArrayList",slug:"b-4-acceder-a-un-elemento-del-arraylist",link:"#b-4-acceder-a-un-elemento-del-arraylist",children:[]},{level:3,title:"B.5. Otras funciones de utilidad",slug:"b-5-otras-funciones-de-utilidad",link:"#b-5-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. A\xF1adir datos a un ArrayList",slug:"c-anadir-datos-a-un-arraylist",link:"#c-anadir-datos-a-un-arraylist",children:[{level:3,title:"C.1. A\xF1adir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. A\xF1adir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. A\xF1adir / eliminar elementos desde c\xF3digo",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la colecci\xF3n",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el m\xE9todo forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la colecci\xF3n",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. B\xFAsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. B\xFAsqueda usando los m\xE9todos de la clase",slug:"e-1-busqueda-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. B\xFAsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. B\xFAsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. B\xFAsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtenci\xF3n de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenaci\xF3n de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar usando m\xE9todos de Collection",slug:"g-1-ordenar-usando-metodos-de-collection",link:"#g-1-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.3. Ordenar con expresiones lambda",slug:"g-3-ordenar-con-expresiones-lambda",link:"#g-3-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.4. Ordenar con API Stream",slug:"g-4-ordenar-con-api-stream",link:"#g-4-ordenar-con-api-stream",children:[]}]}],path:"/en/unit3/arraylist_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.6 Annex III - ArrayList cheat sheet by students\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.6 Annex III - ArrayList cheat sheet by students" />\r
\r
# 3.6 Annex III - ArrayList cheat sheet by students\r
\r
::: info Autor\xEDa\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del m\xF3dulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la informaci\xF3n a la que podr\xE9is acceder durante los ex\xE1menes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definici\xF3n y creaci\xF3n\r
\r
Una colecci\xF3n representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almac\xE9n donde poder guardarlos. En Java, se emplea la interfaz gen\xE9rica \`Collection\` para este prop\xF3sito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de m\xE9todos comunes, como pueden ser: a\xF1adir, eliminar, obtener el tama\xF1o de la colecci\xF3n.\r
\r
Partiendo de la interfaz gen\xE9rica Collection extienden otra serie de interfaces gen\xE9ricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
La clase ArrayList en Java permite almacenar datos en memoria de forma similar a los Arrays con la ventaja de que el numero de elementos que almacena lo hace de forma din\xE1mica, es decir, que no es necesario declarar su tama\xF1o como pasa con los Arrays. Los elementos pueden a\xF1adirse o eliminarse seg\xFAn necesidad.\r
\r
### A.1. Constructores de ArrayList\r
\r
ArrayList proporciona 3 constructores que definen la capacidad inicial de la colecci\xF3n o si la inicializamos a partir de los valores de otra colecci\xF3n.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de ArrayList vac\xEDa.\r
ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\r
// ArrayList(int initialCapacity). Crea una instancia de ArrayList con una capacidad inicial especificada. \r
ArrayList<Persona> listaPersonas = new ArrayList<>(10);\r
\r
// ArrayList(Collection c). Crea una instancia de ArrayList a partir de otra colecci\xF3n de datos. Los datos se a\xF1aden en el orden en el que el Iterator de la otra colecci\xF3n los recorra.\r
ArrayList<Persona> listaPersonas = new ArrayList<>(c);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. M\xE9todos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendr\xEDamos con la ejecuci\xF3n de estos m\xE9todos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "Garc\xEDa", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Mart\xEDnez", 65, 1.84d, 82, "Hombre");\r
  Persona p3 = new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre");\r
  Persona p4 = new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer");\r
\`\`\`\r
\r
### B.1. Creaci\xF3n de un ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un ArrayList de Personas\r
  ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\`\`\`\r
\r
### B.2. A\xF1adir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // A\xF1adir un objeto Persona al final del ArrayList\r
  listaPersonas.add(p1);\r
\r
  // A\xF1ade el elemento al ArrayList en la posici\xF3n 'n+1'. \r
  // Cuidado, no podemos insertar en posiciones que no existen.\r
  listaPersonas.add(1, p1);\r
  \r
  // Borra el elemento de la posici\xF3n 'n+1' del ArrayList   \r
  // Cuidado, no podemos eliminar de posiciones que no existen.\r
  listaPersonas.remove(2);\r
\r
  // Borra el primer objeto pasado encontrado en el ArrayList que se le pasa como par\xE1metro.  \r
  listaPersonas.remove(p1);  \r
\`\`\`\r
\r
::: info Duplicados\r
Si ya existe un elemento en el ArrayList, esta colecci\xF3n no controla la existencia de duplicados, por lo que tendremos el mismo objeto en dos posiciones diferentes.\r
Podemos evitarlo comprobando previamente si ya existe ese objeto, como veremos a continuaci\xF3n.\r
:::\r
\r
### B.3. Comprobar si un elemento ya existe\r
\r
\`\`\`java:no-line-numbers\r
  // Comprueba si existe del objeto que se le pasa como par\xE1metro\r
  listaPersonas.contains(p4);\r
\r
  // Devuelve la posici\xF3n del primer objeto pasado encontrado en el ArrayList  \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.indexOf(p1);\r
\r
  // Devuelve la posici\xF3n del \xFAltimo objeto pasado en el ArrayList   \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### B.4. Acceder a un elemento del ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el elemento que esta en la posici\xF3n 'n+1' del ArrayList\r
  listaPersonas.get(2);\r
\`\`\`\r
\r
### B.5. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el numero de elementos del ArrayList\r
  listaPersonas.size();\r
\r
  //Borra todos los elementos de ArrayList   \r
  listaPersonas.clear();\r
\r
  // Devuelve true si el ArrayList esta vac\xEDo. Sino Devuelve false   \r
  listaPersonas.isEmpty();\r
\r
  // Pasa el ArrayList a un Array \r
  Object[] array = listaPersonas.toArray();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. A\xF1adir datos a un ArrayList\r
\r
::: info Orden de los elementos en un ArrayList\r
Cuando a\xF1adimos elementos a un ArrayList, el orden de inserci\xF3n se conserva.\r
\r
Una Lista, por definici\xF3n, siempre mantiene el orden de los elementos. Esto no es solo para ArrayList, sino para todo tipo de listas como LinkedList, Vector, y el resto de clases que implementan el interfaz \`java.util.List\` .\r
\r
:::\r
\r
### C.1. A\xF1adir elementos desde el constructor\r
\r
A la hora de crear el ArrayList, podemos a\xF1adirle datos, usando la sintaxis del doble corchete o bien con la construcci\xF3n List.of o Arrays.asList\r
\r
\`\`\`java:no-line-numbers\r
  // Crea una nueva lista y a la vez la inicializa con valores  \r
  ArrayList<Persona> lista1 = new ArrayList<>() {{\r
      add(p1);\r
      add(p2);\r
  }};\r
\r
  // En este caso indicamos los valores como si de par\xE1metros se tratase\r
  // De esta forma podemos a\xF1adir hasta un m\xE1ximo de 10 elementos\r
  ArrayList<Persona> lista2 = new ArrayList<>(\r
        List.of(p1, p2, p3)\r
  );\r
\r
  // De forma similar al caso anterior, con una construcci\xF3n a partir de un Array\r
  ArrayList<Persona> lista3 = new ArrayList<>(\r
        Arrays.asList(p1, p2, p3)\r
  );       \r
\`\`\`\r
\r
### C.2. A\xF1adir elementos desde otras colecciones\r
\r
Podemos inicializar un ArrayList, como hemos visto en los ejemplos anteriores, desde varios tipos de colecciones (listas) que poseen caracter\xEDsticas similares.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del c\xF3digo anterior, creamos un nuevo ArrayList a partir de lista2\r
  ArrayList<Persona> lista4 = new ArrayList<>(lista3);  \r
  \r
  // A\xF1ade todos los elementos de la lista que indiquemos como argumento al final del ArrayList\r
  lista4.addAll(lista3);\r
\r
  // Hace lo mismo, pero lo inserta en la posici\xF3n indicada (debe existir al menos la posici\xF3n anterior)  \r
  lista4.addAll(lista3,2);\r
\`\`\`\r
\r
### C.3. A\xF1adir / eliminar elementos desde c\xF3digo\r
\r
\`\`\`java:no-line-numbers\r
  // A\xF1adir un elemento al final de la lista\r
  lista4.add(p4);\r
  // A\xF1ade un elemento en la posici\xF3n indicada. El elemento que ocupaba esa posici\xF3n y todos los que hab\xEDa detr\xE1s, se mueven una posici\xF3n a la derecha.\r
  // En el ejemplo, inserta p1 al principio de la lista.\r
  lista4.add(0,p1);   // Inserta p1 al principio de la lista.\r
  \r
  // Eliminar un elemento. Si existe lo elimina y devuelve true, si no devuelve false\r
  boolean existe = lista4.remove(p1);  \r
  // Eliminar un elemento por \xEDndice. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = lista4.remove(2);  \r
  // Elimina del ArrayList todos aquellos elementos que coinciden con los indicados en la lista que pasamos como argumento \r
  lista4.removeAll(lista3);\r
  // Elimina del ArrayList todos aquellos elementos que cumplen con el predicado (la condici\xF3n) descrita como argumento en el m\xE9todo e indicada como expresi\xF3n lambda\r
  lista4.removeIf(p->p.getEdad()<18);   // Elimina los menores de 18\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la colecci\xF3n\r
\r
Vamos a preparar un ArrayList para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList creation\r
  ArrayList<Persona> grupoPersonas = new ArrayList<>() {{\r
    add(new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
    add(new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
    add(new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
    add(new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
    add(new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
    add(new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\r
\`\`\`\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por \xEDndice\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(i));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el ArrayList es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : colecci\xF3n)\r
\r
\`\`\`java:no-line-numbers\r
    // Obtenemos un objeto de tipo Persona en cada iteraci\xF3n del bucle\r
    for (Persona p: grupoPersonas) {\r
        System.out.println(p);\r
    }\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una colecci\xF3n y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un m\xE9todo iterator() que devuelve una instancia de Iterator para recorrer la colecci\xF3n.\r
\r
Iterator tiene 4 m\xE9todos:\r
\r
- **hasNext()** - devuelve true si hay un elemento m\xE1s en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el \xFAltimo elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la acci\xF3n indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la lista\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el m\xE9todo forEach con expresiones lambda\r
\r
En este caso aprovechamos el m\xE9todo foreach de las colecciones para poder realizar una acci\xF3n concreta sobre cada uno de los elementos de la misma.\r
\r
De forma similar al bucle foreach, indicamos un elemento de la lista y la acci\xF3n a realizar sobre el mismo\r
\r
\`\`\`java:no-line-numbers\r
  // Para cada persona (p) -> Acci\xF3n a realizar\r
  grupoPersonas.forEach(p -> System.out.println(p));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la colecci\xF3n\r
\r
Mientras se est\xE1 recorriendo una colecci\xF3n, no con todos los tipos de bucles se puede modificar (a\xF1adir/eliminar elementos) de la colecci\xF3n. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendr\xEDamos problemas. Al acceder por \xEDndice, podemos a\xF1adir o eliminar elementos mientras se recorre la colecci\xF3n.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.get(i).getNombre().equals("Jordi")) {\r
      grupoPersonas.remove(i);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, s\xF3lo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colecci\xF3n.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Persona p : grupoPersonas) {\r
    if (p.getPeso()>100) {\r
      grupoPersonas.remove(p);\r
    }\r
    System.out.println("Eliminada: " + p);\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Siempre que usemos el m\xE9todo remove de Iterator para eliminar elementos de la colecci\xF3n mientras la recorremos, podremos hacerlo sin que se genere ninguna excepci\xF3n.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Persona> iterator = grupoPersonas.iterator();\r
  while (iterator.hasNext()) {\r
    Persona p = iterator.next();\r
    if (p.getAltura() < 100) {\r
      // Si borramos usando iterator.remove funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el m\xE9todo forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, s\xF3lo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colecci\xF3n.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.forEach((p) -> {if (p.getNombre().equals("Jordi")) grupoPersonas.remove(p);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la colecci\xF3n, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. B\xFAsqueda de elementos\r
\r
Para buscar elementos en un ArrayList hay distintas formas de hacerlo. Desde los propios m\xE9todos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. B\xFAsqueda usando los m\xE9todos de la clase\r
\r
La clase ArrayList nos ofrece diferentes alternativas para buscar y/o saber si un elemento est\xE1 presente en la colecci\xF3n. As\xED, podemos usar los m\xE9todos\r
\r
\`\`\`java:no-line-numbers\r
  // Comprobar si est\xE1 el objeto en la colecci\xF3n\r
  boolean existe = grupoPersonas.contains(p1);\r
  // O simplemente obtener su posici\xF3n, si lo encuentra\r
  grupoPersonas.indexOf(p1);\r
  grupoPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### E.2. B\xFAsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la colecci\xF3n hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> it = grupoPersonas.iterator();\r
  while (it.hasNext()) {\r
    Persona p = it.next();\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado: " + p);\r
      break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. B\xFAsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber m\xE1s de un elemento que cumpla el criterio de b\xFAsqueda\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado:: " + p);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. B\xFAsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gesti\xF3n de las colecciones.\r
Podemos emplear varios m\xE9todos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcolecci\xF3n\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber m\xE1s de un elemento que cumpla el criterio de b\xFAsqueda\r
\r
  // Obtener un subarray con los elementos que cumplan el criterio\r
  grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList());\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);   \r
  }\r
\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cu\xE1ntos cumplen el criterio de b\xFAsqueda\r
  grupoPersonas.stream().filter(p -> p.getAltura() > 170).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Persona> first = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .findFirst();\r
\r
  // Obtener cualquiera que cumpla el criterio, o null si no hay ninguno\r
  Persona any = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)                \r
          .findAny()\r
          .orElse(null);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtenci\xF3n de subcolecciones\r
\r
Lo podemos considerar un tipo especial de b\xFAsqueda en el que el objetivo es conseguir una colecci\xF3n con los elementos que cumplan un determinado criterio.\r
\r
As\xED, la forma de buscar es id\xE9ntica a la del apartado anterior, pero en este caso lo que obtendremos de esa b\xFAsqueda ser\xE1 una nueva lista con un subconjunto de elementos de la original\r
\r
### F.1. Subcolecciones usando bucles\r
\r
Para obtener los elementos podemos aplicar lo aprendido en el anterior punto. Buscaremos elemento a elemento y, cuando se cumpla una condici\xF3n especificada, a\xF1adiremos los elementos encontrados a una nueva colecci\xF3n.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas = new ArrayList<>();\r
  for (Persona p : grupoPersonas) {\r
    if (p.getNombre().startsWith("M")) {\r
      personas.add(p);\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
La idea es similar al punto anterior\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas2 = new ArrayList<>();\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().startsWith("M")) {\r
      personas2.add(p);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener directamente una subcolecci\xF3n mediante el filtrado, haciendo subconjuntos y guardando el resultado.\r
\r
Con API Stream podemos guardar el resultado usando diferentes formas de .collect, que dar\xE1n como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList de Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas3 = (ArrayList<Persona>) grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toList());\r
\r
  // Conjunto de Personas cuyo nombre empieza por "M"\r
  Set<Persona> personas4 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toSet());\r
  \r
  // Mapa de Personas cuyo nombre empieza por "M"\r
  // En la construcci\xF3n del mapa, hay que elegir un campo que sirva de clave\r
  Map<String, Persona> personas5 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toMap(Persona::getApellidos, Function.identity()));\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenaci\xF3n de elementos\r
\r
### G.1. Ordenar usando m\xE9todos de Collection\r
\r
Si lo que queremos es tener el conjunto ordenados, la forma m\xE1s f\xE1cil es ordenarla usando el m\xE9todo sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Ordena seg\xFAn el m\xE9todo compareTo sobrescrito al implementar el interfaz Comparable\r
  // Si no se ha implementado, ordena seg\xFAn el orden natural\r
  Collections.sort(grupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(grupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su m\xE9todo \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos m\xE1s adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.3. Ordenar con expresiones lambda\r
\r
De esta forma no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparaci\xF3n que queremos hacer como par\xE1metro del m\xE9todo sort.\r
\r
As\xED podemos tener distintas formas de ordenar, seg\xFAn nos convenga.\r
\r
\`\`\`java:no-line-numbers\r
  // Indicamos la comparaci\xF3n que queremos hacer. Podemos usar compareTo \r
  Collections.sort(grupoPersonas, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(grupoPersonas);      \r
\r
  // o bien podemos definir nuestro propio comparador\r
  Collections.sort(grupoPersonas, (p1, p2) -> {\r
    String nombreCompleto1 = p1.getApellidos() + ", " + p1.getNombre();\r
    String nombreCompleto2 = p2.getApellidos() + ", " + p2.getNombre();\r
    return nombreCompleto1.compareTo(nombreCompleto2);\r
});\r
\`\`\`\r
\r
### G.4. Ordenar con API Stream\r
\r
Con API Stream usamos tambi\xE9n el m\xE9todo sorted para indicar qu\xE9 comparaci\xF3n se debe realizar. Tenemos varias opciones en funci\xF3n del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el m\xE1s flexible es aquel en el que indicamos, mediante una expresi\xF3n lambda, qu\xE9 comparaci\xF3n realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en una nueva lista con los elementos ordenados\r
  ArrayList<Persona> grupoPersonasOrdenado = (ArrayList<Persona>) grupoPersonas.stream()\r
          // En este caso ordenamos por apellido, ascendente.\r
          .sorted((p1, p2) -> p1.getApellidos().compareTo(p2.getApellidos()))\r
          // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
          //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
          .collect(Collectors.toList());\r
\`\`\`\r
\r
::: info Encadenar m\xE9todos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcolecci\xF3n con los resultados.\r
\r
Es lo m\xE1s parecido que vamos a encontrar a una consulta SQL para los datos de una colecci\xF3n cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instant\xE1neas, sin lugar a bugs, con muy poco c\xF3digo.\r
:::\r
`]},{title:"3.5 Annex I - Debugging multithread apps in Netbeans",headers:[],path:"/en/unit3/debugger_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.5 Annex I - Debugging multithread apps in Netbeans\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.5 Annex I - Debugging multithread apps in Netbeans" />\r
\r
# 3.5 Annex I - Debugging multithread apps in Netbeans\r
\r
Modern IDE provide the user with facilities to debug multithread apps.\r
\r
Just like in monothread apps, we can use breakpoints to stop a thread execution to inspect object state, properties values, etc.\r
\r
If we want to use the Debugging window in NetBeans IDE to debug multi-threaded applications we have to activate it by setting it from menu *Window > Debugging > Debugging (Alt+Shift +9)*\r
\r
![Activate thread debug](../../media/unit3/NetbeansDebug1.jpg)\r
\r
The Debugging window simplifies the debugging process by integrating into one window the information about debugging sessions, application threads and thread call stacks. The Debugging window enables you to easily see the status of application threads and suspend and resume any of the threads in the session.\r
\r
![Debugging dialogue](../../media/unit3/NetbeansDebug2.jpg)\r
\r
- The *current thread* is indicated by a green bar in the margin (it is also highlighted in green).  The current thread is the one we can work on by using StepInto, StepOver, Pause, Continue actions from the debugger. We can also access the variables inspection on that thread.\r
- Threads that invoked the notification, by hitting a breakpoint, are indicated by a yellow bar and the thread icon (orange color) indicates that the thread is suspended by a breakpoint.\r
- In the right side we have a quick access to Resume/Pause each active thread.\r
  \r
![Thread change](../../media/unit3/NetbeansDebug3.jpg)\r
\r
Clicking with the right mouse button over any thread we can make it the *current thread*. This way we get control over it and we can inspect this thread while other are paused or keep on running.\r
\r
![Estado de los hilos](../../media/unit3/NetbeansDebug4.jpg)\r
\r
Furthermore, the cogwheel next to each thread identifier is giving us many information about a thread state.\r
\r
- When the cogwheel is orange that means the thread is suspended and it requires our attention.\r
- When the cogwheel is green that means the thread is running. If we move the mouse over the thread we can get a tip showing the thread state information. As you can observe in the image thread-2 is running but it is in a waiting state. Actually this thread is locked in a join (waiting for another thread to finish)\r
\r
![Thread monitors](../../media/unit3/NetbeansDebug5.jpg)\r
\r
Finally, thread debugging helps us with synchronization using monitors. We can know when a thread owns a monitor (lock) and we can also know which monitors (locks) a thread is waiting for.\r
\r
As an additional tool Netbeans provides an utility (Debug > Check for deadlocks) that checks if any deadlock has happened, telling the monitors owned by each thread and the monitors each thread is waiting for.\r
`]},{title:"3.6 Annex II - HashMap cheat sheet by students",headers:[{level:2,title:"A. Definici\xF3n y creaci\xF3n",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de HashMap",slug:"a-1-constructores-de-hashmap",link:"#a-1-constructores-de-hashmap",children:[]}]},{level:2,title:"B. M\xE9todos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creaci\xF3n de un HashMap",slug:"b-1-creacion-de-un-hashmap",link:"#b-1-creacion-de-un-hashmap",children:[]},{level:3,title:"B.2. A\xF1adir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si una clave o un valor existen",slug:"b-3-comprobar-si-una-clave-o-un-valor-existen",link:"#b-3-comprobar-si-una-clave-o-un-valor-existen",children:[]},{level:3,title:"B.4. Acceder a las partes del mapa",slug:"b-4-acceder-a-las-partes-del-mapa",link:"#b-4-acceder-a-las-partes-del-mapa",children:[]},{level:3,title:"B.5. Acceder a un elemento del mapa",slug:"b-5-acceder-a-un-elemento-del-mapa",link:"#b-5-acceder-a-un-elemento-del-mapa",children:[]},{level:3,title:"B.6. Otras funciones de utilidad",slug:"b-6-otras-funciones-de-utilidad",link:"#b-6-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. A\xF1adir datos a un HashMap",slug:"c-anadir-datos-a-un-hashmap",link:"#c-anadir-datos-a-un-hashmap",children:[{level:3,title:"C.1. A\xF1adir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. A\xF1adir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. A\xF1adir / eliminar elementos desde c\xF3digo",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la colecci\xF3n",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el m\xE9todo forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la colecci\xF3n",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. B\xFAsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. B\xFAsqueda por clave o usando los m\xE9todos de la clase",slug:"e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. B\xFAsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. B\xFAsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. B\xFAsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtenci\xF3n de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenaci\xF3n de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar por clave",slug:"g-1-ordenar-por-clave",link:"#g-1-ordenar-por-clave",children:[]},{level:3,title:"G.2. Ordenar usando m\xE9todos de Collection",slug:"g-2-ordenar-usando-metodos-de-collection",link:"#g-2-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.3. Ordenar con expresiones lambda",slug:"g-3-ordenar-con-expresiones-lambda",link:"#g-3-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.4. Ordenar con API Stream",slug:"g-4-ordenar-con-api-stream",link:"#g-4-ordenar-con-api-stream",children:[]}]}],path:"/en/unit3/hashmap_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.6 Annex II - HashMap cheat sheet by students\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.6 Annex II - HashMap cheat sheet by students" />\r
\r
# 3.6 Annex II - HashMap cheat sheet by students\r
\r
::: info Autor\xEDa\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del m\xF3dulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la informaci\xF3n a la que podr\xE9is acceder durante los ex\xE1menes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definici\xF3n y creaci\xF3n\r
\r
Una colecci\xF3n representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almac\xE9n donde poder guardarlos. En Java, se emplea la interfaz gen\xE9rica \`Collection\` para este prop\xF3sito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de m\xE9todos comunes, como pueden ser: a\xF1adir, eliminar, obtener el tama\xF1o de la colecci\xF3n.\r
\r
Partiendo de la interfaz gen\xE9rica Collection extienden otra serie de interfaces gen\xE9ricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
Un HashMap b\xE1sicamente designa claves \xFAnicas para los valores correspondientes que se pueden recuperar en cualquier punto dado, es decir, nos permite almacenar elementos asociando a cada clave un valor.\r
\r
Para cada clave tenemos un valor asociado. Podemos despu\xE9s buscar f\xE1cilmente un valor para una determinada clave. Las claves en el diccionario no pueden repetirse.\r
\r
### A.1. Constructores de HashMap\r
\r
HashMap proporciona 4 constructores que definen la capacidad inicial de la colecci\xF3n y en qu\xE9 momento debe redimensionarse. Son par\xE1metros para mejorar el rendimiento en el uso del HashMap.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de HashMap con una capacidad inicial de 16 y un factor de carga de 0,75.\r
HashMap<Integer, String> hm1 = new HashMap<>(); \r
\r
// HashMap(int initialCapacity). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga de 0,75. \r
HashMap<Integer, String> hm1 = new HashMap<>(10); \r
\r
// HashMap(int initialCapacity, float loadFactor). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga especificados. \r
HashMap<Integer, String> hm1 = new HashMap<>(5, 0.75f); \r
\r
//HashMap(Mapa de mapas) . Crea una instancia de HashMap con las mismas asignaciones que el mapa especificado. \r
HashMap<Integer, String> hm1 = new HashMap<>();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. M\xE9todos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendr\xEDamos con la ejecuci\xF3n de estos m\xE9todos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "Garc\xEDa", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Mart\xEDnez", 65, 1.84d, 82, "Hombre");\r
\`\`\`\r
\r
### B.1. Creaci\xF3n de un HashMap\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un HashMap con claves de tipo String y valores de tipo Persona\r
  HashMap<String,Persona> DNIs = new HashMap<>();\r
\`\`\`\r
\r
### B.2. A\xF1adir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // Element.put(k,v) - A\xF1ade un par clave-valor al mapa.\r
  DNIs.put("390543M",p);\r
  // Element.remove(Object key) - Removes the key and his value.\r
  DNIs.remove("298423Z");// Will remove (\u201C390543M\u201D, p1) from the map.\r
\`\`\`\r
\r
::: warning Clave ya existente\r
Si ya existe un elemento con la misma clave en el mapa, el m\xE9todo put reemplaza el valor existente por el nuevo.\r
Podemos evitarlo comprobando previamente si ya existe esa clave o con el m\xE9todo **DNIs.putIfAbsent(k,v)**.\r
:::\r
\r
### B.3. Comprobar si una clave o un valor existen\r
\r
\`\`\`java:no-line-numbers\r
  // Element.containsKey(Key) \u2013 Comprueba si existe la clave dada\r
  DNIs.containsKey("390543M");\r
  // Element.containsValue(Value) \u2013 Comprueba si existe el valor dado asociado a alguna clave\r
  DNIs.containsValue(p2);\r
\`\`\`\r
\r
### B.4. Acceder a las partes del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.keySet() - Obtiene el conjunto de claves del mapa\r
  Set<String> claves = DNIs.keySet();\r
  // Element.values() - Obtiene el conjunto de valores almacenados en el mapa\r
  Collection<Persona> valores = DNIs.values();\r
  // Element.entrySet() - Obtiene el conjunto de pares clave-valor del mapa\r
  Set<Entry<String,Persona>> tuplas = DNIs.entrySet();\r
\`\`\`\r
\r
### B.5. Acceder a un elemento del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.get(Key) - Obtiene el valor asociado a la clave\r
  Persona p = DNIs.get("390543")\r
\`\`\`\r
\r
### B.6. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Element.size() - Devuelve el n\xFAmero de elementos en el mapa\r
  int size = DNIs.size();\r
  //Element.clear() - Elimina todas las asignaciones y vac\xEDa el mapa\r
  DNIs.clear();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. A\xF1adir datos a un HashMap\r
\r
::: info Orden de los elementos en el HashMap\r
Cuando a\xF1adimos elementos a una HashMap, el orden de inserci\xF3n no se conserva. Internamente, para cada elemento, se genera un hash separado y los elementos se indexan en funci\xF3n de este hash para hacerlo m\xE1s eficiente. Antes de a\xF1adir un elemento, como se ha avisado antes, es recomendable comprobar si ya existe para no sustituirlo\r
:::\r
\r
### C.1. A\xF1adir elementos desde el constructor\r
\r
A la hora de crear el Hashmap, podemos a\xF1adirle datos, usando la sintaxis del doble corchete o bien con la construcci\xF3n Map.of\r
\r
\`\`\`java:no-line-numbers\r
  // Crea un nuevo mapa y a la vez lo inicializa con valores  \r
  HashMap<String, Persona> map1 = new HashMap<>() {{\r
    put("390543M", p1);\r
    put("298423Z", p2);\r
  }};\r
  // En este caso indicamos los pares clave valor como si de un array se tratase\r
  // De esta forma podemos a\xF1adir hasta un m\xE1ximo de 10 elementos\r
  HashMap<String, Persona> map2 = new HashMap<>(\r
    Map.of("390543M", p1, "298423Z", p2)\r
  );\r
\`\`\`\r
\r
### C.2. A\xF1adir elementos desde otras colecciones\r
\r
Al ser una colecci\xF3n compuesta por una clave y un valor, la inicializaci\xF3n se limita a los tipos de colecciones que tienen una estructura similar.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del c\xF3digo anterior, creamos un nuevo mapa a partir de map2\r
  HashMap<String, Persona> map3 = new HashMap<>(map2);\r
  // O bien copiando todos los pares clave-valor\r
  map3.putAll(map2);  \r
\`\`\`\r
\r
### C.3. A\xF1adir / eliminar elementos desde c\xF3digo\r
\r
\`\`\`java:no-line-numbers\r
  // A\xF1adir y si existe la clave reemplazarlo\r
  DNIs.put("390543M", p1);\r
  // A\xF1adir s\xF3lo si la clave no existe\r
  DNIs.putIfAbsent("390543M", p1);\r
  // Eliminar un elemento. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = map3.remove("390543M");  \r
  // Eliminar un par clave-valor. Si existe la tupla, la elimina y devuelve true, si no devuelve false\r
  boolean existe = map3.remove("390543M", p1);  \r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la colecci\xF3n\r
\r
Vamos a preparar un HashMap para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap creation\r
  HashMap<String, Persona> grupoPersonas = new HashMap<>() {{\r
          put("12345678A", new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
          put("23456789B", new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
          put("34567890C", new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
          put("45678901D", new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
          put("56789012E", new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
          put("67890123F", new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\`\`\`\r
\r
::: info Tipos de valores\r
Vamos a mostrar ejemplos de c\xF3mo recorrer cada uno de los elementos que componen el HashMap, claves, valores y pares clave-valor.\r
\r
.entrySet() - devuelve el conjunto de pares clave-valor\r
\r
.keySet() - devuelve el conjunto de claves\r
\r
.values() - devuelve la colecci\xF3n de valores\r
:::\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por \xEDndice, por lo que vamos a necesitar una forma de obtener el \xEDndice (i) de cada elemento para recorrer el HashMap.\r
\r
En este caso, vamos a usar el \xEDndice de la clave, a trav\xE9s del m\xE9todo toArray.\r
\r
::: warning Orden de los elementos en el HashMap\r
Es importante recordar y tener en cuenta que los elementos en un HashMap se ordenan autom\xE1ticamente en base a una funci\xF3n Hash (resumen) que permite realizar una b\xFAsqueda muy r\xE1pida sobre la clave. Por lo tanto, no podemos esperar que el recorrido por \xEDndice coincida con el orden en el que los elementos se a\xF1aden al mapa.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(map.keySet().toArray()[i]));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el HashMap es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : colecci\xF3n)\r
\r
\`\`\`java:no-line-numbers\r
  // Recorremos la estructura obteniendo la tupla (k,v) en cada iteraci\xF3n\r
  for (Map.Entry<String, Persona> entry : grupoPersonas.entrySet()) {\r
        System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());\r
  }\r
\`\`\`\r
\r
o bien para ir mostrando las claves\r
\r
\`\`\`java:no-line-numbers\r
  for (String key : grupoPersonas.keySet()) {\r
    System.out.println("DNI = " + key);\r
  }\r
\`\`\`\r
\r
o los valores\r
\r
\`\`\`java:no-line-numbers\r
  for (Person value : grupoPersonas.values()) {\r
    System.out.println("Value = " + value);\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una colecci\xF3n y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un m\xE9todo iterator() que devuelve una instancia de Iterator para recorrer la colecci\xF3n.\r
\r
Iterator tiene 4 m\xE9todos:\r
\r
- **hasNext()** - devuelve true si hay un elemento m\xE1s en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el \xFAltimo elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la acci\xF3n indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la colecci\xF3n\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.values().iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el m\xE9todo forEach con expresiones lambda\r
\r
En este caso aprovechamos el m\xE9todo foreach de las colecciones para poder realizar una acci\xF3n concreta sobre cada uno de los elementos de la misma\r
\r
\`\`\`java:no-line-numbers\r
  // Pares (clave,valor)\r
  grupoPersonas.forEach((k,v) -> System.out.println("Clave: " + k + ", Values: " + v));\r
  // Claves\r
  grupoPersonas.keySet().forEach(k -> System.out.println("Clave: " + k));\r
  // Valores\r
  grupoPersonas.values().forEach(v -> System.out.println("Values: " + v));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la colecci\xF3n\r
\r
Mientras se est\xE1 recorriendo una colecci\xF3n, no con todos los tipos de bucles se puede modificar (a\xF1adir/eliminar elementos) de la colecci\xF3n. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendr\xEDamos problemas. Al acceder por \xEDndice, podemos a\xF1adir o eliminar elementos mientras se recorre la colecci\xF3n.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.keySet().toArray()[i].equals("23456789B")) {\r
      grupoPersonas.remove(grupoPersonas.entrySet().toArray()[i]);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, s\xF3lo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colecci\xF3n.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Map.Entry<String, Persona> p : grupoPersonas.entrySet()) {\r
    if (p.getKey().equals("34567890C")) {\r
      personas.remove(p.getKey());\r
    }\r
    System.out.println("Clave: " + p.getKey() + " Valor: " + p.getValue().toString());\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Si usamos el m\xE9todo remove para eliminar elementos de la colecci\xF3n mientras la recorremos, podremos hacerlo sin que se genere ninguna excepci\xF3n.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Entry<String, Persona>> iterator = grupoPersonas.entrySet().iterator();\r
  while (iterator .hasNext()) {\r
    Map.Entry<String, Persona> p = (Map.Entry<String, Persona>) iterator.next();\r
    if (p.getKey().equals("12345678A")) {\r
      // Si borramos usando iterator.remove o el m\xE9todo remove(key) de HashMap, funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el m\xE9todo forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, s\xF3lo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colecci\xF3n.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.keySet().forEach((k) -> {if (k.equals("34567890C")) grupoPersonas.remove(k);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la colecci\xF3n, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.values().forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. B\xFAsqueda de elementos\r
\r
Para buscar elementos en un HashMap hay distintas formas de hacerlo. Desde los propios m\xE9todos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. B\xFAsqueda por clave o usando los m\xE9todos de la clase\r
\r
La clase HashMap nos ofrece diferentes alternativas para buscar y/o saber si un elemento est\xE1 presente en la colecci\xF3n. As\xED, podemos usar los m\xE9todos\r
\r
\`\`\`java:no-line-numbers\r
  // A partir de una clave, obtener el valor\r
  grupoPersonas.get("34567890C");\r
  // O simplemente comprobar si existe esa clave o ese valor antes de buscarlo\r
  grupoPersonas.containsKey("34567890C");\r
  grupoPersonas.containsValue(person);\r
\`\`\`\r
\r
### E.2. B\xFAsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la colecci\xF3n hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber m\xE1s de un elemento que cumpla el criterio de b\xFAsqueda\r
  Iterator<Map.Entry<String, Persona>> it = grupoPersonas.entrySet().iterator();\r
  while (it.hasNext()) {\r
    Map.Entry<String, Persona> entry = it.next();\r
    if (((Persona)entry.getValue()).getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + entry.getKey() + ", Value: " +\r
      entry.getValue());\r
    break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. B\xFAsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber m\xE1s de un elemento que cumpla el criterio de b\xFAsqueda\r
  grupoPersonas.forEach((k, v) -> {\r
    if (v.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + k + ", Value: " + v);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. B\xFAsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gesti\xF3n de las colecciones.\r
Podemos emplear varios m\xE9todos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcolecci\xF3n\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber m\xE1s de un elemento que cumpla el criterio de b\xFAsqueda\r
\r
  // Obtener un submapa con los elementos que cumplan el criterio\r
  grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("abc"))\r
    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Entry<String, Persona> p : grupoPersonas.entrySet().stream()\r
      .filter(k -> k.getKey().equals("abc"))\r
      .collect(Collectors.toList())) {\r
          System.out.println(p.getValue());   // Sacamos el valor de la tupla <clave,valor>\r
  }\r
\r
  for (Persona p : grupoPersonas.entrySet().stream()\r
      .filter((k) -> k.getKey().equals("98761234D"))\r
      .map(Map.Entry::getValue)         // Cogemos s\xF3lo los valores del entryMap\r
      .collect(Collectors.toList())) {\r
          System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cu\xE1ntos cumplen el criterio de b\xFAsqueda\r
  grupoPersonas.entrySet().stream().filter(k -> k.getKey().equals("abc")).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Entry<String,Persona>> s = grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("6780123F"))\r
    .findFirst();\r
  \`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtenci\xF3n de subcolecciones\r
\r
Lo podemos considerar un tipo especial de b\xFAsqueda en el que el objetivo es conseguir una colecci\xF3n con los elementos que cumplan un determinado criterio.\r
\r
As\xED, la forma de buscar es id\xE9ntica a la del apartado anterior, pero en este caso lo que obtendremos de esa b\xFAsqueda ser\xE1 un nuevo tipo de colecci\xF3n, no necesariamente otro HashMap.\r
\r
### F.1. Subcolecciones usando bucles\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String,Persona> personas2 = new HashMap<String,Persona>();\r
  for (Entry<String, Persona> e : grupoPersonas.entrySet()) {\r
    if(e.getKey().endsWith("F")) {\r
      personas2.put(e.getKey(), e.getValue());\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
En este ejemplo obtenemos un nuevo HashMap, pero tambi\xE9n podr\xEDamos guardar la informaci\xF3n en un ArrayList o en cualquier otro tipo de estructura.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas2 = new HashMap<String, Persona>();\r
  grupoPersonas.forEach((k, v) -> {\r
    if (k.endsWith("F")) {\r
      grupoPersonas2.put(k, v);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener diferentes tipos de subcolecciones. Con API Stream podemos filtrar, hacer subconjuntos y guardar el resultado usando diferentes formas de .collect, que dar\xE1n como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap de Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas3 = (HashMap<String, Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // Lista de Personas cuyo DNI acaba en "F"\r
  List<Persona> listaPersonas3 = (List<Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toList());\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenaci\xF3n de elementos\r
\r
::: danger HashMap no garantiza el orden de los elementos\r
Como ya hemos comentado anteriormente, un HashMap es una estructura de datos en la que el orden de los elementos no est\xE1 garantizado. Es por eso que si queremos mantener una copia ordenada de los elementos, deberemos recurrir a otros tipos de colecciones que s\xED garantizan el orden.\r
:::\r
\r
### G.1. Ordenar por clave\r
\r
Hay un tipo especial de map, TreeMap, en el que los elementos se ordenan siguiendo el orden natural de las claves. Por lo tanto es la opci\xF3n ideal si queremos tener los elementos ordenados por clave.\r
\r
\`\`\`java:no-line-numbers\r
  // As\xED podemos recorrer el TreeMap y mostrar los elementos ordenados por clave\r
  TreeMap<String, Persona> grupoPersonasOrdenado = new TreeMap<>(grupoPersonas);\r
 \r
  Iterator it=grupoPersonasOrdenado.keySet().iterator();\r
  while(it.hasNext())\r
  {\r
    int key=(int)itr.next();\r
    System.out.println("Key: "+key+" Element: "+hashMap.get(key));\r
  }\r
\`\`\`\r
\r
### G.2. Ordenar usando m\xE9todos de Collection\r
\r
Si lo que queremos es tener el conjunto de claves o valores ordenados por separado, la forma m\xE1s f\xE1cil es obtener una lista y ordenarla usando el m\xE9todo sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Para las claves\r
  List<String> clavesGrupoPersonas = new ArrayList<>(grupoPersonas.keySet());\r
  Collections.sort(clavesGrupoPersonas);\r
\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas = new ArrayList<>(grupoPersonas.values());\r
  // Ordena seg\xFAn el m\xE9todo compareTo sobrescrito al implementar el interfaz Comparable\r
  Collections.sort(valoresGrupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(valoresGrupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su m\xE9todo \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos m\xE1s adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.3. Ordenar con expresiones lambda\r
\r
Si usamos una lista, no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparaci\xF3n que queremos hacer como par\xE1metro del m\xE9todo sort\r
\r
\`\`\`java:no-line-numbers\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas2 = new ArrayList<>(grupoPersonas.values());\r
  // Indicamos la comparaci\xF3n que queremos hacer. Podemos usar compareTo o definir\r
  // nuestro propio comparador\r
  Collections.sort(valoresGrupoPersonas2, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(valoresGrupoPersonas2);      \r
\`\`\`\r
\r
### G.4. Ordenar con API Stream\r
\r
Con API Stream usamos tambi\xE9n el m\xE9todo sorted para indicar qu\xE9 comparaci\xF3n se debe realizar. Tenemos varias opciones en funci\xF3n del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el m\xE1s flexible es aquel en el que indicamos, mediante una expresi\xF3n lambda qu\xE9 comparaci\xF3n realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en un LinkedHashMap que s\xED garantiza el orden\r
  Map<String, Persona> sortedMap = grupoPersonas.entrySet().stream()\r
      // En este caso ordenamos por apellido, ascendente.\r
      .sorted((e1, e2) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
      //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      .collect(Collectors.toMap(Entry::getKey, Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));\r
\`\`\`\r
\r
::: info Encadenar m\xE9todos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcolecci\xF3n con los resultados.\r
\r
Es lo m\xE1s parecido que vamos a encontrar a una consulta SQL para los datos de una colecci\xF3n cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instant\xE1neas, sin lugar a bugs, con muy poco c\xF3digo.\r
:::\r
`]},{title:"3 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit3/",pathLocale:"/en/",extraFields:[`---\r
title: 3 Introduction\r
---\r
\r
# Unit 3. Multithread programming\r
\r
After leaning the basics of concurrent programming and learn how processes can be used to do multitasking, in this unit we are going to look into a single process.\r
\r
We are gonna make use of threads and the eay they are programmed to do concurrent task into a process.\r
\r
key differences between processes and threads are:\r
\r
- Threads share process memory space\r
- Threads share file descriptors\r
- Threads share program code.\r
\r
As they run into the context of a process, the TCB (Tread Control Block) is smaller than the PCB (Process Control Block) because they share part of PCB. That's why sometimes threads are so called \`lightweight processes\`.\r
\r
All previous features simplify threads communication, thus coordination and synchronization becomes harder to program and manage.\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To know thread characteristics in Java\r
- To Learn how to create and manage threads\r
- To debug multithread applications\r
- To use synchronization methods for processes and sub-processes\r
- To share information between threads on a process\r
- To learn about shared memory problems\r
- To use different programming approaches to synchronize threads execution\r
`]},{title:"3.3 Producer-Consumer model",headers:[{level:2,title:"3.3.1. Communication & synchronization template",slug:"_3-3-1-communication-synchronization-template",link:"#_3-3-1-communication-synchronization-template",children:[]},{level:2,title:"3.3.2 Main class",slug:"_3-3-2-main-class",link:"#_3-3-2-main-class",children:[]},{level:2,title:"3.3.3 Producer & Consumer classes",slug:"_3-3-3-producer-consumer-classes",link:"#_3-3-3-producer-consumer-classes",children:[]},{level:2,title:"3.3.4 Shared class. Threads synchronization",slug:"_3-3-4-shared-class-threads-synchronization",link:"#_3-3-4-shared-class-threads-synchronization",children:[]}],path:"/en/unit3/producer-consumer.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.3 Producer-Consumer model\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.3 Producer-Consumer model" />\r
\r
# 3.3 Producer-Consumer model\r
\r
[[toc]]\r
\r
## 3.3.1. Communication & synchronization template\r
\r
Threads synchronization means having tools to avoid \`starvation\` (threads lock), \`deadlocks\` (when a condition can never be satisfied) and to ensure shared resources are well managed by concurrent threads access.\r
\r
The Producer-Consumer problem is a classic example of a multi-threaded synchronization problem. Let's go into the usage of the shared resources by using this famous algorithm. [Wikipedia](https://es.wikipedia.org/wiki/Problema_productor-consumidor).\r
\r
Without thread control mechanism we already know that problems will rise up randomly:\r
\r
- Consumer can get elements more than once, exceeding the stock (banc account balance under 0, reader reading a book before it is finished).\r
- Producers can be quicker than Consumer and produce more information than the system can get, making data loose.- Consumer can be quicker than the Producer and can get more than once the same value, having inconsistent systems.\r
\r
That's all we know as \`race conditions\`.\r
\r
The following code template repeats over and over again for almos all activities we are going to work on. That's what we call the Producer-Consumer model.\r
\r
![Producer-Consumer](./../../media/unit3/ProducerConsumer.png)\r
\r
This model is based on three classes, but depending on the problem we can have only producers or just consumers.\r
\r
::: info Model as a design pattern\r
It's very important to fit our code into the model schema\r
\r
This is like a puzzle where we have to adjust the problem solution. Sometimes we won't have a producer, other there will be no consumer. Maybe we will use the wait condition only in one of them.\r
\r
We shouldn't add or modify the way the schema is presented, all parts must fit into the given model.\r
:::\r
\r
## 3.3.2 Main class\r
\r
> Main class will always have the same estructure. Following code can be used as a a template.\r
\r
Here we instantiate the shared object to be used by producers&consumers. This is the object that will hold communication, synchronization and information exchange between threads.\r
\r
In this example it is an object, but we can use a Collection or any other data structure useful for thread to share information and synchronize.\r
\r
\`\`\` java {4,5,6}\r
public class ClasePrincipal { \r
\r
    public static void main(String[] args) {    \r
        ClaseCompartida objetoCompartido = new ObjetoCompartido();\r
        Productor p  = new Productor(objetoCompartido);\r
        Consumidor c  = new Consumidor(objetoCompartido);\r
        productor.start();\r
        consumidor.start();\r
\r
        // No es obligatorio, pero en ocasiones puede interesar que la ClasePrincipal\r
        // espere a que acaben los hilos\r
        productor.join();\r
        consumidor.join();\r
\r
        // Acciones a realizar una vez hayan acabado el productor y el consumidor\r
    }\r
    \r
}\r
\`\`\`\r
\r
::: warning Number of producer & consumer threads\r
In the previous code we have created and launched one of each, but it has not to be like that.\r
\r
Each problem to solve will need a different number of *Producers* and *Consumers*, that will be instantiated and launched in the main method or in any other complementary method in the class in charge of thread management.\r
\r
In the same way, it's on the problem if the main thread has to wait for the others to finish or not.\r
:::\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.3 Producer & Consumer classes\r
\r
> Both **Producer** and **Consumer** classes will call methods in the shared object.\r
\r
In both classes, the application logic will be developed inside **run** method. This will be done basically accessing the shared object, calling its synchronized methods, modifying its properties and updating the object state to control its functionality.\r
\r
\`\`\` java {2,5,15}\r
public class Consumidor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Consumidor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecuci\xF3n del m\xE9todo run estar\xE1 normalmente gestionada por un bucle\r
        // que controlar\xE1 el ciclo de vida del hilo y se adaptar\xE1 al problema.\r
        // En el caso de simulaciones se har\xE1n esperas proporcionales.\r
        try {\r
            // C\xF3digo que hace el hilo consumidor\r
            objetoCompartido.accionDeConsumir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
}    \r
\`\`\`\r
\r
\`\`\` java {2,5,15}\r
public class Productor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Productor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecuci\xF3n del m\xE9todo run estar\xE1 normalmente gestionada por un bucle\r
        // que controlar\xE1 el ciclo de vida del hilo y se adaptar\xE1 al problema.\r
        // En el caso de simulaciones se har\xE1n esperas proporcionales.\r
        try {\r
            // C\xF3digo que hace el hilo productor\r
            objetoCompartido.accionDeProducir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
} \r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.4 Shared class. Threads synchronization\r
\r
 This model is completed with the shared object class. Here we provide methods to be used by both Producers and Consumers. Furthermore, this class must be thread-safe to avoid \`race conditions\`.\r
\r
\`\`\` java {2,9,11,14,21,25,28,30,33,40,44}\r
class ClaseCompartida {\r
    int valorAccedidoSimultaneamente;\r
    \r
    ClaseCompartida() {\r
        // Se inicializa el valor\r
        this.valorAccedidoSimultaneamente = 0;\r
    }\r
\r
    public synchronized void accionDeConsumir() {\r
        // Si no se cumple la condici\xF3n para poder consumir, el consumidor debe esperar\r
        while (valorAccedidoSimultaneamente() == 0) {\r
            try {\r
                System.out.println("Consumidor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizar\xE1 la gesti\xF3n de la Interrupci\xF3n\r
            }\r
        }\r
                \r
        // Cuando se ha cumplido la condici\xF3n para consumir, el consumidor consume\r
        valorAccedidoSimultaneamente--;\r
        System.out.printf("Se ha consumido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
    \r
    public synchronized void accionDeProducir () {\r
        // Si no se cumple la condici\xF3n para poder producir, el productor debe esperar\r
        while (valorAccedidoSimultaneamente() > 10) {\r
            try {\r
                System.out.println("Productor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizar\xE1 la gesti\xF3n de la Interrupci\xF3n                \r
            }\r
        }\r
        \r
        // Cuando se ha cumplido la condici\xF3n para producir, el productor produce\r
        valorAccedidoSimultaneamente++;\r
        System.out.printf("Se ha producido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
\`\`\`\r
\r
What's interesting from above code is the pair  \`wait / notifyAll\` together with the \`synchronized\` modifier.\r
\r
- A call to a **synchronized** method makes it be run if and only if there is no other thread running another **synchronized** method \`for the same object instance\`. If that happens the thread trying to access the synchronized block will be locked until another thread leaves the synchronized block. Then one random thread is chosen from the threads waiting for the monitor and then it owns the monitor and runs the synchronized block.\r
- Simply put, calling **wait()** forces the current thread to wait until some other thread invokes **notify()** or **notifyAll()** on the same object. For this, the current thread must own the object's monitor, because the monitor will be released after the wait call. \r
- We use the **notify/notifyAll** methods for waking up threads that have previously made a wait() call for this monitos. All awaken threads are automatically sent onto the monitor queue together with all threads already waiting to own the monitor. All threads, once the monitor is owned by them, will start running the synchronized code o will continue running the next sentence after the wait call.\r
\r
> With **wait**, **notifyAll** methods and **synchronized** code blocks we can avoid concurrent threads to modify a shared variable. *(lines 21 and 40 from previous code)*.\r
\r
::: info Producer-Consumer model summary\r
Original Producer-Consumer works with a buffer where the Producer puts information and the Consumer gets it from the buffer. The buffer can never be overflown and it cannot be read if it is empty.\r
\r
Our example has been simplified by using a int variable that has to be always in the range [0.10]\r
\r
This variables can be of any type and the class code will be different depending on it. It must be valid for the problem and the data type control.\r
\r
Finally, conditions or states added for waiting and updates will be what us, as programmers, must code in order to make it work as specified by problems requirements.\r
:::\r
`]},{title:"3.1 Java classes for threads",headers:[{level:2,title:"3.1.1. Runnable Interface",slug:"_3-1-1-runnable-interface",link:"#_3-1-1-runnable-interface",children:[{level:3,title:"Java Class Implements Runnable",slug:"java-class-implements-runnable",link:"#java-class-implements-runnable",children:[]},{level:3,title:"Anonymous Implementation of Runnable",slug:"anonymous-implementation-of-runnable",link:"#anonymous-implementation-of-runnable",children:[]},{level:3,title:"Java Lambda Implementation of Runnable",slug:"java-lambda-implementation-of-runnable",link:"#java-lambda-implementation-of-runnable",children:[]},{level:3,title:"Calling the run method on a Runnable class",slug:"calling-the-run-method-on-a-runnable-class",link:"#calling-the-run-method-on-a-runnable-class",children:[]}]},{level:2,title:"3.1.2 Thread subclass",slug:"_3-1-2-thread-subclass",link:"#_3-1-2-thread-subclass",children:[]},{level:2,title:"3.1.3 Starting a Thread from a Runnable",slug:"_3-1-3-starting-a-thread-from-a-runnable",link:"#_3-1-3-starting-a-thread-from-a-runnable",children:[{level:3,title:"Subclass or Runnable?",slug:"subclass-or-runnable",link:"#subclass-or-runnable",children:[]}]},{level:2,title:"3.1.4 Thread class methods",slug:"_3-1-4-thread-class-methods",link:"#_3-1-4-thread-class-methods",children:[{level:3,title:"Pause a thread",slug:"pause-a-thread",link:"#pause-a-thread",children:[]},{level:3,title:"Threads priority management",slug:"threads-priority-management",link:"#threads-priority-management",children:[]}]}],path:"/en/unit3/runnable.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.1 Java classes for threads\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.1. Java classes for threads" />\r
\r
# 3.1. Java classes for threads\r
\r
[[toc]]\r
\r
## 3.1.1. Runnable Interface\r
\r
A Java Thread can execute your Java code inside your Java application.\r
\r
When a Java application is started its main() method is executed by the main thread - a special thread that is created by the Java VM to run your application. From inside your application you can create and start more threads which can execute parts of your application code in parallel with the main thread.\r
\r
Java threads are objects like any other Java objects. Threads are instances of class java.lang.Thread, or instances of subclasses of this class. In addition to being objects, java threads can also execute code.\r
\r
The first way to specify what code a thread should run is by creating a class that implements the \`java.lang.Runnable\` interface.\r
\r
The Runnable interface is a standard Java Interface that comes with the Java platform. The Runnable interface only has a single method run().\r
\r
> [java.lang.Runnable specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html)\r
\r
Whatever the thread is supposed to do when it executes must be included in the implementation of the run() method. There are three ways to implement the Runnable interface:\r
\r
- Create a Java class that implements the Runnable interface.\r
- Create an anonymous class that implements the Runnable interface.\r
- Create a Java Lambda that implements the Runnable interface.\r
\r
All three options are explained in the following sections.\r
\r
### Java Class Implements Runnable\r
\r
The first way to implement the Java Runnable interface is by creating your own Java class that implements the Runnable interface. Here is an example of a custom Java class that implements the Runnable interface:\r
\r
\`\`\`java\r
public class MyRunnable implements Runnable {\r
\r
  public void run(){\r
      System.out.println("MyRunnable running");\r
  }\r
}\r
\`\`\`\r
\r
All this Runnable implementation does is to print out the text MyRunnable running. After printing that text, the run() method exits, and the thread running the run() method will stop.\r
\r
### Anonymous Implementation of Runnable\r
\r
You can also create an anonymous implementation of Runnable. Here is an example of an anonymous Java class that implements the Runnable interface:\r
\r
\`\`\`java\r
Runnable myRunnable =\r
    new Runnable(){\r
        public void run(){\r
            System.out.println("Runnable running");\r
        }\r
    }\r
\`\`\`\r
\r
Apart from being an anonymous class, this example is quite similar to the example that used a custom class to implement the Runnable interface.\r
\r
### Java Lambda Implementation of Runnable\r
\r
The third way to implement the Runnable interface is by creating a Java Lambda implementation of the Runnable interface. This is possible because the Runnable interface only has a single unimplemented method, and is therefore practically (although possibly unintentionally) a functional Java interface.\r
\r
Here is an example of a Java lambda expression that implements the Runnable interface:\r
\r
\`\`\`java\r
Runnable runnable =\r
        () -> { System.out.println("Lambda Runnable running"); };\r
\`\`\`\r
\r
### Calling the run method on a Runnable class\r
\r
Look at this sample code of Runnable implementation\r
\r
\`\`\`java{1,13,23}\r
public class LiftOff implements Runnable {\r
    private int countDown = 10;\r
    private static int taskCount = 0;\r
    private final int id = taskCount;\r
    \r
    public LiftOff() {}\r
    \r
    public LiftOff(int countDown) {\r
        this.countDown = countDown;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        while (countDown > 0) {\r
            System.out.println("#" + id + " (" + countDown + ")" );\r
            countDown--;\r
        }\r
        System.out.println("LiftOff (" + id + ")");\r
    }\r
    \r
    public static void main(String[] args) {\r
        LiftOff launch = new LiftOff();\r
        launch.run();\r
        System.out.println("Waiting for LiftOff!");\r
    }    \r
}\r
\`\`\`\r
\r
::: question What's wrong with previous execution\r
Is the "Waiting for LiftOff!" placed in the right place?\r
\r
Try to create more instances of LiftOff and run them all?\r
\r
Is the application doing something different to a single threaded application?\r
What can you notice from the program output?\r
:::\r
\r
## 3.1.2 Thread subclass\r
\r
The second way to specify what code a thread is to run, is to create a subclass of \`java.lang.Thread\` and override the run() method. The run() method is what is executed by the thread after you call \`start()\`.\r
\r
> [java.lang.Thread specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html)\r
\r
Here is an example of creating a Java Thread subclass:\r
\r
\`\`\`java\r
public class MyThread extends Thread {\r
  public void run(){\r
      System.out.println("MyThread running");\r
  }\r
}\r
\`\`\`\r
\r
To create and start the above thread you can do like this:\r
\r
\`\`\`java\r
MyThread myThread = new MyThread();\r
myTread.start();\r
\`\`\`\r
\r
The start() call will return as soon as the thread is started. It will not wait until the run() method is done. The run() method will execute as if executed by a different CPU. When the run() method executes it will print out the text "MyThread running".\r
\r
You can also create an anonymous subclass of Thread like this:\r
\r
\`\`\`java\r
Thread thread = new Thread(){\r
  public void run(){\r
    System.out.println("Thread Running");\r
  }\r
}\r
\r
thread.start();\r
\`\`\`\r
\r
This example will print out the text "Thread running" once the run() method is executed by the new thread.\r
\r
::: question LiftOff example\r
Copy the original LiftOff example and now make it extends Thread class.\r
\r
Is the "Waiting for LiftOff!" placed in the right place? Is it working as it's supposed to?\r
\r
Try to create more instances of LiftOff and run them all\r
is the application doing something different to a single threaded application?\r
What can you notice from the program output?\r
:::\r
\r
## 3.1.3 Starting a Thread from a Runnable\r
\r
To have the run() method executed by a thread, pass an instance of a class, anonymous class or lambda expression that implements the Runnable interface to a Thread in its constructor. Here is how that is done:\r
\r
\`\`\`java\r
Runnable runnable = new MyRunnable(); // or an anonymous class, or lambda...\r
\r
Thread thread = new Thread(runnable);\r
thread.start();\r
\`\`\`\r
\r
When the thread is started it will call the run() method of the MyRunnable instance (see previous examples) instead of executing it's own run() method. The above example would print out the text "MyRunnable running".\r
\r
::: info\r
Hence, there are two ways to specify what code the thread should execute.\r
\r
- The first is to create a subclass of Thread and override the run() method.\r
- The second method is to pass an object that implements Runnable to the Thread constructor.\r
:::\r
\r
<CodeGroup>\r
<CodeGroupItem title="Extends Thread" active>\r
\r
\`\`\`java{1,7}\r
public class EjemploThread extends Thread {\r
  public void run() {\r
    // C\xF3digo del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    EjemploThread hilo = new EjemploThread();\r
    hilo.start();\r
  }\r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Runnable">\r
\r
\`\`\`java{1,7}\r
public class EjemploRunnable implements Runnable {\r
  public void run() {\r
    // C\xF3digo del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    Thread hilo = new Thread(new EjemploRunnable());\r
    hilo.start();\r
  }    \r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
</CodeGroup>\r
\r
### Subclass or Runnable?\r
\r
There are no rules about which of the two methods is the best. Both methods works. **The preferred method is implementing Runnable**, and handing an instance of the implementation to a Thread instance.\r
\r
A few reasons against extending Thread\r
\r
- When extending the Thread class, we're not overriding any of its methods. Instead, we override the method of Runnable (which Thread happens to implement). This is a clear violation of IS-A Thread principle.\r
- Creating an implementation of Runnable and passing it to the Thread class utilizes composition and not inheritance \u2013 which is more flexible\r
- After extending the Thread class, we can't extend any other class\r
From Java 8 onwards, Runnables can be represented as lambda expressions\r
\r
::: danger Common Pitfall: Calling run() Instead of start()\r
When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start(), like this:\r
\r
> Thread newThread = new Thread(MyRunnable());\r
> newThread.run();  //should be start();\r
\r
or\r
\r
> MyRunnable runnable = new MyRunnable();\r
> runnable.run();  \r
\r
At first you may not notice anything because the Runnable's run() method is executed like you expected. However, it is **NOT executed by the new thread** you just created. Instead the run() method is executed by the thread that created the thread. In other words, the thread that executed the above two lines of code. To have the run() method of the MyRunnable instance called by the new created thread, newThread, **you MUST call the newThread.start() method**.\r
:::\r
\r
## 3.1.4 Thread class methods\r
\r
If we take a look at the Thread class definition, we will find many methods. We must be careful because some of those methods like stop(), suspend(), resume() and destroy() are \`deprecated\`.\r
\r
Next we can see the most commonly used methods of Thread class:\r
\r
| Method                      | Description                                                                                                                                           |\r
| :-------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| start()                     | Makes a thread execute the code in the run method()                                                                                                   |\r
| boolean isAlive()           | Checks if the thread is alive or not                                                                                                                  |\r
| sleep(long ms)              | Changes the thread state to blocked for the ms specified                                                                                              |\r
| run()                       | Is the thread code to be run. It is called by the start method. It represents the lifecycle of a thread.                                              |\r
| String toString()           | Returns a readable representation a thread [threadName, priority, threadGroupName]                                                                    |\r
| long getId()                | Returns the thread id                                                                                                                                 |\r
| void yield()                | Makes the thread stop running at the moment going back to the queue and allowing other threads to be executed.                                        |\r
| void join()                 | Called from another thread, waits for this thread to die                                                                                              |\r
| String getName()            | Gets the thread name                                                                                                                                  |\r
| String setName(String name) | Sets a name for the thread                                                                                                                            |\r
| int getPriority()           | Gets the thread priority                                                                                                                              |\r
| setPriority(int p)          | Sets the thread priority                                                                                                                              |\r
| void interrupt()            | Interrupts the thread executions causing a InterruptedException                                                                                       |\r
| boolean interrupted()       | Checks if a thread has been interrupted                                                                                                               |\r
| Thread.currentThread()      | STATIC method returns a reference to the thread that is running this code                                                                             |\r
| boolean isDaemon()          | Checks if thread is a daemon. A low-level process running independently from its process. A process can finish while a daemon thread is still running |\r
| setDaemon(boolean on)       | Makes a thread turn into a daemon. By default all threads are user-threads when they are created.                                                     |\r
| int activeCount()           | Returns the number of active threads in the thread group where the thread belongs to.                                                                 |\r
| Thread.State getState()     | Returns the thread state, one of NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING or TERMINATED.                                                        |\r
\r
Thread also has up to 9 constructors, most of them getting a Runnable object as parameter along with the thread name and the tread group.\r
\r
| Thread constructors                                                                                   |\r
| :---------------------------------------------------------------------------------------------------- |\r
| Thread()                                                                                              |\r
| Thread\u200B(Runnable target)                                                                              |\r
| Thread\u200B(String name)                                                                                  |\r
| Thread\u200B(Runnable target, String name)                                                                 |\r
| Thread\u200B(ThreadGroup group, Runnable target)                                                           |\r
| Thread\u200B(ThreadGroup group, String name)                                                               |\r
| Thread\u200B(ThreadGroup group, Runnable target, String name)                                              |\r
| Thread\u200B(ThreadGroup group, Runnable target, String name, long stackSize)                              |\r
| Thread\u200B(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals) |\r
\r
Here we can see an example of some of these methods in use\r
\r
\`\`\`java\r
public class ThreadMethodsExample extends Thread {\r
    \r
    ThreadMethodsExample (ThreadGroup group, String name) {\r
        // Call to parent class constructor with group and thread name\r
        super(group, name);\r
    }\r
    \r
    @Override\r
    public void run() {\r
        String threadName = Thread.currentThread().getName();\r
        System.out.println("["+threadName+"] " + "Inside the thread");\r
        System.out.println("["+threadName+"] " + "Priority: " \r
          + Thread.currentThread().getPriority());\r
        Thread.yield();\r
        System.out.println("["+threadName+"] " + "Id: " \r
          + Thread.currentThread().getId());\r
        System.out.println("["+threadName+"] " + "ThreadGroup: " \r
          + Thread.currentThread().getThreadGroup().getName());\r
        System.out.println("["+threadName+"] " + "ThreadGroup count: " \r
          + Thread.currentThread().getThreadGroup().activeCount());\r
    } \r
    \r
    public static void main(String[] args) {\r
        // main thread \r
        Thread.currentThread().setName("Main");\r
        System.out.println(Thread.currentThread().getName());\r
        System.out.println(Thread.currentThread().toString());\r
        \r
        ThreadGroup even = new ThreadGroup("Even threads");\r
        ThreadGroup odd = new ThreadGroup("Odd threads");\r
        \r
        Thread localThread = null;\r
        for (int i=0; i<10; i++) {\r
            localThread = new ThreadMethodsExample((i%2==0)?even:odd, "Thread"+i);\r
            localThread.setPriority(i+1);\r
            localThread.start();\r
        }\r
              \r
        try {\r
            localThread.join(); // --> Will wait until last thread ends \r
                                // like a waitFor() for processes\r
        } catch (InterruptedException ex) {\r
            ex.printStackTrace();\r
            System.err.println("The main thread was interrupted while waiting for " \r
              + localThread.toString() + "to finish");\r
        }\r
        System.out.println("Main thread ending");\r
    }    \r
}\r
\`\`\`\r
\r
As you can see in the code above, the static method Thread.currentThread() should be called in order to get the instance of the current thread running each statement, as there are many threads running the same code at the same time.\r
\r
In the previous example we have used just one class for the new threads and for the main thread. And that's not the usual way to run threads. It's a better practice to split the code in separate classes.\r
\r
Also note that the Thread (or Runnable) class can have it's own constructor to set its local properties or call the superclass constructors.\r
\r
:::question Split the code in two classes\r
Copy the code from the ThreadMethodsExample and split in in two classes. One containing the thread class and the other just having the main method and the calls to create and launch the processes.\r
\r
Next, change the ThreadMethodsExample to implement the Runnable interface and make the appropriate changes in the other class to make it work again.\r
:::\r
\r
Pay attention to  even if the threads are started in sequence (1, 2, 3 etc.) they may not execute sequentially, meaning thread 1 may not be the first thread to write its name to System.out. This is because the threads are in principle executing in parallel and not sequentially. The JVM and/or operating system determines the order in which the threads are executed. This order does not have to be the same order in which they were started nor each time the are run.\r
\r
### Pause a thread\r
\r
A thread can pause itself by calling the static method **Thread.sleep()**. The sleep() takes a number of milliseconds as parameter. The sleep() method will attempt to sleep that number of milliseconds before resuming execution. The Thread sleep() is not 100% precise, but it is pretty good still. Here is an example of pausing a Java thread for 3 seconds (3.000 milliseconds) by calling the Thread sleep() method:\r
\r
\`\`\`java:no-line-numbers\r
try {\r
    Thread.sleep(3000L);\r
} catch (InterruptedException e) {\r
    e.printStackTrace();\r
}\r
\`\`\`\r
\r
::: info Real systems simulation\r
This method is going to be used in activities to simulate time lapses and speed up the real systems simulation. For instance, we can set that each *real* hour is just a second in the simulation, so one day will be reduced to 24 seconds.\r
\r
Also it's interesting when we need to set random time lapses for each thread, in order to get a realistic simulation of events in the real system.\r
:::\r
\r
Random numbers within a specific range of type integer, float, double, long, and boolean can be generated in Java.\r
\r
There are three methods to generate random numbers in Java.\r
\r
#### Method 1: Using random class\r
\r
We can use the \`java.util.Random\` class to generate random numbers, following the steps below:\r
\r
- Import the class java.util.Random\r
- Make the instance of the class Random, i.e., Random rand = new Random()\r
- Invoke one of the following methods of rand object:\r
  - nextInt(upperbound) generates random numbers in the range 0 to upperbound-1.\r
  - nextFloat() generates a float between 0.0 and 1.0.\r
  - nextDouble() generates a double between 0.0 and 1.0.\r
  \r
if we use the netxInt invocation with the bound parameter, we'll get numbers within a range\r
\r
> int randomIntWithinARange = random.nextInt(max)\r
\r
This will give us a number between *0 (inclusive)* and *max* (exclusive). The bound parameter must be greater than 0. Otherwise, we'll get a java.lang.IllegalArgumentException.\r
\r
#### Method 2: Using Math.random\r
\r
For generating random numbers within a range using Math.random(), follow the steps below:\r
\r
- Declare the minimum value of the range\r
- Declare the maximum value of the range\r
- Use the formula Math.random()*(max-min)+min to generate values with the min and the max value inclusive.\r
\r
The value returned by Math.random() is in the range 0 to 1 inclusive.\r
\r
To generate a random value between 0 and an upper limit (50)\r
\r
> Math.random()*50\r
\r
To generate a random value between 1 and an upper limit (50)\r
\r
> Math.random()*49+1\r
\r
To generate a random bounded value, let's say between 200 and 500\r
\r
> Math.random()*300+200\r
\r
#### Method 3: Use ThreadLocalRandom\r
\r
The \`java.util.Random\` class doesn't perform well in a multi-threaded environment.\r
\r
In a simplified way, the reason for the poor performance of Random in a multi-threaded environment is due to contention \u2013 given that multiple threads share the same Random instance.\r
\r
To address that limitation, Java introduced the \`java.util.concurrent.ThreadLocalRandom\` for generating random numbers in a multi-threaded environment.\r
\r
We just need to call \`ThreadLocalRandom.current()\` method, and it will return the instance of ThreadLocalRandom for the current thread. We can then generate random values by invoking available instance methods of the class.\r
\r
To generate a random int value without any bounds:\r
\r
> int unboundedRandomValue = ThreadLocalRandom.current().nextInt());\r
\r
To generate a random bounded int value, meaning a value between a given lower and upper limit.\r
\r
> int boundedRandomValue = ThreadLocalRandom.current().nextInt(0, 100);\r
\r
Please note, 0 is the inclusive lower limit and 100 is the exclusive upper limit.\r
\r
We can generate random values for long and double by invoking \`nextLong()\` and \`nextDouble()\` methods in a similar way as shown in the examples above.\r
  \r
### Threads priority management\r
\r
In Java, a thread's priority is an integer in the range 1 to 10. *The larger the integer, the higher the priority*. The thread scheduler uses this integer from each thread to determine which one should be allowed to execute. The Thread class defines three types of priorities:\r
\r
- Minimum priority\r
- Normal priority\r
- Maximum priority\r
  \r
The Thread class defines these priority types as constants \`MIN_PRIORITY\`, \`NORM_PRIORITY\`, and \`MAX_PRIORITY\`, with values 1, 5, and 10, respectively. **NORM_PRIORITY is the default priority for a new Thread**.\r
\r
Java's Thread class provides methods for checking the thread\u2019s priority and for modifying it.\r
\r
The \`getPriority()\` instance method returns the integer that represents its priority.\r
\r
The \`setPriority()\` instance method takes an integer between 1 and 10 for changing the thread's priority. If we pass a value outside the 1-10 range, the method will throw an error.\r
\r
When we create a Thread, it inherits its default priority. When multiple threads are ready to execute, the JVM selects and executes the Runnable thread that has the highest priority. If this thread stops or becomes not runnable, the lower-priority threads will execute. In case two threads have the same priority, the JVM will execute them in FIFO order.\r
\r
There are two scenarios that can cause a different thread to run:\r
\r
- A thread with higher priority than the current thread becomes runnable\r
- The current thread exits the runnable state or yields (temporarily pause and allow other threads)\r
\r
In general, at any time, the highest priority thread is running. But sometimes, the thread scheduler might choose low-priority threads for execution to avoid starvation.\r
\r
\`\`\`java\r
class U3S3_HiloPrioridad1 extends Thread {\r
  private int c = 0;\r
  private boolean stopHilo = false;\r
  public int getContador () {\r
    return c;\r
  }\r
  public void pararHilo() {\r
    stopHilo = true;\r
  }\r
  public void run() {\r
    while (!stopHilo) c++;\r
  }\r
}\r
\r
public class U3S3_EjemploHiloPrioridad1 {\r
  public static void main(String args[]) {\r
    U3S3_HiloPrioridad1 h1 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h2 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h3 = new U3S3_HiloPrioridad1();\r
\r
    h1.setPriority(Thread.NOR_PRIORITY);\r
    h2.setPriority(Thread.MAX_PRIORITY);\r
    h3.setPriority(Thread.MIN_PRIORITY);\r
\r
    h1.start();\r
    h2.start();\r
    h3.start();\r
\r
    try {\r
      Thread.sleep(10000);\r
    } catch (exception e) {}\r
\r
    h1.pararHilo();\r
    h2.pararHilo();\r
    h3.pararHilo();\r
\r
    System.out.println("h2 (Prio. M\xE1x: "+h2.getContador());\r
    System.out.println("h1 (Prio. Nomral: "+h1.getContador());\r
    System.out.println("h3 (Prio. M\xEDnima: "+h3.getContador());\r
  }\r
}\r
\`\`\`\r
`]},{title:"3.2 Threads synchronization and communication",headers:[{level:2,title:"3.2.1. Shared memory",slug:"_3-2-1-shared-memory",link:"#_3-2-1-shared-memory",children:[]},{level:2,title:"3.2.2. Synchronization",slug:"_3-2-2-synchronization",link:"#_3-2-2-synchronization",children:[{level:3,title:"Monitors and locks",slug:"monitors-and-locks",link:"#monitors-and-locks",children:[]},{level:3,title:"Critical sections",slug:"critical-sections",link:"#critical-sections",children:[]},{level:3,title:"Synchronized and Data Visibility",slug:"synchronized-and-data-visibility",link:"#synchronized-and-data-visibility",children:[]}]},{level:2,title:"3.2.3 Inter-Thread synchronization",slug:"_3-2-3-inter-thread-synchronization",link:"#_3-2-3-inter-thread-synchronization",children:[]}],path:"/en/unit3/synchronization.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.2 Threads synchronization and communication\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.2 Threads synchronization and communication" />\r
\r
# 3.2 Threads synchronization and communication\r
\r
[[toc]]\r
\r
::: info Multithread Vocabulary\r
\r
- **Race condition**: A race condition occurs when two or more threads can access shared data and they try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, you don't know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data.\r
- **Deadlock**: Deadlock describes a situation where two or more threads are blocked forever, waiting for each other. Deadlock occurs when multiple threads need the same locks but obtain them in different order.\r
- **Critical section**: A critical section is a section of code that is executed by multiple threads and where the sequence of execution for the threads makes a difference in the result of the concurrent execution of the critical section. It needs to be executed without outside interference - i.e. without another thread potentially affecting/being affected by "intermediate" states within the section.\r
- **Thread-safe**: A class (or chunk of code) is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and **with no additional synchronization or other coordination on the part of the calling code**.\r
\r
:::\r
\r
## 3.2.1. Shared memory\r
\r
Usually threads need to communicate with each other. The most common way of communication is sharing a common object.\r
\r
Let's code an example where two threads share the same Contador instance.\r
\r
![alt_text](../../media/unit3/SumadorRestador_uml.jpg)\r
\r
<!--\r
\`\`\`puml\r
class Contador {\r
  - int c = 0\r
  + Contador(int c)\r
  +void incrementa()\r
  +void decrementa()\r
  + int valor()\r
}\r
class Sumador extends Thread {\r
  - Contador c\r
  + Sumador(String name, Contador c)\r
  + void run()\r
\r
}\r
class Restador implements Runnable{\r
  - Contador c\r
  + Restador(String name, Contador c)\r
  + void run()\r
\r
}\r
Restador o-- Contador\r
Sumador o-- Contador\r
\`\`\`\r
-->\r
\r
To test the shared object, there must be just another class - containing the main method - to create the shared object (with init value of 100) and to launch the Sumador and Restador threads. In Sumador class we call the Contador.incrementa method in order to add 1 the Contador c property, and similarly Restador calls the decrementa method to substract 1 on Contador c property. Each thread will repeat the same action 300 times, waiting a random time between 50ms and 150ms.\r
It is very relevant to use the same Contador object as parameter for Sumador and Restador, to make sure they are sharing the same Contador instance.\r
\r
::: question Expected behaviour\r
Write the four classes attending to the Class diagram. Make sure to have Sumador extending Thread and Restador implementing Runnable to test differences in how a thread is obtained from each approach.\r
\r
What should happen after running the code?\r
\r
Check what it really happens. Try to run the program many times.\r
:::\r
\r
:::details Code for the example\r
\r
\`\`\`java{4,7,9}\r
public class U3S3_SharedMemory {\r
  public static void main(String[] args) throws InterruptedException {\r
    // Inicializar el objeto Contador\r
    Contador c = new Contador(100);\r
    \r
    // Crear y lanzar 2 hilos (Sumador + Restador)\r
    Sumador s1 = new Sumador("Sumador1", c);\r
    Restador r1 = new Restador("Restador1", c);\r
    Thread h1 = new Thread(r1);\r
    \r
    s1.start();\r
    h1.start();\r
    \r
    // El hilo principal espera a que los hilos s1 y r1 terminen\r
    s1.join();\r
    h1.join();\r
    \r
    System.out.println("El valor final de c es " + c.valor());\r
    \r
  }\r
\`\`\`\r
\r
\`\`\`java\r
public class Contador {\r
  private int c = 0;\r
  \r
  public Contador(int c) {\r
    this.c = c;\r
  }\r
  \r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
  \r
  public int valor() {\r
    return c;\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,5,14}\r
public class Sumador extends Thread {\r
  private Contador c;\r
  public Sumador(String name, Contador c) {\r
    // To set the thread name we can access the Thread class constructor\r
    super(name);\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.incrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());\r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }\r
    }\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,3,13,17}\r
public class Restador implements Runnable {\r
  private Contador c;\r
  private String name;\r
  public Restador(String name, Contador c) {\r
    // Restador doesn't extend Thread, so it cannot call the Thread constructor\r
    // super(name);\r
    this.name = name;\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    Thread.currentThread().setName(this.name);\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.decrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());              \r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }      \r
    }    \r
  }\r
}\r
\`\`\`\r
\r
If we run the code, sometimes it will end by showing a final value of 100 for c, what it should be expected. But if you run the code many times you'll find that sometimes the value can be 99, 101 or any other value.\r
\r
To avoid this synchronization problems (random problems really hard to detect), we need the threads to be synchronized.\r
:::\r
\r
if we check the above problem, we'll find that we are trying to run this code in parallel, from different threads, on the same object instance (shared instance):\r
\r
\`\`\`java\r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
\`\`\`\r
\r
If we apply Bernstein conditions, we well get that none of the three conditions are met, so this code cannot be run concurrently, at least not without having concurrency problems.\r
\r
So, we have to set a special configuration in our code in order to avoid this code to be run simultaneously.\r
\r
## 3.2.2. Synchronization\r
\r
As we have previously seen, threads communicate primarily by sharing access to objects and their properties. This form of communication is extremely efficient but makes two kinds of errors possible:\r
\r
- thread interference\r
- memory consistency errors.\r
\r
The tool needed to prevent these errors is synchronization.\r
\r
When one thread is able to observe the effects of other threads and may be able to detect that variable accesses become visible to other threads in a different order than executed or specified in the program, we talk about reorderings, usually happening with incorrectly synchronized multithread programs. Most of the time, one thread doesn\u2019t care what the other is doing. But when it does, that\u2019s what synchronization is for.\r
\r
### Monitors and locks\r
\r
To synchronize threads, Java uses \`monitors\`, which are a high-level mechanism for allowing only one thread at a time to execute a region of code protected by the monitor. The behavior of monitors is explained in terms of locks; **there is a lock associated with each object**.\r
\r
Synchronization has several aspects. The most well-understood is \`mutual exclusion\` \u2014 **only one thread can hold a monitor at once**, so synchronizing on a monitor means that once one thread enters a synchronized block protected by a monitor, no other thread can enter a block protected by that monitor until the first thread exits the synchronized block.\r
\r
But there is more to synchronization than mutual exclusion. Synchronization ensures that memory writes by a thread before or during a synchronized block are made visible in a predictable manner to other threads that synchronize on the same monitor.\r
\r
::: info Volatile-like behaviour\r
After we exit a synchronized block, we release the monitor, which has the effect of flushing the cache to main memory, so that writes made by this thread can be visible to other threads. Before we can enter a synchronized block, we acquire the monitor, which has the effect of invalidating the local processor cache so that variables will be reloaded from the main memory.\r
:::\r
\r
### Critical sections\r
\r
Synchronized blocks in Java are marked with the \`synchronized\` keyword. A synchronized block in Java is synchronized with some objects. All synchronized blocks synchronized on the same object can only have one thread executing inside them at the same time. All other threads attempting to enter the synchronized block are blocked until the thread inside the synchronized block exits the block.\r
\r
The synchronized keyword can be used to mark four different types of blocks:\r
\r
- Instance methods\r
- Static methods\r
- Code blocks inside instance methods\r
- Code blocks inside static methods\r
\r
Here is a synchronized instance method:\r
\r
\`\`\`java{3}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
}\r
\`\`\`\r
\r
Notice the use of the synchronized keyword in the add() method declaration. This tells Java that the method is synchronized.\r
\r
A synchronized instance method in Java is synchronized on the instance (object) owning the method. Thus, each instance has its synchronized methods synchronized on a different object: the owning instance.\r
\r
Only one thread per instance can execute inside a synchronized instance method. If more than one instance exists, then one thread at a time can execute inside a synchronized instance method per instance. One thread per instance.\r
\r
This is true across all synchronized instance methods for the same object (instance). Thus, in the following example, only one thread can execute inside either of the two synchronized methods. One thread in total per instance:\r
\r
\`\`\`java{3,6}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
 public synchronized void sub(int value){\r
   this.count -= value;\r
 }\r
}\r
\`\`\`\r
\r
::: info Synchronized with static methods\r
Synchronized static methods are synchronized on the **class object** of the class the synchronized static method belongs to. Since **only one class object exists in the Java VM per class**, only one thread can execute inside a static synchronized method in the same class.\r
:::\r
\r
You do not have to synchronize a whole method. Sometimes it is preferable to synchronize only part of a method. Java synchronized blocks inside methods make this possible.\r
Here is a synchronized block of Java code inside an unsynchronized Java method:\r
\r
\`\`\`java{2}\r
public void add(int value){\r
  synchronized(this){\r
    this.count += value;  \r
  }\r
 }\r
\`\`\`\r
\r
This example uses the Java synchronized block construct to mark a block of code as synchronized. This code will now execute as if it was a synchronized method.\r
\r
Notice how the Java synchronized block construct takes an object in parentheses. In the example \u201Cthis\u201D is used, which is the instance the add method is called on. The object taken in the parentheses by the synchronized construct is called a monitor object. The code is said to be synchronized on the monitor object. **A synchronized instance method uses the object it belongs to as a monitor object**.\r
\r
Only one thread can execute inside a Java code block synchronized on the same monitor object.\r
\r
The following two examples are both synchronized on the instance they are called on. **They are therefore equivalent with respect to synchronization**:\r
\r
\`\`\`java{2,8}\r
public class MyClass { \r
  public synchronized void log1(String msg1, String msg2){\r
    log.writeln(msg1);\r
    log.writeln(msg2);\r
  }\r
 \r
  public void log2(String msg1, String msg2){\r
    synchronized(this){\r
     log.writeln(msg1);\r
     log.writeln(msg2);\r
    }\r
  }\r
 }\r
\`\`\`\r
\r
Thus only a single thread can execute inside either of the two synchronized blocks in this example.\r
\r
::: warning What Objects to Synchronize On\r
The synchronized block must be synchronized on some object. You can actually choose any object to synchronize on, but **it is recommended that you do not synchronize on String objects, or any primitive type wrapper objects** (Integer, Double, Boolean, ...).\r
\r
To be on the safe side, synchronize on this - or on a new Object() . Those are not cached or reused internally by the Java compiler, Java VM, or Java libraries.\r
:::\r
\r
### Synchronized and Data Visibility\r
\r
Without the use of the synchronized keyword (or the Java \`volatile\` keyword) there is no guarantee that when one thread changes the value of a variable shared with other threads (e.g. via an object all threads have access to), that the other threads can see the changed value. There are no guarantees about when a variable kept in a CPU register by one thread is "committed" to main memory, and there is no guarantee about when other threads "refresh" a variable kept in a CPU register from main memory.\r
\r
The synchronized keyword changes that.\r
\r
- When a thread enters a synchronized block it will refresh the values of all variables visible to the thread.\r
- When a thread exits a synchronized block all changes to variables visible to the thread will be committed to the main memory.\r
\r
This is similar to how the volatile keyword works.\r
\r
## 3.2.3 Inter-Thread synchronization\r
\r
We can avoid several threads run the same code at the same time by using the \`synchronized\` keyword in order to get \`mutual exclusion\` in the form of \`critical sections\`.\r
Sometimes it can be enough, but others we need the threads to keep certain order in their execution, probably related to other threads previous actions or results.\r
\r
To do so, we need to use three new methods from the object class, directly related to synchronized.\r
\r
- **wait()**: When you call wait method on the object then it tell threads to \`give up the lock\` and go to sleep state unless and until some other thread enters in same monitor and calls notify or notifyAll methods on it.\r
- **notify()**: When you call notify method on the object, it \`wakes one of thread waiting for that object\`. So if multiple threads are waiting for an object, it will wake of one of them. Now you must be wondering which one it will wake up. It actually depends on OS implementation.\r
- **notifyAll()**: notifyAll will \`wake up all threads waiting on that object\` unlike notify which wakes up only one of them. Which one will wake up first depends on thread priority and OS implementation.\r
\r
wait , notify and notifyAll method are used to allow threads to communicate to each other via accessing common object. This common object can be considered a medium for \`inter thread communication\`via these methods. **These methods need to be called from synchronized context**,otherwise it will throw java.lang.IllegalMonitorStateException.\r
\r
When **wait()** method is called, the thread is running inside the synchronized block so it will own the monitor (lock) for the object. That monitor is released by the thread and the thread is locked into another **queue (from the lock object) of threads waiting to be notified**, different than the queue of threads waiting for the object monitor (lock).\r
\r
When a thread is unlocked because another thread has called **notify()/notifyAll()** on the same object, the thread goes back to the point where the wait was made, so the thread is still into a synchronized block. To keep on running, the thread goes back to the **queue of threads waiting for the object monitor (lock)** and it has to wait until it gets the lock to run the sentences after the wait().\r
\r
![Monitor queues](../../media/unit3/Monitor_queues.png)\r
\r
Let's learn how these methods work by looking at the following example\r
\r
\`\`\`java\r
// It is the common java class on which thread will act and call wait and notify method.\r
public class Book {\r
 String title;\r
 boolean isCompleted;\r
 \r
 public Book(String title) {\r
 super();\r
 this.title = title;\r
 }\r
 \r
 public String getTitle() {\r
 return title;\r
 }\r
 public void setTitle(String title) {\r
 this.title = title;\r
 }\r
 public boolean isCompleted() {\r
 return isCompleted;\r
 }\r
 public void setCompleted(boolean isCompleted) {\r
 this.isCompleted = isCompleted;\r
 } \r
}\r
\`\`\`\r
\r
\`\`\`java{14,17}\r
// It will first take a lock on book object \r
// Then, the thread will wait until other thread call notify method, then after it will complete its processing. \r
// So in this example, it will wait for BookWriter to complete the book.\r
public class BookReader implements Runnable{\r
 Book book;\r
 \r
 public BookReader(Book book) {\r
 super();\r
 this.book = book;\r
 }\r
 \r
 @Override\r
 public void run() {\r
 synchronized (book) {\r
  System.out.println(Thread.currentThread().getName()+" is waiting for the book to be completed: "+book.getTitle());\r
  try {\r
  book.wait();\r
  } catch (InterruptedException e) {  \r
  e.printStackTrace();\r
  }\r
  System.out.println(Thread.currentThread().getName()+": Book has been completed now!! you can read it");\r
 }\r
 } \r
}\r
\`\`\`\r
\r
\`\`\`java{15,22,25}\r
// This class will notify thread(in case of notify) which is waiting on book object. \r
// It will not give away lock as soon as notify is called, it first complete its synchronized block. \r
// So in this example, BookWriter will complete the book and notify it to BookReaders. \r
public class BookWriter implements Runnable{\r
\r
 Book book;\r
 \r
 public BookWriter(Book book) {\r
 super();\r
 this.book = book;\r
 }\r
 \r
 @Override\r
 public void run() {\r
 synchronized (book) {\r
  System.out.println("Author is Starting book : " +book.getTitle() );\r
  try {\r
  Thread.sleep(1000);\r
  } catch (InterruptedException e) {\r
  e.printStackTrace();\r
  }\r
  book.setCompleted(true);\r
  System.out.println("Book has been completed now");\r
 \r
  book.notify();\r
  System.out.println("notify one reader");\r
 } \r
 }\r
}\r
\`\`\`\r
\r
\`\`\`java{8,9,26}\r
// This is our main class which will create object of above classes and run it.\r
public class ThreadInterCommunicationMain {\r
 \r
 public static void main(String args[])\r
 {\r
 // Book object on which wait and notify method will be called\r
 Book book=new Book("The Alchemist");\r
 BookReader johnReader=new BookReader(book);\r
 BookReader arpitReader=new BookReader(book);\r
 \r
 // BookReader threads which will wait for completion of book\r
 Thread johnThread=new Thread(johnReader,"John");\r
 Thread arpitThread=new Thread(arpitReader,"Arpit");\r
 \r
 arpitThread.start();\r
 johnThread.start();\r
 \r
 // To ensure both readers started waiting for the book\r
 try {\r
  Thread.sleep(3000);\r
 } catch (InterruptedException e) {\r
 \r
  e.printStackTrace();\r
 }\r
\r
 // BookWriter thread which will notify once book get completed\r
 BookWriter bookWriter=new BookWriter(book);\r
 Thread bookWriterThread=new Thread(bookWriter);\r
 bookWriterThread.start();\r
 }\r
}\r
\`\`\`\r
\r
There must be a notify call for every wait to ensure we have no deadlocks in our app.\r
\r
::: question Does order matter?\r
In the previous example, the Readers will wait for the Writer, assuming that the book isn't still finished.\r
\r
What will happen to the above code if we change the order for the Readers and Writer in the main method? That is, first we make sure the Book is finished and then we call the Readers.\r
\r
Try to modify the Sumador-Restador example to start always running one incrementa operation and just after it a decrementa one, having all operations ordered just one after another.\r
So we will see Sumador-Restador-Sumador-Restador-...\r
:::\r
\r
::: details U3S3_SharedMemory_v2\r
\r
\`\`\`java\r
public class Contador {\r
\r
    private int c = 0;\r
    boolean ahoraSumador = true;\r
\r
    public Contador(int c) {\r
        this.c = c;\r
        ahoraSumador = true;\r
    }\r
\r
    public synchronized void incrementa() {\r
        while (!ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) {\r
            }\r
        }\r
\r
        // El hilo hace su tarea\r
        c++;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = false;\r
        notifyAll();\r
\r
    }\r
\r
    public synchronized void decrementa() {\r
        while (ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) { }\r
        }\r
\r
        // El hilo hace su tarea\r
        c--;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = true;\r
        notifyAll();\r
    }\r
\r
    public int valor() {\r
        return c;\r
    }\r
}\r
\`\`\`\r
\r
In Contador class a new state variable has been added to control the threads order, which one has to wait and which one can run its code.\r
\r
Furthermore, output from the threads run method has been moved into the synchronized methods in this class.\r
\r
\`\`\`java\r
public class Restador  implements Runnable {\r
    private Contador c;\r
    private String name;\r
    public Restador(String name, Contador c) {\r
        // super(name);\r
        this.name = name;\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        Thread.currentThread().setName(this.name);\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.decrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }        \r
    }\r
}\r
\`\`\`\r
\r
Restador and Sumador have few changes.\r
\r
\`\`\`java\r
public class Sumador  extends Thread {\r
    private Contador c;\r
    public Sumador(String name, Contador c) {\r
        super(name);\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.incrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }\r
    }\r
}\r
\`\`\`\r
\r
Main class remains equal.\r
\r
::: danger Synchronized output\r
As you can see from the previous code, the output originally in the threads' run methods now is into Contador class methods, more specifically into the \`synchronized\` methods.\r
\r
Careful with console output. All threads are in a \`race condition\` to use the System.out stream. The concequence is that what we see on the console doesn't match the order in which the output has been sent to the stream. That's why is so important to move the console output into the synchronized methods, when possible.\r
\r
If we don't control the console output we can have well coded and solved problems but in the console we will see wrong results.\r
:::\r
\r
`]},{title:"4 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit4/",pathLocale:"/en/",extraFields:[`---\r
title: 4 Introduction\r
---\r
\r
# Unit 4. Network programming\r
\r
---\r
\r
We have already studied how independent applications can collaborate to do a task (\`multiprocess\`) or just how to divide a program in many execution threads to be run simultaneously and even concurrently (\`multithread\`). But all this happens inside one computer, it can be **monoprocessor** or **multiprocessor**, under the same OS and sharing memory and I/O.\r
\r
In this unit we are going one step forward, we are going to code applications working on distributed environments. Once again we will have multiple processes running, but instead having a parent-child (launcher-launched) relationship, now the processes will be run on independent systems, and what's more interesting, the will communicate through the network by using \`communication protocols\`.\r
\r
Basically we can classify distributed systems in two groups::\r
\r
- **Client / Server**: where one process, called the \`server\`, offers services to one or more processes, called \`clients\`.\r
- **Peer to peer (P2P)**: where all the processes collaborate in a similar way without any particular specialization or difference among them.\r
\r
::: warning Processes and Threads\r
To make a distributed application, with processes and network communication, we are not starting form the scratch.\r
\r
Network programming is strongly linked with multiprocess programming. We will see how communication between process is exactly the same as through the network.\r
\r
On the other side, the specialization and service offered by a server, simultaneously to many clients, is based on the multithread approach..\r
\r
All the above, all concepts and knowledge acquired from unit 1 to unit 3, will be the scaffold to start creating distributed applications.\r
:::\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To know about TCP/IP protocol, addresses used in each protocol layer and associated protocols.\r
- To know Java classes tp work with Internet addresses and server names.\r
- To learn about basic TPC and UPD protocols features.\r
- To code applications that use TCP protocol for communication purposes.\r
- To code applications that use UDP protocol for communication purposes.\r
- To design and code protocols for distributed applications.\r
- to coordinate multiple client access to servers by using multithread programming.\r
`]},{title:"4.3 TCP Sockets",headers:[{level:2,title:"4.3.1. Comunicaci\xF3n cliente/servidor con sockets TCP",slug:"_4-3-1-comunicacion-cliente-servidor-con-sockets-tcp",link:"#_4-3-1-comunicacion-cliente-servidor-con-sockets-tcp",children:[{level:3,title:"Programaci\xF3n de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.3.2. Cliente TCP",slug:"_4-3-2-cliente-tcp",link:"#_4-3-2-cliente-tcp",children:[{level:3,title:"Streams para E/S en los sockets",slug:"streams-para-e-s-en-los-sockets",link:"#streams-para-e-s-en-los-sockets",children:[]}]},{level:2,title:"4.3.3 Servidor TCP",slug:"_4-3-3-servidor-tcp",link:"#_4-3-3-servidor-tcp",children:[]},{level:2,title:"4.3.4 Servidor multihilo",slug:"_4-3-4-servidor-multihilo",link:"#_4-3-4-servidor-multihilo",children:[]}],path:"/en/unit4/sockets-tcp.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.3 TCP Sockets\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.3 TCP Sockets" />\r
\r
# 4.3 TCP Sockets\r
\r
[[toc]]\r
\r
## 4.3.1. Comunicaci\xF3n cliente/servidor con sockets TCP\r
\r
Oracle ha resumido el uso de los sockets en un breve tutorial. Todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about sockets](https://docs.oracle.com/javase/tutorial/networking/sockets/index.html)\r
\r
La interfaz Java que da soporte a sockets TCP est\xE1 constituida por las clases **ServerSocket** y **Socket**.\r
\r
- ServerSocket: es utilizada por un servidor para crear un socket en el puerto en el que escucha las peticiones de conexi\xF3n de los clientes. Su m\xE9todo \`accept\` toma una petici\xF3n de conexi\xF3n de la cola, o si la cola est\xE1 vac\xEDa, se bloquea hasta que llega una petici\xF3n.\r
  \r
  El resultado de ejecutar accept es una instancia de Socket, a trav\xE9s del cual el servidor tiene acceso a los datos enviados por el cliente.\r
\r
- Socket: es utilizada tanto por el cliente como por el servidor. El cliente crea un socket especificando el nombre DNS del host y el puerto del servidor, as\xED se crea el socket local y adem\xE1s se conecta con el servicio.\r
  \r
  Esta clase proporciona los m\xE9todos \`getInputStream\` y \`getOutputStream\` para acceder a los dos streams asociados a un socket (recordemos que son bidireccionales), y devuelve tipos de datos InputStream y OutputStream, respectivamente, a partir de los cuales podemos construir \`BufferedReader\` y \`PrintWriter\`, respectivamente, para poder procesar los datos de forma m\xE1s sencilla.\r
\r
### Programaci\xF3n de aplicaciones Cliente y/o Servidor\r
\r
Al crear aplicaciones cliente y servidor puede que nos encontremos con varios escenarios, a saber:\r
\r
- Si tenemos que programar solo el servidor **deberemos definir un protocolo** de comunicaci\xF3n para usar ese servidor.\r
- Si tenemos que programar solo el cliente **necesitaremos conocer el protocolo** de comunicaci\xF3n para conectar con ese servidor.\r
- Si tenemos que programar el cliente y el servidor, tendremos que empezar por **definir el protocolo** de comunicaci\xF3n entre ambos.\r
\r
::: info Herramientas para definir los protocolos\r
Dentro de todos los diagramas que ofrece UML, el diagrama de secuencia es el que mejor se adapta para definir los protocolos de comunicaci\xF3n entre clases y las interacciones que se producen.\r
\r
Para crear estos diagramas existen multitud de herramientas, tanto de escritorio como online. De todas ellas cabe destacar:\r
\r
- [Mermaid Live editor](https://mermaid.live/) que usa una [sintaxis en modo texto](https://mermaid-js.github.io/mermaid/#/sequenceDiagram) para definir los diagramas.\r
- [WebSequenceDiagrams](https://www.websequencediagrams.com/): M\xE1s visual y tambi\xE9n con una definici\xF3n textual de los diagramas.\r
- [Visual Paradigm Online](https://online.visual-paradigm.com/drive/#diagramlist:proj=0&dashboard): Herramienta totalmente visual y con unos resultados m\xE1s espectaculares.\r
\r
Estas herramientas son las que ten\xE9is que usar en las actividades en las que se os pida definir un protocolo de comunicaci\xF3n cliente / servidor.\r
:::\r
\r
## 4.3.2. Cliente TCP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente ser\xE1:\r
\r
1. Crear un objeto de la clase Socket, indicando host y puerto donde corre el servicio.\r
2. Obtener las referencias al stream de entrada y al de salida al socket.\r
3. Leer desde y escribir en el stream de acuerdo al protocolo del servicio. Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar el socket.\r
\r
\`\`\`java{12,14,17,36,38,51,52,54}\r
public class BasicClient {\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que est\xE1 en la misma m\xE1quina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket("localhost", 4444);\r
            // Obtenemos el canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexi\xF3n");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenv\xEDa al servidor hasta que este\r
        // se despide con "Adios"\r
        try {\r
            while (true) {\r
                // Leo la entrada del usuario\r
                linea = stdIn.nextLine();\r
                // La envia al servidor por el OutputStream\r
                salida.println(linea);\r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Env\xEDa a la salida est\xE1ndar la respuesta del servidor\r
                System.out.println("Respuesta servidor: " + linea);\r
                // Si es "Adios" es que finaliza la comunicaci\xF3n\r
                if (linea.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
\r
        // Libera recursos\r
        salida.close();\r
        entrada.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\r
\`\`\`\r
::: info Herramientas para simular clientes gen\xE9ricos\r
Si s\xF3lo tenemos que desarrollar un servidor y no tenemos o no queremos hacer un cliente para las pruebas, tenemos varias herramientas que nos ayudan a hacer de clientes gen\xE9ricos, \xFAtiles para una gran variedad de servidores, incluso para servidores est\xE1ndar como FTP, HTTP, etc.\r
\r
La primera herramienta es una aplicaci\xF3n y un protocolo de nivel de aplicaci\xF3n de TCP/IP, es la herramienta \`Telnet\`.\r
\r
Esta herramienta suele venir instalada en los sistemas GNU/Linux y OS X. Sin embargo en los sistemas Windows viene deshabilitada por defecto.\r
\r
Os dejo un enlace al art\xEDculo de Xataka [Telnet: qu\xE9 es y c\xF3mo activarlo en Windows 10](https://www.xataka.com/basics/telnet-que-como-activarlo-windows-10).\r
\r
Es importante que lo activ\xE9is tanto en clase como en el aula.\r
\r
La segunda herramienta es NetCat. Es una herramienta muy vers\xE1til y potente, ya que no s\xF3lo puede hacernos de cliente, sino que tambi\xE9n puede servir como servidor.\r
\r
Como muchas otras herramientas, esta tambi\xE9n viene instalada de serie en GNU/Linux y OS X, pero no en Windows. Su uso en los sistemas de Microsoft es algo m\xE1s controvertido ya que el sistema la detecta como un virus y tenemos que habilitar su uso en el *Guardian* del SO.\r
\r
Os dejo tambi\xE9n un enlace a este art\xEDculo de IONOS [\xBFQu\xE9 es Netcat y c\xF3mo funciona?](https://www.ionos.es/digitalguide/servidores/herramientas/netcat/)\r
:::\r
\r
### Streams para E/S en los sockets\r
\r
Si vemos ejemplos en Internet o en tutoriales, podemos observar que hay dos formas mayoritarias de enviar y recibir la informaci\xF3n a trav\xE9s de los streams que proporciona un socket.\r
\r
![Basic Stream IO](../../media/unit4/basicIOStreams.png)\r
\r
En cualquier caso, a trav\xE9s de los streams enviamos bytes, que es la forma m\xE1s b\xE1sica de generar informaci\xF3n, bien sea a trav\xE9s de la red o entre procesos.\r
\r
Como es complicado gestionar a nivel de bytes toda la informaci\xF3n que queremos enviar o recibir, usamos \`Decorators\` o \`Wrappers\` para enviar tipos de datos de un nivel de abstracci\xF3n mayor.\r
\r
En los temas anteriores, cuando hemos tenido que intercambiar informaci\xF3n entre procesos, hemos estado usando BufferedReader y PrintWriter. Estas clases trabajan a nivel de Strings, y son muy \xFAtiles cuando lo que queremos intercambiar a trav\xE9s de los streams son cadenas de texto.\r
\r
> En los protocolos de comunicaciones, m\xE1s del 90% de la informaci\xF3n que se intercambia, a nivel de protocolo, es en formato texto.\r
\r
Sin embargo, puede haber ocasiones en las que nos interese trabajar con tipos de datos. \r
\r
\`DataInputStream\` y \`DataOutputStream\` proporcionan m\xE9todos para leer y escribir Strings y todos los tipos de datos primitivos de Java, incluyendo n\xFAmeros y valores booleanos. \r
\r
![Basic Stream IO](../../media/unit4/streamWrappers.png)\r
\r
DataOutputStream codifica esos valores de forma independiente de la m\xE1quina y los env\xEDa al stream de m\xE1s bajo nivel para que los gestione como bytes. DataInputStream hace lo contrario.\r
\r
As\xED, podemos trabajar con DataInputStream y DataOutputStream a partir de los streams que nos proporcionan los sockets\r
\r
\`\`\`java\r
// C\xF3digo en el cliente\r
DataInputStream dis = new DataInputStream(socket.getInputStream());\r
dis.readDouble();\r
\r
// C\xF3digo en el servidor\r
DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\r
dis.writeDouble(number);\r
\`\`\`\r
\r
Los m\xE9todos \`readUTF()\` and \`writeUTF()\` de DataInputStream y DataOutputStream leen y escriben un String de caracteres Unicode usando la codificaci\xF3n UTF-8.\r
\r
::: warning Elige un m\xE9todo y usa siempre el mismo\r
Es muy importante no mezclar diferentes wrappers en el mismo sistema. Aunque todos acaban utilizando el InputStream y el OutputStream, las codificaciones y la forma de enviar la informaci\xF3n no es la misma.\r
\r
Por lo que, si usas DataInputStream en el cliente para leer, debes usar DataOutputStream en el servidor para enviar. Adem\xE1s de usar los m\xE9todos complementarios para la lectura y escritura, por ejemplo readInt / writeInt.\r
:::\r
\r
Informaci\xF3n extra\xEDda de [Learning Java, 4th Edition - O'Reilly](https://www.oreilly.com/library/view/learning-java-4th/9781449372477/ch12s01.html)\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.3 Servidor TCP\r
\r
La forma de implementar un servidor ser\xE1:\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_states.png)\r
\r
1. Crear un objeto de la clase ServerSocket para escuchar peticiones en el puerto asignado al servicio.\r
2. Esperar solicitudes de clientes\r
3. Cuando se produce una solicitud:\r
    - Aceptar la conexi\xF3n obteniendo un objeto de la clase Socket\r
    - Obtener las referencias al stream de entrada y al de salida al socket anterior.\r
    - Leer datos del socket, procesarlos y enviar respuestas al cliente, escribiendo en el stream del socket.Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar los sockets.\r
\r
\`\`\`java{9,23,26,29,36,40,50,51,52,53}\r
public class BasicServer {\r
\r
    public static final int PORT = 4444;\r
\r
    public static void main(String[] args) throws IOException {\r
        // Establece el puerto en el que escucha peticiones\r
        ServerSocket socketServidor = null;\r
        try {\r
            socketServidor = new ServerSocket(PORT);\r
        } catch (IOException e) {\r
            System.out.println("No puede escuchar en el puerto: " + PORT);\r
            System.exit(-1);\r
        }\r
\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        System.out.println("Escuchando: " + socketServidor);\r
        try {\r
            // Se bloquea hasta que recibe alguna petici\xF3n de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexi\xF3n aceptada: " + socketCliente);\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Hace eco de lo que le proporciona el cliente, hasta que recibe "Adios"\r
            while (true) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
                // Env\xEDa a la salida est\xE1ndar el mensaje del cliente\r
                System.out.println("Cliente: " + str);\r
                // Le env\xEDa la respuesta al cliente por el OutputStream                \r
                salida.println(str);\r
                // Si es "Adios" es que finaliza la comunicaci\xF3n\r
                if (str.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
        salida.close();\r
        entrada.close();\r
        socketCliente.close();\r
        socketServidor.close();\r
    }\r
\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_sequence.png)\r
\r
El servidor monohilo se encarga de realizar las operaciones de E/S con el cliente. Hasta que no acaba no puede hacer otro \`accept\` y atender a otro cliente.\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.4 Servidor multihilo\r
\r
Si queremos que un servidor pueda atender varias peticiones de forma simultanea, debemos usar hilos para dotarle de esa capacidad.\r
\r
El flujo b\xE1sico ahora cambiar\xEDa para adaptarse a este formato\r
\r
\`\`\`\r
while (true) {\r
\r
    Aceptar la conexi\xF3n obteniendo un objeto de la clase Socket;\r
\r
    Crear un thread para que se encargue de la comunicaci\xF3n con ese cliente, es decir, \r
    para que gestione el socket obtenido en el accept.;\r
}\r
\`\`\`\r
![Estados de un servidor multihilo](../../media/unit4/multithread_server_states.png)\r
\r
El servidor multihilo crea un nuevo hilo que se encarga de las operaciones de E/S con el cliente. Mientras tanto puede esperar la conexi\xF3n de nuevos clientes con los que volver\xE1 a hacer lo mismo.\r
\r
El servidor multihilo se ayuda de una clase \`Worker\` que hereda de Thread, pudiendo as\xED ejecutarse concurrentemente con el hilo principal.\r
\r
Esta clase \`Worker\` es la encargada de realizar toda la comunicaci\xF3n con el cliente y el servidor. Para poder hacerlo, en su constructor recibe el Socket que se crea cuando se recibe  la conexi\xF3n de un cliente \`ServerSocket.accept()\`.\r
\r
\`\`\`java {6,20,24}\r
public static final int PORT = 4444;\r
public static void main(String[] args)  {\r
    // Establece el puerto en el que escucha peticiones\r
    ServerSocket socketServidor = null;\r
    try {\r
        socketServidor = new ServerSocket(PORT);\r
    } catch (IOException e) {\r
        System.out.println("No puede escuchar en el puerto: " + PORT);\r
        System.exit(-1);\r
    }\r
\r
    Socket socketCliente = null;\r
\r
    System.out.println("Escuchando: " + socketServidor);\r
    try {\r
        \r
        while (true) {\r
            // Se bloquea hasta que recibe alguna petici\xF3n de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexi\xF3n aceptada: " + socketCliente);\r
            // Para seguir aceptando peticiones de otros clientes\r
            // se crea un nuevo hilo que se encargar\xE1 de la comunicaci\xF3n con el cliente\r
            new Worker(socketCliente).start();\r
        }\r
                        \r
    ...\r
}    \r
\`\`\`\r
\r
Y esta ser\xEDa una implementaci\xF3n est\xE1ndar de un worker\r
\r
\`\`\`java{13,15,22,26}\r
public class Worker extends Thread {\r
\r
    private Socket socketCliente;\r
    private BufferedReader entrada = null;\r
    private PrintWriter salida = null;\r
\r
    ....\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Realizamos la comunicaci\xF3n entre servidor y cliente\r
            // **** ES LO QUE CAMBIA EN CADA EJERCICIO ****\r
\r
            // Hacemos una recepci\xF3n de informaci\xF3n desde el cliente\r
            String mensajeRecibido = entrada.readLine();\r
            System.out.println("<-- Cliente: " + mensajeRecibido);\r
            \r
            // Hacemos un env\xEDo al cliente\r
            String mensajeEnviado = "Mensaje enviado desde el servidor al cliente";\r
            salida.println(mensajeEnviado);\r
            System.out.println("--> Cliente: " + mensajeEnviado);\r
        }\r
        ....\r
}        \r
\`\`\`\r
\r
Quedando ahora la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/multithread_server_sequence.png)\r
\r
<div class="pagebreak"> </div>\r
\r
::: info Ejecuci\xF3n de m\xFAltiples clientes desde l\xEDnea de comandos\r
Para poder lanzar varias aplicaciones java a la vez, la forma m\xE1s correcta de hacerlo es desde una terminal de comandos. Esto nos permite poder pasarle argumentos a todas las clases, no s\xF3lo a la que est\xE1 marcada como *principal* en el proyecto.\r
\r
Aqu\xED tenemos dos posibilidades, **ejecutar las clases individualmente**, tal y como hacemos desde el IDE o bien **lanzar las clases desde un archivo JAR**.\r
\r
En ambos casos, necesitamos haber compilado y construido el proyecto (*F11 \xF3 Shift+F11 en Netbeans*).\r
\r
Ejecuci\xF3n de clases individuales\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener las clases compiladas.\r
- A continuaci\xF3n, al igual que hac\xEDamos con los procesos, debemos ubicarnos en la carpeta \`build/classes\` del proyecto.\r
- Desde ah\xED, ejecutaremos\r
    > build/classes$ java psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuaci\xF3n del nombre de la clase son los par\xE1metros que la clase recibir\xE1 en el args[] de su m\xE9todo main.\r
\r
    y para la clase o clases que no sean las principales\r
    > build/classes$ java psp.actividades.U4AX_ClaseSCliente localhost 5566\r
\r
    Si queremos lanzar m\xE1s de un cliente, repetiremos el comando desde otra ventana de comandos.\r
\r
Lanzar las clases desde un archivo JAR\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener el proyecto construido\r
- A continuaci\xF3n, y a diferencia del caso anterior, debemos ubicarnos en el directorio donde est\xE9 el archivo JAR. Si no lo hemos movido, estar\xE1 en la carpeta \`dist\` del proyecto.\r
- Desde ah\xED, ejecutaremos, **para la clase principal del proyecto**\r
    > dist$ java -jar U4AX_ProyectoClienteServidor.jar 5566\r
\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuaci\xF3n del nombre de la clase son los par\xE1metros que la clase recibir\xE1 en el args[] de su m\xE9todo main.\r
\r
    y para la clase o clases que no sean las principales\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseCliente localhost 5566\r
\r
    Si queremos lanzar m\xE1s de un cliente, repetiremos el comando desde otra ventana de comandos.\r
:::\r
`]},{title:"4.4 UDP Sockets",headers:[{level:2,title:"4.4.1. Client/Server communication using UDP sockets",slug:"_4-4-1-client-server-communication-using-udp-sockets",link:"#_4-4-1-client-server-communication-using-udp-sockets",children:[{level:3,title:"DatagramSocket",slug:"datagramsocket",link:"#datagramsocket",children:[]},{level:3,title:"DatagramPacket",slug:"datagrampacket",link:"#datagrampacket",children:[]},{level:3,title:"Programaci\xF3n de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.4.2. Cliente UDP",slug:"_4-4-2-cliente-udp",link:"#_4-4-2-cliente-udp",children:[]},{level:2,title:"4.4.3 Servidor UDP",slug:"_4-4-3-servidor-udp",link:"#_4-4-3-servidor-udp",children:[]},{level:2,title:"4.4.4 Multicast socket",slug:"_4-4-4-multicast-socket",link:"#_4-4-4-multicast-socket",children:[]}],path:"/en/unit4/sockets-udp.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.4 UDP Sockets\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.4 UDP Sockets" />\r
\r
# 4.4 UDP Sockets\r
\r
[[toc]]\r
\r
## 4.4.1. Client/Server communication using UDP sockets\r
\r
Igual que en el apartado anterior, Oracle proporciona una gu\xEDa son informaci\xF3n b\xE1sica sobre el uso de los Sockets UDP. De nuevo, todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about datagrams](https://docs.oracle.com/javase/tutorial/networking/datagrams/index.html)\r
\r
::: info UDP - Protocolo sin conexi\xF3n\r
El protocolo de comunicaciones con \`datagramas\` UDP, es un protocolo sin conexi\xF3n, es decir, cada vez que se env\xEDen datagramas es necesario enviar el descriptor del socket local y la direcci\xF3n del socket que debe recibir el datagrama. Como se puede ver, hay que enviar datos adicionales cada vez que se realice una comunicaci\xF3n.\r
\r
Se trata de un servicio de transporte sin conexi\xF3n. Son m\xE1s eficientes que TCP, pero no est\xE1 garantizada la fiabilidad: los datos se env\xEDan y reciben en paquetes, cuya entrega no est\xE1 garantizada; los paquetes pueden ser duplicados, perdidos o llegar en un orden diferente al que se envi\xF3.\r
:::\r
\r
La interfaz Java que da soporte a sockets TCP est\xE1 constituida por las clases **DatagramPacket** y **DatagramSocket**.\r
\r
- DatagramSocket: es la clase utilizada para realizar el env\xEDo y la recepci\xF3n de los datos. A diferencia de los sockets TCP, esta clase no es la encargada de gestionar las direcciones ni de realizar la conexi\xF3n, s\xF3lo se encarga de transportar los datos del origen al destino.\r
\r
    Lo \xFAnico que se hace es enviar los datos, mediante la creaci\xF3n de un socket y utilizando los m\xE9todos de env\xEDo y recepci\xF3n apropiados.\r
\r
    Esta clase proporciona los m\xE9todos \`send\` y \`receive\`.\r
\r
- DatagramPackets: esta clase es la encargada de incluir la informaci\xF3n que se quiere enviar/recibir y la informaci\xF3n de direccionamiento, es decir, la direcci\xF3n a la que se quiere enviar l informaci\xF3n que contiene.\r
  \r
   DatagramPacket contiene la informaci\xF3n relevante. Cuando se desea recibir un datagrama, \xE9ste deber\xE1 almacenarse bien en un buffer o un array de bytes. Y cuando preparamos un datagrama para ser enviado, el DatagramPacket no s\xF3lo debe tener la informaci\xF3n, sino que adem\xE1s debe tener la direcci\xF3n IP y el puerto de destino.\r
\r
::: warning Puertos duplicados UDP / TCP\r
Dado que la gesti\xF3n de los puertos y el protocolo que se utiliza es diferente, podemos usar el mismo n\xFAmero de puerto para un servicio que use el protocolo TCP y otro servicio, en el mismo puerto, que use UDP.\r
\r
En realidad, un socket adem\xE1s de IP_origen, Puerto_origen, IP_destino, Puerto_destino, tambi\xE9n incluye el protocolo usado, por eso un socket con el mismo origen y destino, es diferente y puede ser usado a al vez por UDP y TCP\r
\r
**Socket = [Protocolo (TCP/UDP) + IP_origen + Puerto_origen + IP_destino + Puerto_destino]**\r
:::\r
\r
### DatagramSocket\r
\r
Esta clase proporciona los siguiente m\xE9todos\r
\r
| M\xE9todo | Descripci\xF3n |\r
| --- | ----------- |\r
| public DatagramSocket () throws SocketException | Se encarga de construir un socket para datagramas y de conectarlo al primer puerto disponible. |\r
| public DatagramSocket (int port) throws SocketException | \xCDdem, pero con la salvedad de que permite especificar el n\xFAmero de puerto asociado. |\r
| public DatagramSocket (int port, InetAddress ip) throws SocketException | Permite especificar, adem\xE1s del puerto, la direcci\xF3n local a la que se va a asociar el socket. |\r
| public int getLocalPort() | Retorna el n\xFAmero de puerto en el host local al que est\xE1 conectado el socket. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Env\xEDa un DatagramPacket a trav\xE9s del socket. |\r
| **public setSoTimeout(int timeout)** | Permite establecer un tiempo de espera l\xEDmite para que el m\xE9todo receive se quede bloqueado esperando a recibir una respuesta por parte del otro extremo. Si no reciben datos en el tiempo fijado se lanza la excepci\xF3n \`InterruptedIOException\` |\r
\r
El DatagramSocket, cuando se utiliza en la parte receptora (la que vamos a llamar servidora) que ofrece el servicio para que los clientes se conecten, s\xF3lo va a indicar el puerto al que esos clientes deben enviar sus solicitudes. En el caso de los procesos que act\xFAen como clientes, se usar\xE1 el constructor sin par\xE1metros para que sea el SO el que asigne un puerto libre.\r
\r
Por lo tanto, un mismo DatagramSocket al no incluir ninguna informaci\xF3n de direccionamiento puede ser reutilizado para enviar y/o recibir datagramas a/desde diferentes destinos.\r
\r
### DatagramPacket\r
\r
La clase \`DatagramPacket\` como se ha indicado anteriormente, es un contenedor del mensaje y del destino de ese mensaje.\r
\r
![Datagram Packet](../../media/unit4/datagrampacket.svg)\r
\r
Esta clase proporciona los siguiente m\xE9todos\r
\r
| M\xE9todo | Descripci\xF3n |\r
| --- | ----------- |\r
| public DatagramPacket(byte ibuf[], int  ilength)  | Implementa un DatagramPacket para la **recepci\xF3n** de paquetes de longitud ilength, siendo el valor de este par\xE1metro menor o igual que ibuf.length. |\r
| public DatagramPacket(byte ibuf[], int ilength, InetAddress iaddr, int iport)  | Implementa un DatagramPacket para el **env\xEDo** de paquetes de longitud ilength al n\xFAmero de puerto especificado en el par\xE1metro iport, del host especificado en la direcci\xF3n de destino que se le pasa por medio del par\xE1metro iaddr. |\r
| public InetAddress getAddress () | Retorna la direcci\xF3n IP del host al cual se le env\xEDa el datagrama o del que el datagrama se recibi\xF3. |\r
| public byte[] getData() | Retorna los **datos a recibir** o a enviar. |\r
| public int getLength() | Retorna la longitud de los datos a enviar o a recibir. |\r
| public int getPort() | Retorna el n\xFAmero de puerto de la m\xE1quina remota a la que se le va a enviar el datagrama o del que se recibi\xF3. |\r
\r
Como se intuye de la descripci\xF3n de los m\xE9todos, la forma de crear el datagrama va a depender de si queremos enviar o recibir la informaci\xF3n, ya que en cada uno de estas acciones tendremos que indicar d\xF3nde van dirigidos esos datos (env\xEDo) o bien esa informaci\xF3n ya vendr\xE1 incluida en el datagrama (recepci\xF3n) y podremos acceder a ella a trav\xE9s de los m\xE9todos getter de la clase.\r
\r
Es importante hacer ver que la informaci\xF3n debe enviarse como un array de bytes y que se recibe de la misma forma, por lo que tendremos que usar los m\xE9todos de String o de cualquiera de los otros tipos primitivos de Java para convertirlos a bytes.\r
\r
### Programaci\xF3n de aplicaciones Cliente y/o Servidor\r
\r
En el caso de aplicaciones UDP, el protocolo de comunicaci\xF3n no tiene sentido a nivel de capa de transporte, ya que s\xF3lo se env\xEDan y reciben mensajes y hablamos de un \`protocolo no orientado a conexi\xF3n\`, por lo tanto no sirve para realizar confirmaciones o di\xE1logos entre la parte servidora y cliente.\r
\r
La parte del protocolo se delega en una capa superior, que ser\xE1 la encargada de gestionar la comunicaci\xF3n a un nivel de abstracci\xF3n mayor.\r
\r
De todas formas, la comunicaci\xF3n entre ambas partes debe seguir estando sincronizada en los que a env\xEDos / respuestas se refiere para no dejar a la otra parte bloqueada en las lecturas.\r
\r
::: info Bloqueo de lecturas con timeout\r
Esta caracter\xEDstica, tambi\xE9n disponible para los sockets TCP, permite evitar un bloqueo infinito de un hilo a la espera de recibir datos del otro extremo del socket.\r
\r
Es de especial importancia en la gesti\xF3n de las comunicaciones UDP ya que, como hemos dicho, no tienen porqu\xE9 seguir un protocolo preestablecido a nivel de transporte.\r
\r
Con el m\xE9todo \`setSoTimeout\` de DatagramSocket podemos fijar un tiempo de espera m\xE1ximo para la recepci\xF3n de datos a trav\xE9s del socket.\r
:::\r
\r
## 4.4.2. Cliente UDP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente ser\xE1:\r
\r
1. El cliente crear\xE1 un socket para comunicarse con el servidor. Para enviar datagramas necesita conocer su IP y el puerto por el que escucha.\r
2. Utilizar\xE1 el m\xE9todo send() del socket para enviar la petici\xF3n en forma de datagrama.\r
    - La informaci\xF3n se envia en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
3. Permanece a la espera de recibir respuesta\r
4. El cliente recibe la respuesta del servidor mediante el m\xE9todo receive() del socket.\r
    - La informaci\xF3n se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
5. Cerrar y liberar los recursos.\r
\r
\`\`\`java{10,14,17,20,28,31}\r
public class BasicUDP_Client {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // IP y puerto al que se env\xEDa el Datagrama\r
        InetAddress destino = InetAddress.getLocalHost();\r
        int port = 12345; \r
        \r
        // Buffer para recibir el datagrama\r
        byte[] buffer = new byte[1024];\r
        \r
        // El mensaje a enviar en el Datagrama se convierte a bytes\r
        String mensajeEnviado = "Enviando Saludos !!";\r
        buffer = mensajeEnviado.getBytes(); //codifico String a bytes\r
\r
        // Se preparara el DatagramPacket que se va a enviar\r
        DatagramPacket datagramaEnviado = new DatagramPacket(buffer, buffer.length, destino, port);\r
        // En este caso, especificamos un puerto, aunque podr\xEDamos dejarlo para\r
        // que el SO asigne uno libre\r
        DatagramSocket socket = new DatagramSocket(34567);\r
        \r
        System.out.println("Host destino : " + destino.getHostName());\r
        System.out.println("IP Destino : " + destino.getHostAddress());\r
        System.out.println("Puerto local del socket: " + socket.getLocalPort());\r
        System.out.println("Puerto al que envio: " + datagramaEnviado.getPort());\r
\r
        // Env\xEDo del Datagrama\r
        socket.send(datagramaEnviado);\r
        \r
        // Cierre y liberaci\xF3n de recursos       \r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.4.3 Servidor UDP\r
\r
En los sockets UDP no se establece conexi\xF3n. A pesar de que cuando los programamos s\xED existen diferencias entre el servidor y el cliente, estas no son tan claras como con los sockets TCP. La funcionalidad y el c\xF3digo que diferencia a un servidor de un cliente est\xE1 m\xE1s diluido.\r
\r
> Podemos considerar servidor al que espera un mensaje y responde; y cliente al que inicia la comunicaci\xF3n.\r
\r
Tanto uno como otro si desean ponerse en contacto necesitan saber en qu\xE9 ordenador y en qu\xE9 puerto est\xE1 escuchando el otro.\r
\r
1. El servidor crea un socket asociado a un puerto local para escuchar peticiones de clientes.\r
2. Permanece a la espera de recibir peticiones.\r
3. El servidor recibe las peticiones mediante el m\xE9todo receive() del socket.\r
    - La informaci\xF3n se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
4. En el datagrama recibido va incluido adem\xE1s del mensaje, el puerto y la IP del cliente emisor de la petici\xF3n; lo que le permite al servidor conocer la direcci\xF3n del emisor del datagrama. Utilizando el m\xE9todo send() del socket puede enviar la respuesta al cliente emisor.\r
5. El servidor permanece a la espera de recibir m\xE1s peticiones.\r
6. Cerrar y liberar los recursos.\r
\r
\`\`\`java{6,10,18,20,21,33}\r
public class BasicUDP_Server {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // Buffer para recibir el datagrama\r
        byte[] bufer = new byte[1024];\r
\r
        // El Socket del servidor se asocia a un puerto para que los clientes\r
        // puedan enviar peticiones.\r
        DatagramSocket socket = new DatagramSocket(12345);\r
\r
        // Se espera la llegada de un DATAGRAMA\r
        // Al igual que con TCP, esta llamada a receive es bloqueante\r
        // y es la que tiene que marcar la sincronizaci\xF3n entre lecturas y \r
        // escrituras de las app cliente / servidor\r
        System.out.println("Esperando Datagrama ................");\r
        // Se crea el objeto que almacenar\xE1 el mensaje enviado por el cliente\r
        DatagramPacket datagramaRecibido = new DatagramPacket(bufer, bufer.length);\r
        // Se espera el mensaje y se le pasa el datagrama para que lo almacene ah\xED\r
        socket.receive(datagramaRecibido);\r
        String mensajeRecibido = new String(datagramaRecibido.getData());\r
\r
        //Informaci\xF3n recibida\r
        System.out.println("N\xFAmero de Bytes recibidos: " + datagramaRecibido.getLength());\r
        System.out.println("Contenido del Paquete    : " + mensajeRecibido.trim());\r
\r
        System.out.println("Puerto origen del mensaje: " + datagramaRecibido.getPort());\r
\r
        System.out.println("IP de origen             : " + datagramaRecibido.getAddress().getHostAddress());\r
        System.out.println("Puerto destino del mensaje:" + socket.getLocalPort());\r
\r
        // Liberamos los recursos\r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor UDP](../../media/unit4/udp_process.png)\r
\r
Veamos ahora un ejemplo completo de C/S UDP\r
\r
\`\`\`java\r
public class BasicUDP_Client2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // FLUJO PARA ENTRADA ESTANDAR\r
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\r
\r
        DatagramSocket clientSocket = new DatagramSocket();\r
        byte[] enviados = new byte[1024];\r
        byte[] recibidos = new byte[1024];\r
\r
        // DATOS DEL SERVIDOR al que enviar mensaje\r
        InetAddress IPServidor = InetAddress.getLocalHost();// localhost\r
        int puerto = 9876; // puerto por el que escucha\r
\r
        // INTRODUCIR DATOS POR TECLADO\r
        System.out.print("Introduce mensaje: ");\r
        String cadena = in.readLine();\r
        enviados = cadena.getBytes();\r
\r
        // ENVIANDO DATAGRAMA AL SERVIDOR\r
        System.out.println("Enviando " + enviados.length + " bytes al servidor.");\r
        DatagramPacket envio = new DatagramPacket(enviados, enviados.length, IPServidor, puerto);\r
        clientSocket.send(envio);\r
\r
        // RECIBIENDO DATAGRAMA DEL SERVIDOR\r
        DatagramPacket recibo = new DatagramPacket(recibidos, recibidos.length);\r
        System.out.println("Esperando datagrama....");\r
        clientSocket.receive(recibo);\r
        String mayuscula = new String(recibo.getData());\r
\r
        // OBTENIENDO INFORMACI\xD3N DEL DATAGRAMA\r
        InetAddress IPOrigen = recibo.getAddress();\r
        int puertoOrigen = recibo.getPort();\r
        System.out.println("\\tProcedente de: " + IPOrigen + ":" + puertoOrigen);\r
        System.out.println("\\tDatos: " + mayuscula.trim());\r
\r
        //cerrar socket\r
        clientSocket.close();\r
\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class BasicUDP_Server2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Puerto por el que escucha el servidor: 9876\r
        DatagramSocket serverSocket = new DatagramSocket(9876);\r
        byte[] recibidos = new byte[1024];\r
        byte[] enviados = new byte[1024];\r
        String cadena;\r
\r
        while (true) {\r
            System.out.println("Esperando datagrama.....");\r
\r
            //RECIBO DATAGRAMA\r
            recibidos = new byte[1024];\r
            DatagramPacket paqRecibido = new DatagramPacket(recibidos, recibidos.length);\r
            serverSocket.receive(paqRecibido);\r
            cadena = new String(paqRecibido.getData());\r
\r
            //DIRECCION ORIGEN\r
            InetAddress IPOrigen = paqRecibido.getAddress();\r
            int puerto = paqRecibido.getPort();\r
            System.out.println("\\tOrigen: " + IPOrigen + ":" + puerto);\r
            System.out.println("\\tMensaje recibido: " + cadena.trim());\r
\r
            //CONVERTIR CADENA A MAY\xDASCULA\r
            String mayuscula = cadena.trim().toUpperCase();\r
            enviados = mayuscula.getBytes();\r
\r
            //ENVIO DATAGRAMA AL CLIENTE\r
            DatagramPacket paqEnviado = new DatagramPacket(enviados, enviados.length, IPOrigen, puerto);\r
            serverSocket.send(paqEnviado);\r
\r
            // Condici\xF3n de finalizaci\xF3n\r
            if (cadena.trim().equals("*")) {\r
                break;\r
            }\r
\r
        }//Fin de while\r
\r
        serverSocket.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.4.4 Multicast socket\r
\r
La clase MulticastSocket es \xFAtil para enviar paquetes a m\xFAltiples destinos simult\xE1neamente.\r
\r
Para poder recibir estos paquetes es necesario establecer un grupo multicast, que es un grupo de direcciones IP que comparten el mismo n\xFAmero de puerto.\r
\r
Cuando se env\xEDa un mensaje a un grupo de multicast, todos los que pertenezcan a ese grupo recibir\xE1n el mensaje.\r
\r
La pertenencia al grupo es transparente al emisor, es decir, el emisor no conoce el n\xFAmero de miembros del grupo ni sus direcciones IP.\r
\r
::: info Grupo multicast\r
\r
Un grupo multicast se especifica mediante una direcci\xF3n IP de clase D y un n\xFAmero de puerto UDP est\xE1ndar.\r
\r
Las direcciones desde la 224.0.0.0 a la 239.255.255.255 est\xE1n destinadas para ser direcciones de multicast.\r
\r
La direcci\xF3n 224.0.0.0 est\xE1 reservada y no debe ser utilizada.\r
:::\r
\r
Los m\xE9todos que proporciona la clase MulticastSocket son\r
\r
| M\xE9todo | Descripci\xF3n |\r
| --- | ----------- |\r
|  MulticastSocket() throws IOException  | Construye un socket multicast dejando al SO que asigne un puerto libre. |\r
|  MulticastSocket(int port) throws IOException  | Construye un socket multicast y lo conecta al puerto local especificado. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Env\xEDa un DatagramPacket a trav\xE9s del socket. |\r
| joinGroup( InetAddress multicastAddress) | Permite al socket unirse al grupo de multicast. A partir de ese momento podr\xE1 recibir los mensajes que se env\xEDan a esa direcci\xF3n. Un MulticastSocket puede estar unido a m\xE1s de un grupo multicast. |\r
| leaveGroup( InetAddress multicastAddress) | Permite al socket abandonar el grupo de multicast |\r
\r
Y a continuaci\xF3n presentamos el esquema de llamadas seguido por un **servidor multicast**\r
\r
1. Se crea el socket multicast. No hace falta especificar puerto\r
    > MulticastSocket ms = new MulticastSocket();\r
\r
2. Se define el puerto multicast\r
    > int Puerto = 12345;\r
\r
3. Se crea el grupo multicast\r
    > InetAddress grupo = InetAddress.getByName(\u201C225.0.0.1\u201D);\r
\r
4. Se crea el datagrama\r
    > DatagramPacket paquete = new DatagramPacket(msg.getBytes(), msg.length(), grupo, Puerto);\r
\r
5. Se env\xEDa el paquete al grupo\r
    > ms.send(paquete);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
y el esquema de llamadas seguido por un **cliente multicast**\r
\r
1. Se crea un socket multicast en el puerto establecido\r
    > MulticastSocket ms = new MulticastSocket(12345);\r
\r
2. Se configura la IP del grupo al que nos conectaremos\r
    > InetAddress grupo = InetAddress.getByName(\u201C225.0.0.1\u201D);\r
\r
3. Se une al grupo\r
    > ms.joinGroup(grupo);\r
\r
4. Recibe el paquete del servidor multicast\r
\r
    > byte[] buf = new byte[1000];\r
DatagramPacket recibido = new DatagramPacket(buf, buf.length);\r
ms.receive(recibido);\r
\r
5. Salimos del grupo multicast:\r
    > ms.leaveGroup(grupo);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
Y ahora lo vemos todo junto con un ejemplo\r
\r
\`\`\`java\r
public class U4_BasicMulticastServer {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // Enviamos la informaci\xF3n introducida por teclado hasta que se env\xEDe un *        \r
        Scanner in = new Scanner(System.in);\r
\r
        //Se crea el socket multicast.\r
        MulticastSocket ms = new MulticastSocket();\r
        // Se escoge un puerto para el server\r
        int puerto = 12345;\r
        // Se escoge una direcci\xF3n para el grupo\r
        InetAddress grupoMulticast = InetAddress.getByName("225.0.0.1");\r
\r
        String cadena = "";\r
        while (!cadena.trim().equals("*")) {\r
\r
            System.out.print("Datos a enviar al grupo: ");\r
            cadena = in.nextLine();\r
\r
            // Enviamos el mensaje a todos los clientes que se hayan unido al grupo\r
            DatagramPacket paquete = new DatagramPacket(cadena.getBytes(), cadena.length(), grupoMulticast, puerto);\r
            ms.send(paquete);\r
        }\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class U4_BasicMulticastClient {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Se crea el socket multicast\r
        // El puerto debe ser el mismo en todos los clientes, ya que el \r
        // servidor multicast env\xEDa la informaci\xF3n a la IP multicast y a un puerto\r
        int puerto = 12345;//Puerto multicast\r
        MulticastSocket ms = new MulticastSocket(puerto);\r
\r
        //Nos unimos al grupo multicast\r
        InetAddress grupo = InetAddress.getByName("225.0.0.1");\r
        ms.joinGroup(grupo);\r
        String msg = "";\r
\r
        while (!msg.trim().equals("*")) {\r
            // El buffer se crea dentro del bucle para que se sobrescriba \r
            // con cada nuevo mensaje\r
            byte[] buf = new byte[1000];\r
            DatagramPacket paquete = new DatagramPacket(buf, buf.length);\r
            //Recibe el paquete del servidor multicast\r
            ms.receive(paquete);\r
            msg = new String(paquete.getData());\r
            System.out.println("Recibo: " + msg.trim());\r
        }\r
\r
        // Abandonamos grupo\r
        ms.leaveGroup(grupo);\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
::: info mezcla de sockets en una app\r
Ya hemos visto todo el abanico de posibilidades que tenemos para comunicar dos procesos en red.\r
\r
A partir de este momento, en nuestras aplicaciones no s\xF3lo tenemos que elegir uno de ellos, sino que podemos tener varios sockets, de diferente tipo, para comunicar los clientes y los servidores.\r
\r
Se trata ahora de analizar en qu\xE9 situaci\xF3n es m\xE1s conveniente un tipo que otro y usarlo. Podemos ayudarnos de la creaci\xF3n de hilos que est\xE9n "especializados" en el env\xEDo y/o recepci\xF3n de informaci\xF3n de un socket, permitiendo que se intercambien varios mensajes a la vez.\r
:::\r
`]},{title:"4.5 Stateful protocols",headers:[{level:2,title:"4.5.1. Stateful and stateless protocols",slug:"_4-5-1-stateful-and-stateless-protocols",link:"#_4-5-1-stateful-and-stateless-protocols",children:[{level:3,title:"Stateless protocols",slug:"stateless-protocols",link:"#stateless-protocols",children:[]},{level:3,title:"Stateful protocols",slug:"stateful-protocols",link:"#stateful-protocols",children:[]}]},{level:2,title:"4.5.2 Programaci\xF3n de servidores basados en estados",slug:"_4-5-2-programacion-de-servidores-basados-en-estados",link:"#_4-5-2-programacion-de-servidores-basados-en-estados",children:[{level:3,title:"Programaci\xF3n de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.5.3. Ejemplo de servidor con estados",slug:"_4-5-3-ejemplo-de-servidor-con-estados",link:"#_4-5-3-ejemplo-de-servidor-con-estados",children:[{level:3,title:"Ejemplo del Worker que implementa el protocolo",slug:"ejemplo-del-worker-que-implementa-el-protocolo",link:"#ejemplo-del-worker-que-implementa-el-protocolo",children:[]}]},{level:2,title:"4.5.4. Ejemplo de cliente con estados",slug:"_4-5-4-ejemplo-de-cliente-con-estados",link:"#_4-5-4-ejemplo-de-cliente-con-estados",children:[{level:3,title:'Ejemplo de cliente "gen\xE9rico" que implementa el protocolo',slug:"ejemplo-de-cliente-generico-que-implementa-el-protocolo",link:"#ejemplo-de-cliente-generico-que-implementa-el-protocolo",children:[]}]}],path:"/en/unit4/stateful-protocols.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.5 Stateful protocols\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.5 Stateful protocols" />\r
\r
# 4.5 Stateful protocols\r
\r
[[toc]]\r
\r
## 4.5.1. Stateful and stateless protocols\r
\r
Como ya hemos comentado anteriormente, un protocolo, aplicado al mundo de las comunicaciones inform\xE1ticas, es un conjunto de reglas que especifican la manera en la que se realiza la comunicaci\xF3n entre dos interlocutores.\r
\r
Este conjunto de reglas establece el formato de los mensajes que se intercambian \`(texto, binario, JSON, XML, CSV, ...)\`, las acciones que cada uno de los extremos de la comunicaci\xF3n deben realizar en cada momento \`(env\xEDo o recepci\xF3n)\` y, lo que nos ocupa en este apartado del tema, si las acciones dependen de acciones anteriores o no.\r
\r
### Stateless protocols\r
\r
En inform\xE1tica, un protocolo sin estado es un protocolo de comunicaciones que trata cada petici\xF3n como una transacci\xF3n independiente que no tiene relaci\xF3n con cualquier solicitud anterior, de modo que la comunicaci\xF3n se compone de pares independientes de solicitud y respuesta.\r
[Wikipedia: Protocolo sin estado](https://es.wikipedia.org/wiki/Protocolo_sin_estado)\r
\r
El ejemplo m\xE1s conocido de protocolo sin estado es HTTP.1\u200B El protocolo no proporciona medio alguno de almacenamiento de datos de un usuario entre las peticiones, dejando esta tarea a niveles superiores y haciendo necesario el reenv\xEDo de informaci\xF3n de manera continua para simular un funcionamiento con estado (cookies, cabeceras, etc.).\r
\r
### Stateful protocols\r
\r
Un protocolo sin estado no requiere que el servidor retenga informaci\xF3n de la sesi\xF3n o de estado acerca de los intercambios de informaci\xF3n durante la realizaci\xF3n de m\xFAltiples peticiones. En contraste, un protocolo que requiere el mantenimiento del **estado interno en el servidor** se conoce como un **protocolo con estado**.\r
\r
Por lo tanto, un estado es una configuraci\xF3n en un programa o m\xE1quina que depende de los estados anteriores y que determina el funcionamiento del sistema, en funci\xF3n de la entrada recibida y del estado actual en el que se encuentre el sistema.\r
\r
Poniendo una analog\xEDa, podemos tomar una solicitud a la administraci\xF3n, donde debemos realizar varios pasos hasta resolver la solicitud.\r
\r
1. En primer lugar se rellena una instancia con los datos y se env\xEDa al departamento correspondiente.\r
2. Ese departamento comprobar\xE1 la instancia recibida y contestar\xE1 solicitando informaci\xF3n adicional o confirmando que la solicitud se ha recibido correctamente.\r
3. En un proceso posterior, se solicita un pago de tasas al usuario.\r
4. El usuario tiene que realizar el pago de tasas y enviar el justificante.\r
5. Tras cotejar toda la informaci\xF3n, se le solicita al usuario que aporte los documentos originales.\r
6. El usuario se persona para mostrar la documentaci\xF3n original\r
7. Finalmente se resuelve la solicitud informando al usuario el resultado de la misma.\r
\r
Esto, que puede ser un procedimiento normal, refleja claramente un proceso en el que se siguen una serie de pasos y cuyo orden no se puede cambiar.\r
\r
Por ejemplo, no tendr\xEDa sentido hacer el pago de las tasas (paso 4) sin antes haber presentado la solicitud (paso 1) o sin haber recibido la confirmaci\xF3n de que la solicitud est\xE1 completa.\r
\r
Esto mismo pasa con algunos protocolos de comunicaci\xF3n.\r
\r
## 4.5.2 Programaci\xF3n de servidores basados en estados\r
\r
Hay toda una teor\xEDa matem\xE1tica, \`la teor\xEDa de grafos\`, desarrollada en torno a esto, junto con un modelo computacional, \`los aut\xF3matas finitos\`, que estudian y optimizan el desarrollo de aplicaciones basadas en estados.\r
\r
La teor\xEDa de grafos es una rama de las matem\xE1ticas y las ciencias de la computaci\xF3n que estudia las propiedades de los grafos\r
\r
La teor\xEDa de grafos tiene sus fundamentos en las \`matem\xE1ticas discretas\` y de las \`matem\xE1ticas aplicadas\`. Esta teor\xEDa requiere de diferentes conceptos de diversas \xE1reas como **combinatoria, \xE1lgebra, probabilidad, geometr\xEDa de pol\xEDgonos, aritm\xE9tica y topolog\xEDa**. Actualmente ha tenido mayor influencia en el campo de la inform\xE1tica, las ciencias de la computaci\xF3n y telecomunicaciones. Debido a la gran cantidad de aplicaciones en la optimizaci\xF3n de recorridos, procesos, flujos y algoritmos de b\xFAsquedas, entre otros\r
\r
Un aut\xF3mata finito o m\xE1quina de estado finito es un modelo computacional que toma decisiones de computaci\xF3n de forma autom\xE1tica sobre una entrada para producir una salida.\r
\r
Este modelo est\xE1 conformado por un alfabeto, un conjunto de estados finito, una funci\xF3n de transici\xF3n, un estado inicial y un conjunto de estados finales.\r
\r
La finalidad de los aut\xF3matas finitos, entre otras, es la de reconocer lenguajes regulares, que corresponden a los lenguajes formales m\xE1s simples seg\xFAn la Jerarqu\xEDa de Chomsky.\r
\r
### Programaci\xF3n de aplicaciones Cliente y/o Servidor\r
\r
Como en todos los casos que hemos estudiado con anterioridad, el protocolo es la pieza com\xFAn entre los clientes y los servidores.\r
\r
Nuestros clientes podr\xE1n estar bien o mal programados, de hecho muchos de nuestros clientes son interactivos, por lo que podemos alterar el orden de los comandos a nuestro antojo, no siendo esto ning\xFAn problema.\r
\r
Debe ser el servidor el que tenga el control del proceso, el que asegure la integridad del sistema y de los datos, por lo tanto va a ser en la parte del servidor donde tengamos que realizar las modificaciones para adaptarlo al control y gesti\xF3n de los estados.\r
\r
Esto no quita que los clientes deban seguir \`sincronizados\` con el servidor para evitar situaciones de interbloqueo, ya que de una forma u otra el cliente siempre debe seguir el protocolo, aunque no los estados tal y como hemos dicho.\r
\r
## 4.5.3. Ejemplo de servidor con estados\r
\r
Vamos a ver qu\xE9 pasos debemos seguir para controlar los estados en el servidor y c\xF3mo adaptar un cliente.\r
\r
El ejemplo que vamos a utilizar es el de la actividad  \`U4A03_ProtocoloSaludo\`. Primero vamos a aclarar c\xF3mo debe funcionar este protocolo.\r
\r
Si el cliente est\xE1 bien programado, el intercambio de informaci\xF3n entre Cliente y Servidor se realiza en tres pasos\r
\r
1. Cliente env\xEDa "Hi Server!"\r
2. Servidor responde "Hi Client!"\r
3. Cliente responde "By Server!"\r
\r
Ante un funcionamiento normal, este protocolo es bastante f\xE1cil de implementar. Sin embargo,\r
\r
- \xBFQu\xE9 pasa si el cliente env\xEDa "By Server!" como primer mensaje?\r
- \xBFQu\xE9 debe responder el servidor si no recibe el mensaje que est\xE1 esperando?\r
- \xBFQu\xE9 debe hacer el cliente si no recibe el mensaje que est\xE1 esperando?\r
\r
Estas son las circunstancias a las que debemos responder con los estados del protocolo, indicando en cada caso qu\xE9 debe hacer cada una de las partes. Todo depender\xE1 de la funcionalidad que est\xE9 implementando el protocolo.\r
\r
Cada caso es diferente, por ejemplo, si es importante hacer los tres pasos en orden, ante cualquier fallo se debe volver a empezar (un borrado en una BD, una autenticaci\xF3n de tres v\xEDas). Si por el contrario, los dos primeros pasos se tienen que realizar de forma conjunta, pero el tercero es independiente, si el incumplimiento del protocolo se produce en ese momento, no es necesario que se repitan los dos primeros pasos, sino que s\xF3lo ser\xE1 necesario repetir el \xFAltimo.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Estado Hi\\nEsperando al saludo\r
    Bye: Estado Bye\\nEsperando la despedida\r
    [*] -> Hi\r
    Hi -> Hi : Mensaje incorrecto\\nSe env\xEDa error al cliente\r
    Hi -> Bye : Se ha recibido el mensaje correcto\\nSe env\xEDa respuesta al cliente\r
    note left of Hi : Permanecemos en este estado\\nhasta que se reciba el mensaje correcto\r
    Bye -> Hi : Mensaje incorrecto\\nSe env\xEDa error al cliente\r
    Bye -> [*] : Se ha recibido el mensaje correcto\\nSe cierra la conexi\xF3n con el cliente\r
-->\r
\r
### Ejemplo del Worker que implementa el protocolo\r
\r
\`\`\`java{12,17,34,50,61,71}\r
public class U4A03_SaludoWorker extends Thread {\r
\r
    Socket socketCliente;\r
    BufferedReader entrada;\r
    PrintWriter salida;\r
\r
    private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\r
    U4A03_SaludoWorker(Socket socketCliente) {\r
        this.socketCliente = socketCliente;\r
        // Inicializamos el valor del estado al estado inicial\r
        estado = Estados.HI;\r
    }\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Recibe lo que env\xEDa el cliente hasta que el mensaje sea\r
            // END OF TRANSMISSION\r
            while (estado != Estados.END) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
\r
                // Comprobamos si se ha cerrado el extremo cliente del socket\r
                // Y damos por concluida la comunicaci\xF3n.\r
                if (str == null) {\r
                    estado = Estados.END;\r
                } else {\r
                    // Mostramos la informaci\xF3n recibida por consola\r
                    System.out.println("CLIENTE > " + str);\r
                }\r
\r
                // Controlamos la respuesta en funci\xF3n del mensaje recibido y \r
                // el estado actual\r
                switch (estado) {\r
                    case HI:\r
                        if (messages[0].equals(str)) {\r
                            // Enviamos respuesta al cliente\r
                            salida.println(messages[1]);\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.BYE;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                        }\r
                        break;\r
                    case BYE:\r
                        if (messages[2].equals(str)) {\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.END;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                            estado = Estados.HI;\r
                        }\r
                        break;\r
                    case END:\r
                        // No ser\xEDa necesario contemplarlo en este caso\r
                        // Pero s\xED en otros en los que se tenga que enviar \r
                        // alg\xFAn mensaje antes de salir.\r
                        break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("Error de comunicaci\xF3n con el cliente");\r
        } catch (Exception e) {\r
            System.out.println(e.getLocalizedMessage());\r
            e.printStackTrace();\r
        } finally {\r
            try {\r
                entrada.close();\r
                System.out.println("Conexi\xF3n cerrada: " + socketCliente);\r
                socketCliente.close();\r
            } catch (IOException e) {\r
                System.out.println("Error inesperado cerrando los recursos");\r
            }\r
        }\r
    }\r
}\r
\`\`\`\r
\r
El c\xF3digo corresponde al worker de un servidor multihilo. Analicemos ahora el c\xF3digo por partes\r
\r
Es recomendable usar propiedades para guardar los mensajes que queramos comparar y tener un ENuM para definir los estados. Los \`enum\` en Java permiten ser usados en los bloques switch-case.\r
\r
La propiedad **estado** va a ser el punto central que controle el flujo de ejecuci\xF3n del servidor.\r
\r
\`\`\`java:no-line-numbers {6}\r
private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\`\`\`\r
\r
En el constructor, adem\xE1s de todas las propiedades, inicializamos el estado, asign\xE1ndole el valor del estado inicial.\r
\r
\`\`\`java:no-line-numbers{4}\r
U4A03_SaludoWorker(Socket socketCliente) {\r
    this.socketCliente = socketCliente;\r
    // Inicializamos el valor del estado al estado inicial\r
    estado = Estados.HI;\r
}\r
\`\`\`\r
\r
El servidor estar\xE1 ejecut\xE1ndose hasta que se alcance el estado final\r
\r
\`\`\`java:no-line-numbers\r
// Recibe lo que env\xEDa el cliente hasta que el mensaje sea\r
// END OF TRANSMISSION\r
while (estado != Estados.END) {\r
\`\`\`\r
\r
En este ejemplo, el intercambio de informaci\xF3n con el cliente se hace uno a uno, es decir se recibe un mensaje y se env\xEDa una respuesta, pero no tiene porqu\xE9 ser as\xED, se pueden recibir varios mensajes y no enviar respuesta, o cualquier combinaci\xF3n de env\xEDo respuesta que nos imaginemos.\r
\r
El c\xF3digo que sigue e un control para saber si el cliente ha cerrado el socket, as\xED evitamos tener excepciones de tipo NullPointerException o dejar al servidor en un bucle infinito. Forzamos la salida cambiando el estado del protocolo.\r
\r
\`\`\`java:no-line-numbers{4}\r
// Comprobamos si se ha cerrado el extremo cliente del socket\r
// Y damos por concluida la comunicaci\xF3n.\r
if (str == null) {\r
    estado = Estados.END;\r
} else {\r
    // Mostramos la informaci\xF3n recibida por consola\r
    System.out.println("CLIENTE > " + str);\r
}\r
\`\`\`\r
\r
Este es el c\xF3digo que implementa el diagrama de estados que he dise\xF1ado para esta actividad.\r
Fijaos que el servidor tiene que realizar una comprobaci\xF3n para cada l\xEDnea que sale de un estado. En este caso al ser s\xF3lo dos l\xEDneas, sirve con un if-else, pero puede ser un n\xFAmero mayor de opciones.\r
\r
Adem\xE1s, una de las opciones tiene un comportamiento totalmente diferente al resto, ya que **cuando se recibe el mensaje final, el protocolo no dice que enviemos una respuesta al cliente**.\r
\r
Esto \`debemos controlarlo en el cliente\`, porque si lo programamos de forma que env\xEDe un mensaje y espere una respuesta, puede quedarse bloqueado en la lectura. Aprovechando que este es el \xFAltimo mensaje, m\xE1s adelante veremos c\xF3mo se ha solventado en el cliente.y las opciones que tenemos para evitar posibles bloqueos como este.\r
\r
\`\`\`java:no-line-numbers{16}\r
// Controlamos la respuesta en funci\xF3n del mensaje recibido y \r
// el estado actual\r
switch (estado) {\r
    case HI:\r
        if (messages[0].equals(str)) {\r
            // Enviamos respuesta al cliente\r
            salida.println(messages[1]);\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.BYE;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
        }\r
        break;\r
    case BYE:\r
        if (messages[2].equals(str)) {\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.END;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
            estado = Estados.HI;\r
        }\r
        break;\r
    case END:\r
        // No ser\xEDa necesario contemplarlo en este caso\r
        // Pero s\xED en otros en los que se tenga que enviar \r
        // alg\xFAn mensaje antes de salir.\r
        break;\r
}\r
\`\`\`\r
\r
## 4.5.4. Ejemplo de cliente con estados\r
\r
Aunque un cliente interactivo como los que usamos para las pruebas no deber\xEDan cambiar su funcionalidad, s\xED hay que hacer peque\xF1os ajustes para adaptar su funcionamiento a las posibles respuestas y errores que env\xEDa el servidor.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/client_sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Env\xEDo mensaje\r
    Bye: Recibo mensaje\r
    [*] -> Hi\r
    Hi -> Bye : Se env\xEDa un mensaje\\nSe espera la respuesta del servidor\r
    Bye -> Hi : Se muestra la respuesta del servidor\r
    note left of Hi : Se env\xEDan mensajes\\nmientras el servidor mantenga\\nla conexi\xF3n abierta   \r
    Hi -> [*] : Se ha detectado el cierre\\nde la conexi\xF3n con el servidor\r
-->\r
\r
Como ya hemos dicho en el c\xF3digo del servidor, si implementamos el protocolo como un cliente de env\xEDo-respuesta, hay un caso en el que no debemos esperar una respuesta. Este es el caso de la salida, en la que se env\xEDa un mensaje pero no esperamos respuesta por parte del servidor.\r
\r
Se puede pensar en poner una condici\xF3n de salida para cuando el cliente env\xEDa el \xFAltimo mensaje, pero no podemos asegurar que ese mensaje cerrar\xE1 la comunicaci\xF3n, porque depender\xE1 del estado en el que se encuentre el servidor.\r
\r
### Ejemplo de cliente "gen\xE9rico" que implementa el protocolo\r
\r
\`\`\`java{39,41}\r
public class U4A03_SaludoClient {\r
\r
    private static final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que est\xE1 en la misma m\xE1quina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket(args[0], Integer.parseInt(args[1]));\r
\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexi\xF3n");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenv\xEDa al servidor hasta que se env\xEDa \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
            // Recibe la respuesta del servidor por el InputStream\r
            linea = entrada.readLine();\r
            if (linea == null) {\r
                // Comprobamos si se ha cerrado el extremo servidor del socket\r
                // Y damos por concluida la comunicaci\xF3n.\r
                break;\r
            } else {\r
                // Env\xEDa a la salida est\xE1ndar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            }\r
        } while (true);\r
\r
        // Libera recursos\r
        salida.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\`\`\`\r
\r
El c\xF3digo corresponde a un cliente interactivo gen\xE9rico, que va enviando mensajes y esperando la respuesta de los mismos sin hacer ning\xFAn tipo de control sobre lo que se env\xEDa o lo que recibe.\r
\r
Analicemos algunos aspectos del c\xF3digo del cliente\r
\r
La parte que sigue es equivalente a la que hemos usado en el servidor. No modificamos el flujo env\xEDo-recepci\xF3n, pero s\xED que comprobamos si el lado del servidor ha cerrado el socket (ha realizado todo el protocolo correctamente) para decidir que el cliente finalice su ejecuci\xF3n.\r
\r
\`\`\`java:no-line-numbers{3}\r
// Recibe la respuesta del servidor por el InputStream\r
linea = entrada.readLine();\r
if (linea == null) {\r
    // Comprobamos si se ha cerrado el extremo servidor del socket\r
    // Y damos por concluida la comunicaci\xF3n.\r
    break;\r
} else {\r
    // Env\xEDa a la salida est\xE1ndar la respuesta del servidor\r
    System.out.println("SERVIDOR > " + linea);\r
}\r
} while (true);\r
\`\`\`\r
\r
::: warning Lectura con timeout\r
Otra manera distinta de hacer lo mismo es usando lecturas con timeout.\r
\r
En este ejemplo podr\xEDamos haber comprobado si el mensaje enviado es el mensaje de finalizaci\xF3n. Es ese caso, si todo ha ido bien, no deber\xEDamos esperar una respuesta por parte del server, pero si ha habido alg\xFAn error, s\xED debemos realizar una lectura del socket.\r
\r
Usando este c\xF3digo\r
\r
\`\`\`java\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenv\xEDa al servidor hasta que se env\xEDa \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
\r
            // Si enviamos el mensaje de salida, no hacemos una lectura indefinida\r
            if (linea.equals(messages[2])) {\r
                socketCliente.setSoTimeout(100);\r
            } else {\r
                socketCliente.setSoTimeout(0);\r
            }\r
\r
            try { \r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Env\xEDa a la salida est\xE1ndar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            } catch (SocketTimeoutException ste) {\r
                // Pasado el timeout no se ha recibido una respuesta\r
                // Podemos suponer que el server no env\xEDa respuesta\r
                // Eso indica que el protocolo se ha completado\r
                // Damos por concluida la comunicaci\xF3n.\r
                break;\r
            }            \r
        } while (true);\r
\`\`\`\r
\r
fijamos un tiempo de espera pasado el cual se producir\xE1 una \`SocketTimeoutException\` indicando que no se ha le\xEDdo nada del socket. Si por el contrario se lee informaci\xF3n del socket, esta se muestra por la consola.\r
\r
En este caso en concreto, esta soluci\xF3n no funciona porque el servidor ya ha cerrado el socket. Esto ser\xEDa \xFAtil cuando tengamos que hacer una \`lectura opcional\` en mitad de un protocolo, y servir\xEDa tanto para un cliente como para un servidor.\r
:::\r
`]},{title:"4.1 TCP IP protocol stack",headers:[{level:2,title:"4.1.1. TCP/IP Layers",slug:"_4-1-1-tcp-ip-layers",link:"#_4-1-1-tcp-ip-layers",children:[]},{level:2,title:"4.1.2. Addresses and ports - Sockets",slug:"_4-1-2-addresses-and-ports-sockets",link:"#_4-1-2-addresses-and-ports-sockets",children:[{level:3,title:"IP Addresses",slug:"ip-addresses",link:"#ip-addresses",children:[]},{level:3,title:"Ports",slug:"ports",link:"#ports",children:[]},{level:3,title:"Sockets",slug:"sockets",link:"#sockets",children:[]}]},{level:2,title:"4.1.3 TCP vs UDP",slug:"_4-1-3-tcp-vs-udp",link:"#_4-1-3-tcp-vs-udp",children:[]}],path:"/en/unit4/tcp-ip.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.1 TCP IP protocol stack\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.1 TCP IP protocol stack" />\r
\r
# 4.1 TCP IP protocol stack\r
\r
[[toc]]\r
\r
## 4.1.1. TCP/IP Layers\r
\r
The TCP/IP Stack, or the internet protocol suite, is a set of communication protocols used by the Internet or similar networks.\r
\r
TCP/IP is the world's most widely-used non-proprietary protocol suite because it enables computers using diverse hardware and software platforms, on different types of networks, to communicate. The protocols work equally well in both LANs and WANs.\r
\r
TCP/IP is a collection of protocols named after its two best-known and most important protocols, the \`Transmission Control Protocol (TCP)\` and the \`Internet Protocol (IP)\`. As well as these relatively low-level protocols, TCP/IP includes several higher level protocols that facilitate common applications such as electronic mail, terminal emulation, and file transfer.\r
\r
::: info Protocol RFC\r
Each Internet protocol, together with any subsequent amendments, is described in a document known as a Request For Comments (RFC).\r
\r
A list of RFCs is available at: [http://www.ietf.org/rfc.html](http://www.ietf.org/rfc.html).\r
:::\r
\r
It is called a **stack** because it is typically designed as a hierarchy of layers, each supporting the one above it and using those below it. Each layer solves a specific set of problems involving the transmission of data and provides well-defined services to the layers above it.\r
\r
The TCP/IP model has four layers. From lowest to highest, these are the link layer, the internet layer, the transport layer, and the application layer, as shown below.\r
\r
![TCP/IP real communication flow](../../media/unit4/1-ip-real-communication-flow.gif)\r
\r
- The **link layer** provides the interface with the underlying network hardware and physical wired or wireless connection media.\r
- The **internetwork layer** provides addressing and routing functions that ensures messages are delivered to their destination. Internet Protocol (IP) is the most important protocol in this layer and probably on the whole stack.\r
- The **transport layer** oversees the end-to-end transfer of data, and can handle a number of data streams simultaneously. The main transport layer protocol is \`Transmission Control Protocol (TCP)\`, which provides a reliable, connection-oriented service. \`User Datagram Protocol (UDP)\` provides an unreliable, connectionless service.\r
- An **application layer** protocol is specific to a particular type of application (e.g. file transfer, electronic mail, network management etc.) and is sometimes embodied within the application's client software, although it could also be implemented within the operating system software. The interface between an application layer protocol and a transport layer protocol is defined with reference to \`port numbers\` and \`sockets\`.\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.1-ip-protocols.png)\r
\r
## 4.1.2. Addresses and ports - Sockets\r
\r
### IP Addresses\r
\r
Each host on a TCP/IP network is assigned a unique IP address consisting of a network number and a host number. The network number identifies a specific network. The host number identifies a host on a network and is assigned by the network administrator.\r
\r
Ipv4 IP address are 32-bit addresses. The IP address is grouped into four binary octets (an octet is a group of eight bits) and is represented using dotted decimal notation. The minimum value for an octet is 0, and the maximum value is 255.\r
\r
> 192.168.0.100\r
>\r
> 127.0.0.1\r
>\r
> 10.1.100.1\r
\r
IPv6 addresses are typically composed of a 64-bit network prefix, and a 64-bit host part. IPv6 addresses are normally written as eight groups of four hexadecimal numbers. A group consisting solely of zeros can be omitted. Leading zeros in a group can also be omitted.\r
\r
So the addresses below are all valid and equivalent to each other\r
\r
> 2001:0db8:0000:0000:0000:0000:1428:57ab\r
>\r
> 2001:0db8:0000:0000:0000::1428:57ab\r
>\r
> 2001:0db8:0:0:0:0:1428:57ab\r
>\r
> 2001:0db8:0:0::1428:57ab\r
>\r
> 2001:0db8::1428:57ab\r
>\r
> 2001:db8::1428:57ab\r
\r
![Routing](../../media/unit4/data_transfer.gif)\r
\r
### Ports\r
\r
An application process running on one computer that wants to communicate with an application process running on another computer identifies itself using a 16-bit port number, which is subsequently used by the transport layer protocol (TCP or UDP) to deliver incoming messages.\r
\r
Port numbers go from 0 to 65535, and they are grouped in three ranges\r
\r
| Port group                      | Port range    | Description                                                    |\r
| ------------------------------- | ------------- | -------------------------------------------------------------- |\r
| Well know ports or system ports | 0 - 1023      | Used by standard protocols and services                        |\r
| Registered ports                | 1024- 49151   | Reserved by companies and organizations for their own services |\r
| Ephemeral ports                 | 49152 - 65535 | For free use by clients and servers                            |\r
\r
Common server applications such as Telnet and FTP use one or more of the well known port numbers (these range between 1 and 1023). Most server applications only use one port, although some (like FTP) use two. The use of a specific port number by server applications allows the client process to send a request to a server without having to first find out which port is being used by the server application.\r
\r
> HTTP requests, for example, are addressed by default to port 80 on the server.\r
\r
The clients themselves do not need to use a well known port, since they are initiating the communication. A client process is dynamically allocated a port number (in the range 1024 to 65535) by the client operating system. This number is subsequently included in all datagrams sent to the server.\r
\r
### Sockets\r
\r
A \`socket\` is essentially an addressable end point in a communication between two processes, and consists of a **unique combination of IP address, port number and transport layer protocol (usually TCP)**.\r
\r
When a client application wishes to communicate with a server application, the operating system creates a socket which is then used by the client application to receive incoming data from the server. The unique combination of transport protocol, IP address and port number allows the communication end point to be addressed by a process running on a remote server, and ensures that data is delivered to the process for which it is intended.\r
\r
The server application will have its own socket for communicating with the client, and a connection is established between client and server using the two socket addresses. The applications exchange information by writing to, or reading from, the sockets they have created.\r
\r
The connection used by a client process consists of two sockets, one at each end of the connection. The connection can thus be identified by a unique combination of four numbers - the source and destination IP addresses, together with the source and destination port numbers.\r
\r
It is possible for several client applications running on different computers to connect to the same destination socket on a server. So there is no confusion as to which computer a datagram is destined for, even if the source and destination ports are the same in each case.\r
\r
Using sockets, it is even possible for several client applications running on the same computer to connect to the same destination socket on a server. Datagrams sent to the client by the server contain the socket address for each client process, which includes the client process's individual port number, so there is no confusion as to which process a datagram is bound for.\r
\r
![TCP/IP logical communication flow](../../media/unit4/2-ip-logical-communication-flow.gif)\r
\r
As the real communication flow goes from one layer to the next or previous one, applications on each layer are abstracted from the underlying layers, so their communications flows to the same layer on the other side. In the TCP/IP stack different pieces of information are managed at each level as shown in the previous diagram.\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.0-The-TCP-IP-UDP-IP-Stack_Q640.jpg)\r
\r
As stated before, sockets are the bridge between application layer and transport layer. That's the point where our applications are going to be developed and run, giving service to higher level protocols.\r
\r
## 4.1.3 TCP vs UDP\r
\r
The \`Transmission Control Protocol (TCP)\` is a widely used connection-oriented transport layer protocol that provides reliable transfer of data between two end points, and includes mechanisms to handle flow-control, segmentation, error recovery, and multiplexing.\r
\r
The TCP transport service offers the following features:\r
\r
- Full duplex communication: both ends of a connection can transmit simultaneously\r
- Timing: timers are used to ensure that data is transmitted in a timely fashion\r
- Sequencing: message blocks are given sequence numbers to enable messages to be reassembled in the correct order before being passed to the application layer protocols on the destination computer\r
- Flow control: the flow of data is regulated using buffers and windows\r
- Error handling: checksums are provided to enable transmission errors to be detected and dealt with\r
\r
![TCP/IP logical communication flow](../../media/unit4/5-Graphic-UDP-Vs-TCP.png)\r
\r
The \`User Datagram Protocol (UDP)\` is an unreliable, connectionless protocol that works at the transport layer of TCP/IP, and provides a datagram delivery service to applications with a minimum of overhead. UDP provides a very simple interface between the application layer and the internetwork layer.\r
\r
UDP does not provide any guarantee of delivery, nor does it provide error recovery or flow control. No connection is established, and hence no handshaking procedure is required. Packets may arrive out of order, not arrive at all, or be duplicated.\r
\r
UDP is the transport protocol for a variety of application-layer protocols, including Simple Network Management Protocol (SNMP), Dynamic Host Configuration Protocol (DHCP), Routing Information Protocol (RIP), and the Domain Name System (DNS), as well as streaming media applications such as Voice over IP (VoIP).\r
\r
![TCP/IP logical communication flow](../../media/unit4/7-TCP-vs-UDP-differences.png)\r
`]},{title:"4.2 Auxiliary classes for networking",headers:[{level:2,title:"4.2.1. java.net.NetworkInterface",slug:"_4-2-1-java-net-networkinterface",link:"#_4-2-1-java-net-networkinterface",children:[]},{level:2,title:"4.2.2 java.net.InterfaceAddress",slug:"_4-2-2-java-net-interfaceaddress",link:"#_4-2-2-java-net-interfaceaddress",children:[]},{level:2,title:"4.2.3. java.net.InetAddress",slug:"_4-2-3-java-net-inetaddress",link:"#_4-2-3-java-net-inetaddress",children:[]},{level:2,title:"4.2.4 java.net.URL",slug:"_4-2-4-java-net-url",link:"#_4-2-4-java-net-url",children:[]},{level:2,title:"4.2.5 java.net.URLConnection",slug:"_4-2-5-java-net-urlconnection",link:"#_4-2-5-java-net-urlconnection",children:[]}],path:"/en/unit4/urls.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.2 Auxiliary classes for networking\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.2 Auxiliary classes for networking" />\r
\r
# 4.2 Auxiliary classes for networking\r
\r
[[toc]]\r
\r
## 4.2.1. java.net.NetworkInterface\r
\r
This class represents network interface, both software as well as hardware, its name, list of IP addresses assigned to it and all related information. It can be used in cases when we want to specifically use a particular interface for transmitting our packet on a system with multiple NICs.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/NetworkInterface.html)\r
\r
::: info What is a Network Interface?\r
A network interface can be thought of as a point at which your computer connects to the network. It is not necessarily a piece of hardware but can also be implemented in a software. For example a loopback interface which is used for testing purposes.\r
:::\r
\r
| Method                                                            | Description                                                                                                                                                                                         |\r
| ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public static Enumeration getNetworkInterfaces()                  | Returns all the network interfaces on the system.                                                                                                                                                   |\r
| public List getInterfaceAddresses()                               | Returns a list of all interface addresses on this interface.                                                                                                                                        |\r
| public Enumeration getInetAddresses()                             | Returns an enumeration of all InetAddresses bound to this network interface, if security manager allows it.                                                                                         |\r
| public String getName()                                           | Returns the name of this network interface.                                                                                                                                                         |\r
| public int getIndex()                                             | Returns the index assigned to this network interface by the system. Indexes can be used in place of long names to refer to any interface on the device.                                             |\r
| public String getDisplayName()                                    | This method returns the name of network interface in a readable string format.                                                                                                                      |\r
| public static NetworkInterface getByName(String name)             | Finds and returns the network interface with the specified name, or null if none exists.                                                                                                            |\r
| public static NetworkInterface getByIndex(int index)              | Performs similar function as the previous function with index used as search parameter instead of name.                                                                                             |\r
| public static NetworkInterface getByInetAddress(InetAddress addr) | This method is widely used as it returns the network interface the specified inetaddress is bound to. If an InetAddress is bound to multiple interfaces, any one of the interfaces may be returned. |\r
| public boolean isUp()                                             | Returns a boolean value indicating if this network interface is up and running.                                                                                                                     |\r
\r
\`\`\`java\r
// Java program to illustrate various java.net.NetworkInterface class methods.\r
\r
public class NetworkInterfaceExample\r
{\r
    public static void main(String[] args) throws SocketException,\r
                                                UnknownHostException\r
    {\r
\r
        // getNetworkInterfaces() returns a list of all interfaces\r
        // present in the system.\r
        ArrayList<NetworkInterface> interfaces = Collections.list(\r
                                            NetworkInterface.getNetworkInterfaces());\r
\r
        System.out.println("Information about present Network Interfaces...\\n");\r
        for (NetworkInterface iface : interfaces)\r
        {\r
            // isUp() method used for checking whether the interface in process\r
            // is up and running or not.\r
            if (iface.isUp())\r
            {\r
                // getName() method\r
                System.out.println("Interface Name: " + iface.getName());\r
\r
                // getDisplayName() method\r
                System.out.println("Interface display name: " + iface.getDisplayName());\r
\r
                // getHardwareAddress() method\r
                System.out.println("Hardware Address: " +\r
                                Arrays.toString(iface.getHardwareAddress()));\r
\r
                // getParent() method\r
                System.out.println("Parent: " + iface.getParent());\r
\r
                // getIndex() method\r
                System.out.println("Index: " + iface.getIndex());\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInterface addresses: ");\r
\r
                // getInterfaceAddresses() method\r
                for (InterfaceAddress addr : iface.getInterfaceAddresses())\r
                {\r
                    System.out.println("\\t\\t" + addr.getAddress().toString());\r
                }\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInetAddresses associated with this interface: ");\r
\r
                // getInetAddresses() method returns list of all\r
                // addresses currently bound to this interface\r
                Enumeration<InetAddress> en = iface.getInetAddresses();\r
                while (en.hasMoreElements())\r
                {\r
                    System.out.println("\\t\\t" + en.nextElement().toString());\r
                }\r
\r
                // getMTU() method\r
                System.out.println("\\tMTU: " + iface.getMTU());\r
\r
                // getSubInterfaces() method\r
                System.out.println("\\tSubinterfaces: " +\r
                                Collections.list(iface.getSubInterfaces()));\r
\r
                // isLoopback() method\r
                System.out.println("\\tis loopback: " + iface.isLoopback());\r
\r
                // isVirtual() method\r
                System.out.println("\\tis virtual: " + iface.isVirtual());\r
\r
                // isPointToPoint() method\r
                System.out.println("\\tis point to point: " + iface.isPointToPoint());\r
\r
                // supportsMulticast() method\r
                System.out.println("Supports Multicast: " + iface.supportsMulticast());\r
\r
            }\r
        }\r
\r
        // getByIndex() method returns network interface\r
        // with the specified index\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
\r
        // toString() method is used to display textual\r
        // information about this network interface\r
        System.out.println("Network interface 1: " + nif.toString());\r
\r
        // getByName() method returns network interface\r
        // with the specified name\r
        NetworkInterface nif2 = NetworkInterface.getByName("eth0");\r
        InetAddress ip = InetAddress.getByName("localhost");\r
\r
        // getbyInetAddress() method\r
        NetworkInterface nif3 = NetworkInterface.getByInetAddress(ip);\r
        System.out.println("\\nlocalhost associated with: " + nif3);\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.2 java.net.InterfaceAddress\r
\r
This class represents a network interface address. Every device that has an IP address has an IP address on the network interface.\r
\r
In short it's an IP address, a subnet mask and a broadcast address when the address is an IPv4 one. An IP address and a network prefix length in the case of IPv6 address.\r
\r
> [java.net.InterfaceAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InterfaceAddress.html)\r
\r
| Method                                | Description                                                                                                                                                                     |\r
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public InetAddress getAddress()       | Returns an InetAddress for this address.                                                                                                                                        |\r
| public InetAddress getBroadcast()     | Returns the InetAddress for the broadcast address for this interface address. As only IPv4 addresses have broadcast addresses, null would be returned on using an IPv6 address. |\r
| public short getNetworkPrefixLength() | Returns the prefix length for this interface address, i.e. subnet mask for this address.                                                                                        |\r
\r
\`\`\`java\r
// Java program to illustrate methods of java.net.InterfaceAddress class\r
\r
public class InterfaceaddressExample\r
{\r
    public static void main(String[] args) throws SocketException\r
    {\r
        // Modify according to your system\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
        List<InterfaceAddress> list = nif.getInterfaceAddresses();\r
\r
        for (InterfaceAddress iaddr : list)\r
        {\r
            // getAddress() method\r
            System.out.println("getAddress() : " + iaddr.getAddress());\r
\r
            // getBroadcast() method\r
            System.out.println("getBroadcast() : " + iaddr.getBroadcast());\r
\r
            // getNetworkPrefixLength() method\r
            System.out.println("PrefixLength : " + iaddr.getNetworkPrefixLength());\r
\r
            // hashCode() method\r
            System.out.println("Hashcode : " + iaddr.hashCode());\r
\r
            // toString() method\r
            System.out.println("toString() : " + iaddr.toString());\r
        }\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.3. java.net.InetAddress\r
\r
Java InetAddress class represents an IP address. The java.net.InetAddress class provides methods to get the IP of any host name for example www.google.com, www.facebook.com, etc.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InetAddress.html)\r
\r
An instance of InetAddress represents the IP address with its corresponding host name. There are two types of addresses: Unicast and Multicast. The Unicast is an identifier for a single interface whereas Multicast is an identifier for a set of interfaces.\r
\r
::: warning Local Name Resolver (hosts file)\r
You should know that DNS translates domain names like into IP addresses. But did you know that there\u2019s a file on your system that can override that?\r
It\u2019s called your hosts file and lets you map specific domain names to an IP address of your choosing. Your HOSTS file only affects your computer, so you can use it to create custom URLs for IP addresses on your network, or you can use it to redirect certain websites.\r
\r
As you can imagine, editing the HOSTS file can easily break your internet if it\u2019s modified incorrectly or maliciously. So, it\u2019s not particularly easy for a normal user to edit. This is a good thing.\r
\r
- Windows\r
\r
The HOSTS file is normally stored in a plain text file in the Windows System folder.\r
\r
Hit the start menu or press the Windows key and start typing Notepad.\r
\r
Right-click Notepad and choose Run as administrator.\r
\r
In Notepad, click File then Open\u2026 In the File name field, paste the following path in:\r
\r
c:\\Windows\\System32\\Drivers\\etc\\hosts\r
\r
Now you\u2019ll be able to edit and save changes to your HOSTS file.\r
\r
To map a domain, add a line based on the examples in the HOSTS file.\r
\r
- OS X & GNU/Linux\r
\r
The file is in /etc/hosts and you should edit it with administrator privileges.\r
:::\r
\r
| Method                                                                       | Description                                                                      |\r
| ---------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |\r
| public static InetAddress getByName(String host) throws UnknownHostException | It returns the instance of  InetAddress containing LocalHost IP and name.        |\r
| public static InetAddress getLocalHost() throws UnknownHostException         | It returns the instance of InetAdddress  containing local host name and address. |\r
| public String getHostName()                                                  | It returns the host name of the IP address.                                      |\r
| public String getHostAddress()                                               | It returns the IP address in string format.                                      |\r
| public boolean isReachable(int timeout)                                      | This method tests whether that address is reachable.                             |\r
\r
\`\`\`java\r
\r
class InetAddressExample {\r
    public static void main(String[] args)\r
        throws UnknownHostException\r
    {\r
        // To get and print InetAddress of Local Host\r
        InetAddress address1 = InetAddress.getLocalHost();\r
        System.out.println("InetAddress of Local Host : "\r
                        + address1);\r
\r
        // To get and print InetAddress of Named Host\r
        InetAddress address2\r
            = InetAddress.getByName("45.22.30.39");\r
        System.out.println("InetAddress of Named Host : "\r
                        + address2);\r
\r
        // To get and print ALL InetAddresses of Named Host\r
        InetAddress address3[]\r
            = InetAddress.getAllByName("172.19.25.29");\r
        for (int i = 0; i < address3.length; i++) {\r
            System.out.println(\r
                "ALL InetAddresses of Named Host : "\r
                + address3[i]);\r
        }\r
\r
        // To get and print InetAddresses of\r
        // Host with specified IP Address\r
        byte IPAddress[] = { 125, 0, 0, 1 };\r
        InetAddress address4\r
            = InetAddress.getByAddress(IPAddress);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address : "\r
            + address4);\r
\r
        // To get and print InetAddresses of Host\r
        // with specified IP Address and hostname\r
        byte[] IPAddress2\r
            = { 105, 22, (byte)223, (byte)186 };\r
        InetAddress address5 = InetAddress.getByAddress(\r
            "gfg.com", IPAddress2);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address and hostname : "\r
            + address5);\r
    }\r
}\r
\r
\`\`\`\r
\r
::: question Host seeker (U4S4_HostSeeker)\r
Your computer is connected to a LAN (Local Area Network) and probably it is using private IP addresses.\r
\r
Addresses can be one of class C (192.168.X.Y), class B (172.17.X.Y) or class A (10.X.Y.Z). That depends on the network mask or network prefix used for the network interface configuration.\r
\r
You can also check it using Linux **ifconfig** command or Windows **ipconfig** command.\r
\r
Write a program to know which hosts are up and running in your network, that is, which hosts are reachable from you computer by using one of the interfaces.\r
\r
First, you can write specific code to test your network.\r
Once your app is working, try to make it generic and reusable by making it work in any network, detecting the network prefix and checking all the possible IPs in a network.\r
\r
The app will get a Network interface card name as argument and will check only the IPv4 addresses attached to that interface. We can know if an IP is IPv4 or IPv6 using the operator \`\xECnstanceof\` with Inet4Address and  Inet6Address subclasses of InetAddress\r
:::\r
\r
::: details Code for the example\r
\r
\`\`\`java\r
    // Code not visible yet\r
\`\`\`\r
\r
:::\r
\r
## 4.2.4 java.net.URL\r
\r
The Java URL class represents an URL. URL is an acronym for Uniform Resource Locator.\r
\r
> [java.net.URL specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html)\r
\r
It points to a resource on the World Wide Web. For example:\r
\r
> http://psp2dam.github.io/psp_pages/\r
\r
A URL contains many information:\r
\r
- **Protocol**: In this case, \`http\` is the protocol.\r
- **Server name or IP Address**: In this case, \`psp2dam.github.io\` is the server name.\r
- **Port Number**: It is an optional attribute. Many times it is derived from the protocol, by chosing its standard default port. In the example the port is missing but it is set to \`80\`.\r
- **File Name or directory name**: In this case, only the path (directory) is specified in the URL. Depending on the server configuration the file name can take a default value. In the example \`index.html\` is the file name.\r
\r
| Constructor                                                                        | Description                                                                                               |\r
| ---------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |\r
| URL(String spec)                                                                   | Creates an instance of a URL from the String representation.                                              |\r
| URL(String protocol, String host, int port, String file)                           | Creates an instance of a URL from the given protocol, host, port number, and file.                        |\r
| URL(String protocol, String host, int port, String file, URLStreamHandler handler) | Creates an instance of a URL from the given protocol, host, port number, file, and handler.               |\r
| URL(String protocol, String host, String file)                                     | Creates an instance of a URL from the given protocol name, host name, and file name.                      |\r
| URL(URL context, String spec)                                                      | Creates an instance of a URL by parsing the given spec within a specified context.                        |\r
| URL(URL context, String spec, URLStreamHandler handler)                            | Creates an instance of a URL by parsing the given spec with the specified handler within a given context. |\r
\r
The java.net.URL class provides many methods. The important methods of URL class are given below.\r
\r
| Method                                | Description                                                                                    |\r
| ------------------------------------- | ---------------------------------------------------------------------------------------------- |\r
| public String getProtocol()           | it returns the protocol of the URL.                                                            |\r
| public String getHost()               | it returns the host name of the URL.                                                           |\r
| public String getPort()               | it returns the Port Number of the URL.                                                         |\r
| public String getFile()               | it returns the file name of the URL.                                                           |\r
| public String getAuthority()          | it returns the authority of the URL.                                                           |\r
| public String toString()              | it returns the string representation of the URL.                                               |\r
| public String getQuery()              | it returns the query string of the URL.                                                        |\r
| public String getDefaultPort()        | it returns the default port of the URL.                                                        |\r
| public URLConnection openConnection() | it returns the instance of URLConnection i.e. associated with this URL.                        |\r
| public InputStream openStream()       | it opens a connection to this URL and returns an InputStream for reading from that connection. |\r
| public boolean equals(Object obj)     | it compares the URL with the given object.                                                     |\r
| public Object getContent()            | it returns the content of the URL.                                                             |\r
| public String getRef()                | it returns the anchor or reference of the URL.                                                 |\r
| public URI toURI()                    | it returns a URI of the URL.                                                                   |\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args) throws MalformedURLException{  \r
\r
    URL url=new URL("http://psp2dam.github.io/psp_pages");  \r
  \r
    System.out.println("Protocol: "+url.getProtocol());  \r
    System.out.println("Host Name: "+url.getHost());  \r
    System.out.println("Port Number: "+url.getPort());  \r
    System.out.println("File Name: "+url.getFile());  \r
}   \r
\`\`\`\r
\r
Let us see another example URL class in Java.\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args){    \r
    URL url=new URL("https://www.google.com/search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8");    \r
        \r
    System.out.println("Protocol: "+url.getProtocol());    \r
    System.out.println("Host Name: "+url.getHost());    \r
    System.out.println("Port Number: "+url.getPort());    \r
    System.out.println("Default Port Number: "+url.getDefaultPort());    \r
    System.out.println("Query String: "+url.getQuery());    \r
    System.out.println("Path: "+url.getPath());    \r
    System.out.println("File: "+url.getFile());      \r
}    \r
\`\`\`\r
\r
\`\`\`bash:no-line-numbers{3}\r
Protocol: https\r
Host Name: www.google.com\r
Port Number: -1\r
Default Port Number: 443\r
Query String: q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
Path: /search\r
File: /search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
\`\`\`\r
\r
## 4.2.5 java.net.URLConnection\r
\r
The Java URLConnection class represents a communication link between the URL and the application. It can be used to read and write data to the specified resource referred by the URL.\r
\r
> [java.net.URLConnection specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLConnection.html)\r
\r
URLConnection is an abstract class. The two subclasses \`HttpURLConnection\` and \`JarURLConnection\` makes the connection between the client Java program and URL resource on the internet.\r
\r
With the help of URLConnection class, a user can read and write to and from any resource referenced by an URL object. Once a connection is established and the Java program has an URLConnection object, we can use it to read or write or get further information like content length, etc.\r
\r
The URLConnection class provides many methods. We can display all the data of a webpage by using the getInputStream() method. It returns all the data of the specified URL in the stream that can be read and displayed.\r
\r
| Method                                | Description                                                                                    |\r
| ------------------------------------- | ---------------------------------------------------------------------------------------------- |\r
| void connect() | It opens a communications link to the resource referenced by this URL, if such a connection has not already been established. |\r
| Object getContent() | It retrieves the contents of the URL connection. |\r
| String getContentEncoding() | It returns the value of the content-encoding header field. |\r
| int getContentLength() | It returns the value of the content-length header field. |\r
| long getContentLengthLong() | It returns the value of the content-length header field as long. |\r
| String getContentType() | It returns the value of the date header field. |\r
| long getDate() | It returns the value of the date header field. |\r
| boolean getDoInput() | It returns the value of the URLConnection's doInput flag.|\r
| boolean getDoInput() | It returns the value of the URLConnection's doOutput flag.|\r
| String getHeaderField(int n) | It returns the value of nth header field|\r
| String getHeaderField(String name) | It returns the value of the named header field.|\r
| String getHeaderFieldKey(int n) | It returns the key for the nth header field.|\r
| Map<String, List&lt;String&gt;> getHeaderFields() | It returns the unmodifiable Map of the header field.|\r
| long getIfModifiedSince() | It returns the value of the object's ifModifiedSince field.|\r
| InputStream getInputStream() | It returns an input stream that reads from the open condition.|\r
| long getLastModified() | It returns the value of the last-modified header field.|\r
| OutputStream getOutputStream() | It returns an output stream that writes to the connection.|\r
| URL getURL() | It returns the value of the URLConnection's URL field.|\r
| void setDoInput(boolean doinput) | It sets the value of the doInput field for this URLConnection to the specified value.|\r
|void setDoOutput(boolean dooutput) | It sets the value of the doOutput field for the URLConnection to the specified value.|\r
\r
::: info How to get the object of URLConnection Class\r
The openConnection() method of the URL class returns the object of URLConnection class.\r
:::\r
\r
\`\`\`java{11}\r
// URLConnectionExample\r
public static void main(String[] args) throws MalformedURLException, IOException{\r
\r
    // Creating an object of URL class\r
\r
    // Custom input URL is passed as an argument\r
    URL u = new URL("www.google.com");\r
\r
    // Creating an object of URLConnection class to\r
    // communicate between application and URL\r
    URLConnection urlconnect = u.openConnection();\r
\r
    // Creating an object of InputStream class\r
    // for our application streams to be read\r
    InputStream stream\r
        = urlconnect.getInputStream();\r
\r
    BufferedReader in =  \r
        new BufferedReader(\r
            new InputStreamReader(stream));\r
    // Till the time URL is being read\r
    String line;\r
    while ((line = in.readLine()) != null) {\r
\r
        // Continue printing the stream\r
        System.out.println(line);\r
    }\r
}\r
\`\`\`\r
\r
::: question Images downloader (U4S7_ImagesDownloader)\r
Create an application to download images from a URL.\r
The image URL must be given as an application argument and the image has to be saved in a images folder on the root of your project.\r
:::\r
\r
::: details Code for the example\r
\r
\`\`\`java\r
    // Code not visible yet\r
\`\`\`\r
\r
:::\r
`]},{title:"6.4 Encriptaci\xF3n asim\xE9trica",headers:[{level:2,title:"6.4.1. Clave p\xFAblica y clave privada",slug:"_6-4-1-clave-publica-y-clave-privada",link:"#_6-4-1-clave-publica-y-clave-privada",children:[]},{level:2,title:"6.4.2. Firma digital",slug:"_6-4-2-firma-digital",link:"#_6-4-2-firma-digital",children:[{level:3,title:"Integridad",slug:"integridad",link:"#integridad",children:[]},{level:3,title:"Autenticaci\xF3n y no repudio",slug:"autenticacion-y-no-repudio",link:"#autenticacion-y-no-repudio",children:[]}]},{level:2,title:"6.4.3 Certificados digitales",slug:"_6-4-3-certificados-digitales",link:"#_6-4-3-certificados-digitales",children:[{level:3,title:"Claves digitales",slug:"claves-digitales",link:"#claves-digitales",children:[]},{level:3,title:"Infraestructura de clave p\xFAblica (PKI)",slug:"infraestructura-de-clave-publica-pki",link:"#infraestructura-de-clave-publica-pki",children:[]}]},{level:2,title:"6.4.4. Generaci\xF3n de pares de claves",slug:"_6-4-4-generacion-de-pares-de-claves",link:"#_6-4-4-generacion-de-pares-de-claves",children:[{level:3,title:"Tipos de ficheros para certificados digitales",slug:"tipos-de-ficheros-para-certificados-digitales",link:"#tipos-de-ficheros-para-certificados-digitales",children:[]},{level:3,title:"Generaci\xF3n de claves desde Java",slug:"generacion-de-claves-desde-java",link:"#generacion-de-claves-desde-java",children:[]}]},{level:2,title:"6.4.5. Cifrado y descifrado usando un par de claves",slug:"_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",link:"#_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",children:[]},{level:2,title:"6.2.3. Cifrado asim\xE9trico con GnuPG",slug:"_6-2-3-cifrado-asimetrico-con-gnupg",link:"#_6-2-3-cifrado-asimetrico-con-gnupg",children:[]}],path:"/en/unit6/asymmetric-keys.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.4 Encriptaci\xF3n asim\xE9trica\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.4 Encriptaci\xF3n asim\xE9trica" />\r
\r
# 6.4 Encriptaci\xF3n asim\xE9trica\r
\r
[[toc]]\r
\r
## 6.4.1. Clave p\xFAblica y clave privada\r
\r
La criptograf\xEDa asim\xE9trica o **criptograf\xEDa de clave p\xFAblica** supuso una aut\xE9ntica revoluci\xF3n en su momento. Permit\xEDa el intercambio seguro de informaci\xF3n (confidencialidad, autenticaci\xF3n y no repudio) entre interlocutores que no compart\xEDan ning\xFAn secreto.\r
\r
Se cre\xF3 en los a\xF1os 70 a partir del trabajo de *Diffie y Hellman* por una parte y de *Rivest, Shamir y Adleman* por otra.\r
\r
Se basa en la existencia de un par de claves, una p\xFAblica y otra privada, entre las cuales existe una relaci\xF3n matem\xE1tica, de manera que es muy dif\xEDcil obtener la clave privada a partir de la p\xFAblica. Sin embargo, es muy sencillo obtener la clave p\xFAblica a partir de la privada.\r
\r
::: info Algoritmo RSA\r
En la familia de algoritmos RSA (Rivest, Shamir y Adleman) la clave p\xFAblica consiste en un n\xFAmero que es el producto de dos factores primos muy grandes (mayores que 10^100) y la clave privada se deriva de la factorizaci\xF3n de dicho n\xFAmero, es decir, los dos factores primos.\r
\r
Requiere poco procesamiento multiplicar dos n\xFAmeros primos tan grandes, pero requiere una cantidad enorme de c\xE1lculos encontrar la factorizaci\xF3n del n\xFAmero.\r
:::\r
\r
A diferencia del cifrado sim\xE9trico, el el cifrado asim\xE9trico se usan funciones diferentes para cifrar y descifrar los mensajes.\r
\r
- Para **encriptaci\xF3n** se usa la **clave p\xFAblica**. Cualquiera puede tener acceso a la clave p\xFAblica, mediante la cual, usando la funci\xF3n de cifrado, se encripta la informaci\xF3n dirigida a un destinatario concreto (el propietario de la clave privada asociada).\r
- Para **desencriptaci\xF3n** se usa la **clave privada**, que debe mantenerse a buen recaudo ya que s\xF3lo con esa clave y la funci\xF3n de descifrado se puede desencriptar un mensaje cifrado con la clave p\xFAblica correspondiente.\r
\r
Entre los algoritmos de cifrado asim\xE9trico m\xE1s utilizados se encuentran\r
\r
- Rivest Shamir Adleman (RSA). Basado en la factorizaci\xF3n de n\xFAmeros primos grandes.\r
- Digital Signature Standard (DSS), que incorpora Digital Signature Algorithm (DSA).\r
- Elliptical Curve Cryptography (ECC). Est\xE1 basado en las matem\xE1ticas de las curvas el\xEDpticas\r
- the Diffie-Hellman exchange method.\r
- TLS/SSL protocol.\r
\r
![cifrado asim\xE9trico](../../media/unit6/asymmetric-encryption-primitive.png)\r
\r
## 6.4.2. Firma digital\r
\r
Con la firma digital Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
![cifrado asim\xE9trico](../../media/unit6/proceso-firma-digital.png)\r
\r
El proceso b\xE1sico que se sigue para la firma electr\xF3nica es el siguiente:\r
\r
1. El usuario dispone de un documento electr\xF3nico (una hoja de c\xE1lculo, un pdf, una imagen, incluso un formulario en una p\xE1gina web) y de un **certificado** (clave p\xFAblica y clave privada) que le pertenece y le identifica.\r
2. La aplicaci\xF3n o dispositivo digital utilizados para la firma realiza un **resumen del documento**. El resumen de un documento de gran tama\xF1o puede llegar a ser tan solo de unas l\xEDneas. Este resumen es \xFAnico y cualquier modificaci\xF3n del documento implica tambi\xE9n una modificaci\xF3n del resumen.\r
3. La aplicaci\xF3n utiliza la clave privada para codificar el resumen.\r
4. La aplicaci\xF3n crea otro documento electr\xF3nico que contiene ese resumen codificado. Este nuevo documento es la firma electr\xF3nica.\r
\r
El resultado de todo este proceso es un documento electr\xF3nico obtenido a partir del documento original y de las claves del firmante. La firma electr\xF3nica, por tanto, es el mismo documento electr\xF3nico resultante.\r
\r
![verificaci\xF3n de firma digital](../../media/unit6/digital-signature-sign-verify.png)\r
\r
### Integridad\r
\r
Como estamos comparando funciones de resumen de un documento, se puede detectar de forma muy sencilla si el documento ha sufrido alguna modificaci\xF3n respecto al momento en el que se firm\xF3, garantizando de esta forma la integridad de la informaci\xF3n firmada.\r
\r
### Autenticaci\xF3n y no repudio\r
\r
Por las caracter\xEDsticas de los algoritmos de cifrado se puede determinar, a partir del resumen cifrado con la clave privada, mediante el uso de la clave p\xFAblica, que el mensaje recibido lo gener\xF3 el propietario de la clave privada.\r
\r
Con esta caracter\xEDstica se puede probar y demostrar que el mensaje lo firm\xF3 el emisor y no cualquier otra persona, garantizando por un lado la autor\xEDa y por otro evitando que el emisor niegue haber generado esa informaci\xF3n.\r
\r
## 6.4.3 Certificados digitales\r
\r
Un certificado digital es un documento electr\xF3nico expedido por una **Autoridad de Certificaci\xF3n** e identifica a una persona (f\xEDsica o jur\xEDdica) con un par de claves.Tiene como misi\xF3n validar y certificar que una firma electr\xF3nica se corresponde con una persona o entidad concreta.\r
\r
Contiene la informaci\xF3n necesaria para firmar electr\xF3nicamente e identificar a su propietario con sus datos: nombre, NIF, algoritmo y claves de firma, fecha de expiraci\xF3n y organismo que lo expide.\r
\r
La Autoridad de Certificaci\xF3n da fe de que la firma electr\xF3nica se corresponde con un usuario concreto. Esa es la raz\xF3n por la que los certificados est\xE1n firmados, a su vez, por la Autoridad de Certificaci\xF3n.\r
\r
### Claves digitales\r
\r
En un certificado, las claves digitales son los elementos esenciales para la firma e identificaci\xF3n del firmante. Existen dos claves, la **clave privada** y **clave p\xFAblica**, y trabajan de forma complementaria. *Lo que cifra o codifica una clave s\xF3lo lo puede descifrar o decodificar la otra*.\r
\r
La diferencia entre ellas es que la clave privada est\xE1 pensada para que nunca salga del certificado y est\xE9 siempre bajo el control del firmante. En cambio, la clave p\xFAblica se puede repartir o enviar a otros usuarios.\r
\r
En ocasiones, se habla de Certificado Privado para referirse al certificado que contiene la clave privada y la p\xFAblica y del Certificado P\xFAblico para referirse al certificado que s\xF3lo contiene la clave p\xFAblica.\r
\r
::: info Creaci\xF3n de Certificados digitales\r
Obtener el Certificado Digital depende de si el certificado est\xE1 contenido en una tarjeta, como el DNIe, o de si el certificado se guarda en un fichero software.\r
\r
En ambos procesos hay un paso que es la identificaci\xF3n del responsable o usuario del certificado, lo cual requiere que \xE9ste **se persone en las oficinas de una Autoridad de Registro**. Estas oficinas corroboran la identidad.\r
:::\r
\r
### Infraestructura de clave p\xFAblica (PKI)\r
\r
Una infraestructura de clave p\xFAblica (PKI) es una combinaci\xF3n de hardware, software, procedimientos de seguridad y marco legal que, en su conjunto, permite la ejecuci\xF3n con garant\xEDas de operaciones criptogr\xE1ficas, cumpliendo los requisitos de integridad, confidencialidad, autenticaci\xF3n y no repudio.\r
\r
Una PKI permite establecer y gestionar asociaciones entre claves p\xFAblicas e identidades de personas y organizaciones.\r
\r
La cuesti\xF3n entonces es determinar si un certificado es v\xE1lido o de confianza, ol o que es lo mismo, si representa a la persona u organizaci\xF3n que aparece como titular y propietario  del certificado.\r
\r
Para dar por v\xE1lido un certificado digital su firma digital debe ser v\xE1lida y su emisor debe ser un emisor de confianza. Por lo tanto, ahora queda determinar qu\xE9 emisores son de confianza.\r
\r
::: warning Autenticidad de los certificados\r
Los certificados deben estar firmados por una AC por dos motivos\r
\r
1. Garantizar su integridad, de forma que cualquier intento de modificaci\xF3n del certificado lo invalide.\r
2. Identificar al creador del certificado digital. Todo el sistema est\xE1 basado en una relaci\xF3n de confianza, en la que la AC que ha firmado el certificado es un emisor de confianza, normalmente instituciones p\xFAblicas o privadas de reconocido prestigio\r
:::\r
\r
En nuestro sistema podemos ver y modificar qu\xE9 entidades de certificaci\xF3n consideramos como seguras, es decir, que los certificados que \xE9stas hayan firmado los tomaremos como v\xE1lidos.\r
\r
[Autoridades de confianza para apps de Azure](https://docs.microsoft.com/es-es/exchange/trusted-root-certification-authorities-for-federation-trusts-exchange-2013-help)\r
\r
En Windows, si ejecutamos \`certmgr.msc\` podemos acceder a la configuraci\xF3n de certificados del sistema. En OSX lo podemos hacer con la aplicaci\xF3n \`Llavero\`.\r
\r
Para nuestra navegaci\xF3n, la informaci\xF3n de qu\xE9 certificados considera el navegador como seguros, depende de en qu\xE9 AC confiemos (por defecto en la instalaci\xF3n vienen configurados los m\xE1s comunes)\r
\r
[Ver certificados y AC en Chrome](https://www.adminfacil.es/como-ver-los-certificados-instalados-en-google-chrome/)\r
\r
::: danger Certificados autofirmados\r
**Hemos de tener en cuenta que, con herramientas como las que proporciona Java, SSH o GnuPG cualquiera puede generar un certificado digital con la informaci\xF3n que quiera**\r
\r
Para las pruebas vamos a firmar nuestros propios certificados. Incluso dentro de una compa\xF1\xEDa podemos ejercer nosotros mismos como Autoridad de Certificaci\xF3n de Confianza, firmando nuestros certificados.\r
\r
Debemos preparar la configuraci\xF3n de nuestros sistemas para que **conf\xEDen** en esos certificados autofirmados, asumiendo el riesgo que esto conlleva.\r
:::\r
\r
## 6.4.4. Generaci\xF3n de pares de claves\r
\r
La generaci\xF3n y gesti\xF3n de pares de claves implica dos aspectos fundamentales.\r
\r
Por un lado, tenemos la creaci\xF3n de las claves. Las claves las podemos haber descargado, generado con alguna de las utilidades disponibles para ellos o bien, como veremos a continuaci\xF3n, se pueden generar desde una aplicaci\xF3n, igual que hacemos con las claves sim\xE9tricas.\r
\r
Por otro lado, tenemos la gesti\xF3n del almacenamiento de las claves. Las claves no dejan de ser archivos, que podemos tratar como archivos especiales, pero que usualmente se almacenan en repositorios especiales, denominados \`keyrings\` a los que puede acceder una aplicaci\xF3n y desde los que gestionamos las relaciones de confianza.\r
\r
El JCA nos proporciona clases generadoras de claves. Estas clases se apoyan en buenos algoritmos de generaci\xF3n de n\xFAmeros aleatorios para satisfacer unos requisitos m\xEDnimos de seguridad.\r
\r
::: info SecureRandom\r
La generaci\xF3n de n\xFAmeros aleatorios juega un papel fundamental en la criptograf\xEDa, siendo uno de los **Engine** que proporciona el JCA junto con un amplio grupo de algoritmos.\r
\r
La clase **SecureRandom** genera n\xFAmero aleatorios empleando alguno de los algoritmos disponibles y se puede utilizar un objeto de tipo SecureRandom para que los utilicen las clases generadoras de claves, tanto sim\xE9tricas como asim\xE9tricas\r
:::\r
\r
### Tipos de ficheros para certificados digitales\r
\r
Hay varios tipos de ficheros que se utilizan para guardar certificados digitales siguiendo el est\xE1ndar X.509. Generalmente uncertificado no contiene s\xF3lo la clave, sino que tiene informaci\xF3n adicional.\r
\r
Esxiten dos posibles codificaciones para almacenar certificados X.509\r
\r
- der: Es una codificaci\xF3n binaria\r
- dem: Es una codificaci\xF3n en formato texto guardado en Base64 y tienen un encabezado y pie que delimita el contenido del certificado\r
\r
Veamos un ejemplo de certificado con codificaci\xF3n dem\r
\r
\`\`\`sh\r
-----BEGIN CERTIFICATE----- \r
MIIDijCCAvOgAwIBAgIJAKRvtQxONVZoMA0GCSqGSIb3DQEBBAUAMIGLMQswCQYD \r
VQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxl \r
MSAwHgYDVQQKExdBcnViYSBXaXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFD \r
MSMwIQYDVQQDExpteXNlcnZlci5hcnViYW5ldHdvcmtzLmNvbTAeFw0wODA0MzAy \r
MzM3MDJaFw0xMDA0MzAyMzM3MDJaMIGLMQswCQYDVQQGEwJVUzETMBEGA1UECBMK \r
Q2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxlMSAwHgYDVQQKExdBcnViYSBX \r
aXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFDMSMwIQYDVQQDExpteXNlcnZl \r
ci5hcnViYW5ldHdvcmtzLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA \r
zRwqc9prVXycGhHcsAjGPzC2MKU4DhXSr86Z89Jk8/cXEJBJ0C/NgdAqqDgxneUh \r
nVyxGxODa7BNGAWSagdCsKLrbkchr479E3xLfgdc3UzAJITLGCXGiQ66NwQDyM5I \r
G/xKYm4oqgyOE/lFTTkK0M8V0NmmJynyOCYC/AwQKjMCAwEAAaOB8zCB8DAdBgNV \r
HQ4EFgQUM5btT6IlPGkLTTPvFccTVURO1p0wgcAGA1UdIwSBuDCBtYAUM5btT6Il \r
PGkLTTPvFccTVURO1p2hgZGkgY4wgYsxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpD \r
YWxpZm9ybmlhMRIwEAYDVQQHEwlTdW5ueXZhbGUxIDAeBgNVBAoTF0FydWJhIFdp \r
cmVsZXNzIE5ldHdvcmtzMQwwCgYDVQQLEwNUQUMxIzAhBgNVBAMTGm15c2VydmVy \r
LmFydWJhbmV0d29ya3MuY29tggkApG+1DE41VmgwDAYDVR0TBAUwAwEB/zANBgkq \r
hkiG9w0BAQQFAAOBgQBp71WeF6dKvqUSO1JFsVhBeUesbEgx9+tx6eP328uL0oSC \r
fQ6EaiXZVbrQt+PMqG0F80+4wxVXug9EW5Ob9M/opaCGI+cgtpLCwSf6CjsmAcUc \r
b6EjG/l4HW2BztYJfx15pk51M49TYS7okDKWYRT10y65xcyQdfUKvfDC1k5P9Q== \r
-----END CERTIFICATE-----\r
\`\`\`\r
\r
Adem\xE1s de la codificaci\xF3n, tenemos formatos de fichero est\xE1ndar para guardar los certificados usando una de las codificaciones anteriores\r
\r
- cer, crt, der: Contienen certificados X.509 est\xE1ndares codificados como \`der\`\r
- p12: Realmente hace referencia a toda una familia de est\xE1ndares asociados al algoritmo RSA y definen el formato de almacenamiento de distintos tipos de claves, los PKCS#n (PKCS#8, PKCS#12, etc). Pueden contener, adem\xE1s de los datos del certificado, una clave privada. Si contiene la clave privada, \xE9sta estar\xE1 protegida por una contrase\xF1a que ser\xE1 necesaria para acceder a la clave privada. [PKCS en Wikipedia](https://es.wikipedia.org/wiki/PKCS)\r
\r
### Generaci\xF3n de claves desde Java\r
\r
Usando las clases del JCA, estos son los pasos que debemos seguir para generar un par de claves desde c\xF3digo\r
\r
1. El primer paso para obtener un par de claves es obtener un objeto *keyPairGenerator* para el algoritmo que queramos utilizar.\r
2. A continuaci\xF3n se inicializa el generador del par de claves llamando a alguna de las versiones del m\xE9todo *initialize*. En nuestro caso indicaremos el tama\xF1o de clave para el algoritmo seleccionado y un generador de n\xFAmeros aleatorios.\r
3. El \xFAltimo paso es generar el par de claves y guardarlas en los objetos PrivateKey y PublicKey respectivamente.\r
4. A partir de ese momento ya se pueden usar las claves para cifrar, descifrar e incluso para firmar. Sin embargo, si queremos reutilizar estas claves, lo que tendremos que hacer ser\xE1 guardarlas en sendos archivos.\r
\r
A continuaci\xF3n podemos ver un ejemplo de generaci\xF3n de claves, almacenamiento de las claves en un fichero y visualizaci\xF3n de la clave obtenida.\r
\r
\`\`\`java{14,15,18-20,39,52}\r
public class U6S5_GenerateRsaKeyPair {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            // Elijo un algoritmo de generaci\xF3n de n\xFAmeros aleatorios de los denominados\r
            // altamente seguros para generar el par de claves\r
            SecureRandom algoritmoSeguro = SecureRandom.getInstanceStrong();\r
            // Preparo el generados de claves para usar el algortimo RSA\r
            KeyPairGenerator genParClaves = KeyPairGenerator.getInstance(algoritmoClaveAsimetrica);\r
            genParClaves.initialize(tamanoClaveAsimetrica, algoritmoSeguro);\r
\r
            // Creo el par de claves y lo guardo en objetos\r
            KeyPair parClaves = genParClaves.generateKeyPair();\r
            PublicKey clavePublica = parClaves.getPublic();\r
            PrivateKey clavePrivada = parClaves.getPrivate();\r
\r
            // Guardamos la clave p\xFAblica en un archivo y la visualizamos\r
            // La clave se guarda con codificaci\xF3n DER y en formato X.509\r
            guardaClavePublicaX509(clavePublica);\r
            \r
            // Guardamos la clave privada en un archivo y la visualizamos\r
            // La clave se guarda con codificaci\xF3n DER y en formato PKCS#8\r
            guardaClavePrivadaPKCS8(clavePrivada);\r
            \r
\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementaci\xF3n del algortimo en ning\xFAn Provider");\r
        }\r
\r
    }\r
\r
    private static void guardaClavePublicaX509(PublicKey clavePublica) {\r
        try (FileOutputStream publicKeyFile = new FileOutputStream(ficheroClavePublica)) {\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublica.getEncoded(), algoritmoClaveAsimetrica);\r
            publicKeyFile.write(clavePublica.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePublica.getEncoded(),\r
                    codificacionClavePublica.getFormat(), ficheroClavePublica);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave p\xFAblica en " + ficheroClavePublica);\r
        }                \r
    }\r
\r
    private static void guardaClavePrivadaPKCS8(PrivateKey clavePrivada) {\r
        try (FileOutputStream privateKeyFile = new FileOutputStream(ficheroClavePrivada)) {\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivada.getEncoded(), algoritmoClaveAsimetrica);\r
            privateKeyFile.write(clavePrivada.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePrivada.getEncoded(),\r
                    codificacionClavePrivada.getFormat(), ficheroClavePrivada);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave privada en " + ficheroClavePrivada);\r
        }        \r
    }\r
\r
    private static void MostrarClaveBase64(byte[] clave, String formatoClave, String ficheroClave) {\r
        System.out.println("Clave guardada en formato " + formatoClave \r
                + " en fichero " + ficheroClave);\r
        System.out.println(Base64.getEncoder().encodeToString(clave).replaceAll("(.{76})", "$1\\n"));\r
    }\r
}\r
\`\`\`\r
\r
Esta ser\xEDa la salida proporcionada\r
\r
\`\`\`sh\r
Clave guardada en formato X.509 en fichero claves/clavepublica.der\r
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC4UFRgEIm3lFKO75QmqTPvkDs0fM6NUm2FHQcA\r
cQHawLx9/WKXh9xkx/xYZZcc4L2YQYcwTu4jfk889iGKGLn2Kh4ywBY+g8uZ6ljM5PT6f95dU6Zd\r
xATWOn1qsizBubf7kKhBL7xDnKU5do3XYzrSjme+9uIsgS7HQ7K0MbKrpQIDAQAB\r
\r
Clave guardada en formato PKCS#8 en fichero claves/claveprivada.pkcs8\r
MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALhQVGAQibeUUo7vlCapM++QOzR8\r
zo1SbYUdBwBxAdrAvH39YpeH3GTH/FhllxzgvZhBhzBO7iN+Tzz2IYoYufYqHjLAFj6Dy5nqWMzk\r
9Pp/3l1Tpl3EBNY6fWqyLMG5t/uQqEEvvEOcpTl2jddjOtKOZ7724iyBLsdDsrQxsqulAgMBAAEC\r
gYA97xBLL4N3YqnTSgIYc6b2Cxs56e5mYppWrohZx5996GHuXCSzEn4mh2TuN0Tt+T78WJiazQsM\r
djceHv7qLqDd2kWn3IR0gX207KxwjG0I/sAP2z/i9NZ7DPL+FUv8lmeYUfDj8h3wkyhmBqn+tan1\r
0xIOcZUrr/yRhrjZLI1SCQJBAPEc4uWSbyBLHVC6SNga7XWNmwi8Mq4PZJdhW9RJWDxg9zOlC/HV\r
rV60ddbfW/ldIqCH33DUge5U5YhD6Mla/XMCQQDDsahcwTksp2bJowMTRgFHT094sihtSlQ7sgdI\r
uAemuMvBmVTHleFBWMqz1rAN6A/76yef3WK4I+nsmeCGa+yHAkEA7BR1kYT8q+kATi/n7TkIcoZx\r
W28yTD2kJ5jbWhNqgswKn5WmCWdH9qfJjddrbdEke3wuaoKYqeyURgUAJE+kQwJADhEsQBanrH0Q\r
F3h/VRhYKS8bUFrGKy0Hpw7iFSkda6+m/fCutnYgrhja4ViSaT2AQKSjwYsheIkkXJynFiKV6wJA\r
PUHXqlvfgPr4w2U+Ddq7h/gp59kO0uojGrEBO0B2wt3PuuSQlZlMN97Ly9QmB6LYRtw6woCZZZOD\r
ePqA7rf8IA==\r
\`\`\`\r
\r
En el ejemplo anterior en lugar de utilizar clases est\xE1ndar para volcar el contenido binario de las claves a un archivo en formato raw, se utilizan clases codificadoras para generar ficheros binarios en formatos est\xE1ndares, tanto para la clave p\xFAblica como para la privada.\r
\r
Esto tiene la enorme ventaja de que se pueden utilizar las claves generadas con herramientas est\xE1ndar como openssl. Adem\xE1s, facilita la tarea ya que las claves p\xFAblica y privada para criptograf\xEDa asim\xE9trica son objetos compuestos.\r
\r
::: info Codificaci\xF3n Base64\r
Base64 es un grupo de esquemas de codificaci\xF3n de binario a texto que representa los datos binarios mediante una cadena.\r
\r
Los esquemas de codificaci\xF3n Base64 son com\xFAnmente usados cuando se necesita codificar datos binarios para que sean almacenados y transferidos sobre un medio dise\xF1ado para tratar con datos textuales. Esto es para asegurar que los datos se mantienen intactos y sin modificaciones durante la transmisi\xF3n.\r
\r
Los valores codificados en Base64 como texto se muestran en filas de 76 caracteres como m\xE1ximo, para mejor legibilidad, y siguiendo convenciones habituales.\r
\r
Para verlos en pantalla se a\xF1ade un salto de l\xEDnea despu\xE9s de cada grupo de 76 caracteres usando  \`replaceAll("(.{76})", "$1\\n")\`.\r
:::\r
\r
Las claves que se han guardado con el programa tienen las siguientes caracter\xEDsticas:\r
\r
- La clave p\xFAblica se guarda en un fichero \`clavepublica.der\`, con el formato de la estructura *SubjectPublicKeyInfo* en formato *ASN.1* definido en el est\xE1ndar *X.509*, y con codificaci\xF3n *DER (binaria)*. Para eso se ha utilizado la clase codificadora **X509EncodedKeySpec**.\r
- La clave privada se guarda en un fichero \`claveprivada.pkcs8\`, en formato *PKCS#8*, y con codificaci\xF3n *DER (binaria)*. Para eso se ha utilizado la clase codificadora **PKCS8EncodedKeySpec**.\r
\r
::: info Codificaciones por defecto\r
Las codificaciones usadas en el programa coinciden con las codificacione por defecto que usan las clases PrivateKey y PublicKey, como se puede ver en los valores proporcionados por los m\xE9todos getFormat() y getEncoded().\r
:::\r
\r
## 6.4.5. Cifrado y descifrado usando un par de claves\r
\r
Aunque ya hemos visto que las claves se pueden generar desde c\xF3digo, lo normal es que una vez hayamos generado un par de claves, estas se puedan reutilizar desde las aplicaciones para cifrar y descifrar informaci\xF3n.\r
\r
Si hemos guardado las claves en archivos, el primer paso que tendremos que realizar es recuperar esas claves para poder realizar las operaciones criptogr\xE1ficas con ellas.\r
\r
::: question Prueba de claves online\r
Podemos probar las claves generadas con una herramienta online.\r
\r
[Online RSA tool](https://www.devglan.com/online-tools/rsa-encryption-decryption)\r
\r
Prueba a copiar el contenido (en Base64) de las claves p\xFAblica y privada para hacer un cifrado y un descifrado de la informaci\xF3n.\r
\r
Tambi\xE9n puedes probar a simular una firma digital, realizando el cifrado con la clave privada y el descifrado con la clave p\xFAblica.\r
:::\r
\r
Veamos un ejemplo de c\xF3mo se hace todo este proceso en Java\r
\r
\`\`\`java{23-25,38-40,76-78,108-110}\r
public class U6S6_RsaKeyPairEncrypt {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            //////////////////////////////////////////////////\r
            // CIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave p\xFAblica de un archivo\r
            PublicKey clavePublica = leerClavePublica(ficheroClavePublica);\r
\r
            // Preparamos la informaci\xF3n que queremos cifrar\r
            String textoEnClaro = "Quiero cifrar este mensaje de prueba";\r
            byte[] mensajeEnClaro = textoEnClaro.getBytes("UTF-8");\r
            \r
            // Realizamos el proceso de cifrado con clave p\xFAblica\r
            // Los pasos son exactamente los mismos que con el cifrado sim\xE9trico\r
            Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.ENCRYPT_MODE, clavePublica);\r
            byte[] mensajeCifrado = cifrado.doFinal(mensajeEnClaro);\r
            // Visualizamos el mensaje cifrado en modo texto\r
            MostrarMensajeBase64(mensajeCifrado);\r
            \r
            //////////////////////////////////////////////////\r
            // DESCIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave privada de un archivo\r
            PrivateKey clavePrivada = leerClavePrivada(ficheroClavePrivada);\r
\r
            // Realizamos el proceso de descifrado con clave privada\r
            // Los pasos son exactamente los mismos que con el cifrado sim\xE9trico\r
            // Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.DECRYPT_MODE, clavePrivada);\r
            byte[] mensajeDescifrado = cifrado.doFinal(mensajeCifrado);\r
            // Visualizamos el mensaje descifrado\r
            System.out.println("Texto descifrado:\\n" + new String(mensajeDescifrado, "UTF-8"));\r
                        \r
        } catch (UnsupportedEncodingException ex) {\r
            System.out.println("Codificaci\xF3n de caracteres UTF-8 no soportada");\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementaci\xF3n del algoritmo " + algoritmoClaveAsimetrica + " en ning\xFAn Provider");\r
        } catch (NoSuchPaddingException ex) {\r
            System.err.println("El relleno especificado para el algoritmo no est\xE1 permitido");\r
        } catch (InvalidKeyException ex) {\r
            System.err.println("Especificaci\xF3n de clave no v\xE1lida");\r
        } catch (IllegalBlockSizeException ex) {\r
            System.err.println("Tama\xF1o de bloque no v\xE1lido");\r
        } catch (BadPaddingException ex) {\r
            System.err.println("Excepci\xF3n con el relleno usado por el algoritmo");\r
        }\r
    }\r
\r
    private static PublicKey leerClavePublica(String ficheroClave) {\r
        byte[] clavePublicaEncoded;\r
\r
        // Leemos la informaci\xF3n del archivo\r
        try (FileInputStream publicKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePublicaEncoded = publicKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave p\xFAblica.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave p\xFAblica.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes le\xEDdos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublicaEncoded);\r
            PublicKey clavePublica = keyFactory.generatePublic(codificacionClavePublica);\r
\r
            // Devolvemos la clave p\xFAblica generada\r
            return clavePublica;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementaci\xF3n del algoritmo " + algoritmoClaveAsimetrica + " en ning\xFAn Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
\r
    private static PrivateKey leerClavePrivada(String ficheroClave) {\r
        byte[] clavePrivadaEncoded;\r
\r
        // Leemos la informaci\xF3n del archivo\r
        try (FileInputStream privateKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePrivadaEncoded = privateKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave privada.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave privada.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes le\xEDdos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivadaEncoded);\r
            PrivateKey clavePrivada = keyFactory.generatePrivate(codificacionClavePrivada);\r
\r
            // Devolvemos la clave p\xFAblica generada\r
            return clavePrivada;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementaci\xF3n del algoritmo " + algoritmoClaveAsimetrica + " en ning\xFAn Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
    \r
    private static void MostrarMensajeBase64(byte[] mensajeCifrado) {\r
        System.out.println("Mensaje cifrado visualizado como texto en Base64:");                \r
        System.out.println(Base64.getEncoder().encodeToString(mensajeCifrado).replaceAll("(.{76})", "$1\\n"));\r
    }    \r
}\r
\`\`\`\r
\r
Y esta es la salida proporcionada\r
\r
\`\`\`sh\r
Mensaje cifrado visualizado como texto en Base64:\r
EV+7WrEf+4CYwckys9blk6DXnLHUm4i0k+4BIp3oNmPdo2skYY8bQsAhXToBx2gi/rMIK9wiJTH0\r
yg99jpyaLeUgtga8PxWx1plgvxohzO/lALkf5AFRUczZh8F5QvOXCi93v2ycZCZXq7QmZTopkEQh\r
ARSezD/1Al2UYPc2X68=\r
\r
Texto descifrado:\r
Quiero cifrar este mensaje de prueba\r
\`\`\`\r
\r
::: warning Cifrado siempre diferente, descifrado siempre igual\r
El resultado de cifrar un mensaje con la misma clave p\xFAblica no siempre es igual, aunque al descifrar los mensajes con la clave privada siempre se obtiene el mensaje original.\r
\r
Esto es debido a que, para aumentar la variabilidad (**entrop\xEDa**) del mensaje cifrado al mensaje que se cifra se le a\xF1ade una parte aleatoria (**salt**) que se descarta cuando se descifra.\r
:::\r
\r
En el c\xF3digo podemos observar c\xF3mo los procesos para cargar la clave desde un archivo usan las mismas clases que cuando se generaron, siendo el c\xF3digo muy parecido.\r
\r
En cuanto al cifrado y descifrado se realiza con el *Engine Cipher* usando la misma secuencia de llamadas que con el cifrado sim\xE9trico.\r
\r
## 6.2.3. Cifrado asim\xE9trico con GnuPG\r
\r
Con la suite GnuPG tambi\xE9n podemos generar pares de claves y cifrar y descifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la informaci\xF3n de los algoritmos disponibles para cada tipo de servicio. En concreto, de res\xFAmenes, en mi versi\xF3n instalada:\r
\r
Clave p\xFAblica: RSA, ELG, DSA, ECDH, ECDSA, EDDSA\r
:::\r
\r
Para generar las claves, ejecutamos los siguientes comandos\r
\r
TO-DO: Completar\r
\r
Para cifrar y descifrar un archivo con las claves generadas, ejecutamos los siguientes comandos\r
\r
TO-DO: Completar\r
`]},{title:"6.2 Funciones resumen",headers:[{level:2,title:"6.2.1. Funciones hash",slug:"_6-2-1-funciones-hash",link:"#_6-2-1-funciones-hash",children:[]},{level:2,title:"6.2.2. MessageDigest",slug:"_6-2-2-messagedigest",link:"#_6-2-2-messagedigest",children:[]},{level:2,title:"6.2.3. MessageDigest con GnuPG",slug:"_6-2-3-messagedigest-con-gnupg",link:"#_6-2-3-messagedigest-con-gnupg",children:[]}],path:"/en/unit6/hash-functions.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.2 Funciones resumen\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.2 Funciones resumen" />\r
\r
# 6.2 Funciones resumen\r
\r
[[toc]]\r
\r
## 6.2.1. Funciones hash\r
\r
Un *Message digest* o resumen de mensaje, m\xE1s conocidos como **funciones hash**, es una marca digital de un bloque de datos. Existe un gran n\xFAmero de algoritmos dise\xF1ados para procesar esto res\xFAmenes, los dos m\xE1s conocidos son SHA-1 y MD5.\r
\r
De un resumen cabe destacar las siguientes caracter\xEDsticas:\r
\r
- Para el mismo algoritmo, el resumen siempre tiene el mismo tama\xF1o, independientemente del tama\xF1o de los datos que se haya usado para generarlo.\r
- Es imposible recuperar la informaci\xF3n original a partir de un resumen.\r
- El resumen no debe desvelar nada sobre los datos que se utilizaron para generarlo.\r
- Es computacionalmente inviable encontrar dos mensajes que tengan el mismo valor de resumen.  Matem\xE1ticamente es altamente improbable, pero no imposible.\r
- Un peque\xF1o cambio en los datos resumidos genera un resumen completamente diferente.\r
\r
Los res\xFAmenes se usan para generar identificadores \xFAnicos y confiables. A veces se les llama *checksum*, ya que sirven para comprobar si una descarga se ha realizado correctamente, generando su resumen y compar\xE1ndolo con el que gener\xF3 el archivo original.\r
\r
::: warning Un hash no sirve para cifrar\r
Es importante destacar que, debido a que es imposible obtener los datos que generaron un resumen a partir del propio resumen, el resumen no se puede usar para cifrar informaci\xF3n.\r
\r
Por el contrario, es un mecanismo que se usa para comparar. Su uso m\xE1s extendido es con las contrase\xF1as, ya que en las bases de datos se guarda un resumen en vez de la contrase\xF1a en claro. De esta forma, cuando se recibe una contrase\xF1a se genera su resumen y se compara con el valor almacenado.\r
:::\r
\r
## 6.2.2. MessageDigest\r
\r
La clase *MessageDigest* permite a las aplicaciones implementar algoritmos de resumen criptogr\xE1ficamente seguros como SHA-256 o SHA-512\r
\r
Para generar un hash con JCA se procede de la siguiente forma:\r
\r
1. Se crea un objeto de la clase *MesageDigest* con el m\xE9todo est\xE1tico *getInstance()* de la misma clase, especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.\r
2. Se a\xF1aden datos con el m\xE9todo *update()*. Se puede a\xF1adir un byte o un array de bytes. Este m\xE9todo se puede invocar varias veces para ir a\xF1adiendo nuevos datos.\r
3. Se obtiene el valor de hash con el m\xE9todo *digest()*.\r
4. Si se quisiera calcular un nuevo hash, se invocar\xEDa el m\xE9todo *reset()* para volver a empezar el proceso.\r
\r
A continuaci\xF3n podemos ver un ejemplo\r
\r
\`\`\`java\r
public class U6S2_MessageDigest {\r
\r
    public static void main(String[] args) {\r
        String plaintext = "Esto es un texto plano.";\r
        try {\r
            // Obtenemos un ENGINE que implementa el algoritmo especificado\r
            // Se puede indicar cualquier algoritmo disponible en el sistema\r
            // SHA-224, SHA-512, SHA-256, SHA3-224, ...\r
            MessageDigest m = MessageDigest.getInstance("SHA-256");\r
\r
            // Opcional - Reinicia el objeto para un nuevo uso \r
            // Por si queremos poner este c\xF3digo en un bucle y procesar m\xE1s\r
            // de un mensaje\r
            m.reset();\r
\r
            // Realiza el resumen de los datos pasados por par\xE1metro\r
            // Si queremos procesar la informaci\xF3n poco a poco, \r
            // debemos ir llamando al m\xE9todo update para cada bloque de datos\r
            m.update(plaintext.getBytes());\r
\r
            // Completa el c\xE1lculo del valor del hash y devuelve el resumen\r
            byte[] digest = m.digest();\r
\r
            // Mensaje de resumen\r
            System.out.println("Resumen (raw data): " + new String(digest));\r
\r
            // Mensaje en formato hexadecimal\r
            System.out.println("Resumen (hex data): " + toHexadecimal(digest));\r
            \r
            \r
            // Informaci\xF3n del proceso\r
            System.out.println("=> Algoritmo: " + m.getAlgorithm() + ", Provider: " + m.getProvider().getName() + " " + m.getProvider().getVersionStr());\r
        } catch (NoSuchAlgorithmException e) {\r
            System.err.println("No se ha encontrado la implementaci\xF3n del algoritmo MD5 en ning\xFAn Provider");\r
        }\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
}\r
\`\`\`\r
\r
y esta ser\xEDa la salida proporcionada\r
\r
\`\`\`sh\r
Resumen (raw data): \uFFFDY\uFFFD"\uFFFD3\x1B\uFFFD\uFFFD\`b\uFFFD\uFFFD\uFFFD\uFFFDbs?;\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD~E\r
Resumen (hex data): FB59D31122913314111B92CD60628ED7E7DE62733F3B10DEDAF303AAABE57E45\r
=> Algoritmo: SHA-256, Provider: SUN 11\r
\`\`\`\r
\r
## 6.2.3. MessageDigest con GnuPG\r
\r
Con la suite GnuPG podemos generar res\xFAmenes de archivos utilizando los algoritmos que nos proporciona la suite.\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la informaci\xF3n de los algoritmos disponibles para cada tipo de servicio. En concreto, de res\xFAmenes, en mi versi\xF3n instalada:\r
\r
Resumen: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224\r
:::\r
\r
Para generar un resumen de un archivo, ejecutamos el comando de la siguiente forma\r
\r
\`\`\`sh\r
gpg --print-md SHA256 filename.ext\r
\`\`\``]},{title:"6 Introducci\xF3n",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/en/unit6/",pathLocale:"/en/",extraFields:[`---\r
title: 6 Introducci\xF3n\r
---\r
\r
# Tema 6. T\xE9cnicas de programaci\xF3n segura\r
\r
El t\xE9rmino criptograf\xEDa es un derivado de la palabra riega *kryptos* que significa oculto y *grafos* que significa escritura. El objetivo de la criptograf\xEDa es ocultar el significado de un mensaje mediante el cifrado o codificaci\xF3n del mensaje.\r
\r
De todas las t\xE9cnicas de programaci\xF3n segura, nosotros vamos a estudiar en este tema\r
\r
- Las funciones de resumen (Hash)\r
- El **cifrado sim\xE9trico** o de clave oculta\r
- El **cifrado asim\xE9trico** o de clave privada\r
\r
Tambi\xE9n estudiaremos c\xF3mo usar canales seguros de comunicaci\xF3n para nuestras aplicaciones, mediante el uso de sockets seguros empleando SSL/TLS.\r
\r
Adem\xE1s, veremos una herramienta de seguridad que incorpora Java, las pol\xEDticas de seguridad.\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Identificar principios y pr\xE1cticas de programaci\xF3n segura.\r
- Analizar t\xE9cnicas y pr\xE1cticas criptogr\xE1ficas.\r
- Definir pol\xEDticas de seguridad.\r
- Emplear algoritmos criptogr\xE1ficos.\r
- Utilizar sockets seguros para la transmisi\xF3n de informaci\xF3n.\r
- Estudiar el funcionamiento de TLS/SSL sobre el protocolo TCP\r
- Conocer herramientas de uso gen\xE9rico en la criptograf\xEDa\r
`]},{title:"6.5 Comunicaciones seguras en Java",headers:[{level:2,title:"6.5.1. Protocolo SSL (Secure Sockets Layer)",slug:"_6-5-1-protocolo-ssl-secure-sockets-layer",link:"#_6-5-1-protocolo-ssl-secure-sockets-layer",children:[]},{level:2,title:"6.5.2. JSSE",slug:"_6-5-2-jsse",link:"#_6-5-2-jsse",children:[{level:3,title:"SSLSocket y SSLServerSocket",slug:"sslsocket-y-sslserversocket",link:"#sslsocket-y-sslserversocket",children:[]},{level:3,title:"keytool: certificados, confianza y almacenes de claves",slug:"keytool-certificados-confianza-y-almacenes-de-claves",link:"#keytool-certificados-confianza-y-almacenes-de-claves",children:[]}]},{level:2,title:"6.5.3. Servidor y Cliente SSL",slug:"_6-5-3-servidor-y-cliente-ssl",link:"#_6-5-3-servidor-y-cliente-ssl",children:[]}],path:"/en/unit6/jsse.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.5 Comunicaciones seguras en Java\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.5 Comunicaciones seguras en Java" />\r
\r
# 6.5 Comunicaciones seguras en Java\r
\r
[[toc]]\r
\r
## 6.5.1. Protocolo SSL (Secure Sockets Layer)\r
\r
SSL es el protocolo habitualmente usado para encriptar la comunicaci\xF3n cliente-servidor. Casi todo el tr\xE1fico de la red puede encriptarse con SSL: POP, IMAP, telnet, FTP, etc, pero es especialmente interesante para dotar de seguridad al protocolo HTTP, es decir como base del HTTPS.\r
\r
La implementaci\xF3n de SSL es una extensi\xF3n de los sockets que permite establecer un canal (stream) de comunicaci\xF3n. Dicha comunicaci\xF3n se inicia con un **handshake** durante el cual, el cliente y el servidor construyen una session-key (clave sim\xE9trica encriptada con par de claves asim\xE9tricas) compartida para verificar su identidad mutua.\r
\r
## 6.5.2. JSSE\r
\r
JSSE (Java Secure Socket Extension) es un conjunto de paquetes que permiten el desarrollo de aplicaciones seguras en Internet. Proporciona un marco y una implementaci\xF3n para Java de los protocolos SSL y TSL e incluye funcionalidad de\r
\r
- encriptaci\xF3n de datos\r
- autenticaci\xF3n de servidores\r
- integridad de mensajes\r
- autenticaci\xF3n de clientes\r
\r
Con JSSE, los programadores  pueden ofrecer intercambio seguro de datos entre un cliente y un servidor que ejecuta un protocolo de aplicaci\xF3n, tales como HTTP, Telnet o FTP, a trav\xE9s de TCP/IP.\r
\r
Las clases de JSSE se encuentran en los paquetes javax.net y javax.net.ssl.\r
\r
### SSLSocket y SSLServerSocket\r
\r
Las clases SSLSocket y SSLServerSocket representan sockets seguros y son derivadas de las ya conocidas Socket y ServerSocket respectivamente.\r
\r
JSSE tiene dos clases SSLServerSocketFactory y SSLSocketFactory para la creaci\xF3n de sockets seguros. No tienen constructor, se obtienen a trav\xE9s del m\xE9todo est\xE1tico getDefault().\r
\r
Para obtener un socket servidor seguro o *SSLServerSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
SSLServerSocket servidorSSL = (SSLServerSocket) = sfact.createServerSocket(puerto);\r
\`\`\`\r
\r
El m\xE9todo **createServerSocket(int puerto)** devuelve un socket de servidor enlazado al puerto especificado.\r
\r
Para crear un *SSLSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
SSLSocket Cliente = (SSLSocket) sfact.createSocket(Host, puerto);\r
\`\`\`\r
\r
El m\xE9todo createSocket (String host, int puerto) crea un socket y lo conecta con el host y el puerto especificados.\r
\r
### keytool: certificados, confianza y almacenes de claves\r
\r
Cuando dos socket SSL, uno cliente y otro servidor, intentan establecer conexi\xF3n, tienen que "presentarse" el uno al otro y comprobar que el otro es de confianza. Si todo va bien y uno conf\xEDa en l otro, la conexi\xF3n se establece, en caso contrario, no se establece.\r
\r
Para establecer esa confianza se debe crear un certificado en el servidor y a\xF1adirlo a los certificados de confianza del cliente.\r
\r
- El servidor debe tener su propio certificado. Si no lo tenemos, se puede generar primero una pareja de claves con la herramienta **keytool**, que viene incluida en el JDK de Java. La herramienta guardar\xE1 la pareja de claves en un almac\xE9n (el cual tiene su propia clave).\r
- Despu\xE9s generaremos un certificado a partir de esa pareja.\r
- El c\xF3digo del servidor necesitar\xE1 indicar el fichero donde se almacenan las claves y la clave para acceder a ese almac\xE9n.\r
- El cliente necesitar\xE1 indicar que conf\xEDa en el certificado del servidor. Dicho certificado del servidor puede estar guardado (por ejemplo) en el almac\xE9n de claves del cliente.\r
\r
::: info Seguridad mutua\r
Aunque no suele hacerse tambi\xE9n podr\xEDa hacerse a la inversa y obligar al cliente a tener un certificado que el servidor pudiera importar, lo que aumentar\xEDa la seguridad.\r
:::\r
\r
Vamos a ver c\xF3mo realizar estas operaciones previas con la herramienta **keytool**\r
\r
Primero las acciones a realizar en el servidor\r
\r
\`\`\`sh:no-line-numbers\r
# El servidor genera una pareja de claves que se almacena en un\r
# fichero llamado "clavesservidor". Dentro del fichero se indica\r
# un alias para poder referirnos a esa clave f\xE1cilmente\r
# keytool -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
What is your first and last name?\r
  [Unknown]:  Vicente Martinez\r
What is the name of your organizational unit?\r
  [Unknown]:  Dpto. Informatica\r
What is the name of your organization?\r
  [Unknown]:  IES Doctor Balmis\r
What is the name of your City or Locality?\r
  [Unknown]:  Alicante\r
What is the name of your State or Province?\r
  [Unknown]:  Alicante\r
What is the two-letter country code for this unit?\r
  [Unknown]:  ES\r
Is CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES correct?\r
  [no]: yes\r
\r
# El servidor genera su "certificado", es decir un fichero que\r
# de alguna forma indica quien es \xE9l. El certificado se almacena\r
# en un fichero llamado clavesservidor y a partir de \xE9l queremos\r
# generar el certificado de un alias creado previamente con nombre servidor\r
# keytool -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
Enter keystore password:\r
Certificate stored in file <servidor.cer>\r
\`\`\`\r
\r
En la carpeta donde hemos ejecutado el comando keytool, se ha creado el almac\xE9n de claves en un fichero llamado **ClavesServidor** y el certificado exportado en el archivo **servidor.cer**\r
\r
y a continuaci\xF3n las que habr\xEDa que realizar en el cliente para generar el almac\xE9n de confianza que, en nuestro caso contenga el mismo certificado que hemos exportado del servidor.\r
\r
\`\`\`sh:no-line-numbers\r
# Se importa el certificado del servidor indicando que pertenece a\r
# la lista de certificados confiables.\r
# keytool -importcert -trustcacerts -alias servidor -file servidor.cer -keystore clavescliente  -storepass 87654321\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -importcert -trustcacerts -alias servidor -file servidor.cer -keystore CertificadosConfianzaCliente -storepass 87654321\r
Owner: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Issuer: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Serial number: 4eb6f2a5\r
Valid from: Mon Jan 24 00:20:24 CET 2022 until: Sun Apr 24 01:20:24 CEST 2022\r
Certificate fingerprints:\r
         SHA1: DD:A2:75:4C:1C:BC:39:60:BE:B1:20:67:E1:5C:45:8C:48:B5:1F:54\r
         SHA256: 82:C8:56:C2:DB:DE:8C:73:A9:21:C6:7D:DE:1F:39:4F:79:CC:5F:D5:10:BC:61:DA:E3:EE:E1:1D:21:EA:D2:33\r
Signature algorithm name: SHA256withRSA\r
Subject Public Key Algorithm: 2048-bit RSA key\r
Version: 3\r
\r
Extensions:\r
\r
#1: ObjectId: 2.5.29.14 Criticality=false\r
SubjectKeyIdentifier [\r
KeyIdentifier [\r
0000: 16 AE 35 7C 58 97 B1 95   91 9B FA 6C 2A 80 D2 90  ..5.X......l*...\r
0010: 1C 50 7F C0                                        .P..\r
]\r
]\r
\r
Trust this certificate? [no]:  yes\r
Certificate was added to keystore\r
\`\`\`\r
\r
En esta ocasi\xF3n tambi\xE9n se crea, en la carpeta donde se ha ejecutado el comando keytool, un fichero **CertificadosConfianzaCliente** con el/los certificados de confianza para el cliente.\r
\r
## 6.5.3. Servidor y Cliente SSL\r
\r
En le siguiente ejemplo podemos observar como la inicializaci\xF3n del ServerSocket es diferente, pero a partir de que se llama al m\xE9todo accept y, en este caso se obtiene una instancia de tipo SSLSocket, el resto del c\xF3digo es igual que con la clase Socket.\r
\r
\`\`\`java{5,16,17,24}\r
public class U6S2_SSLServer {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteConectado = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante c\xF3digo, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicaci\xF3n\r
        // System.setProperty("javax.net.ssl.keyStore", System.getProperty("user.dir") + "\\\\ClavesServidor");\r
        // System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
        \r
        // Inicializaci\xF3n del ServerSocket SSL\r
        int puerto = 6000;\r
        SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
        SSLServerSocket servidorSSL = (SSLServerSocket) sfact.createServerSocket(puerto);\r
\r
        for (int i = 1; i < 5; i++) {\r
\r
            System.out.println("Esperando al cliente " + i);\r
\r
            // Se espera la conexi\xF3n de un cliente con accept\r
            clienteConectado = (SSLSocket) servidorSSL.accept();\r
            // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
            // el c\xF3digo del ejemplo\r
            flujoEntrada = new DataInputStream(clienteConectado.getInputStream());\r
            flujoSalida = new DataOutputStream(clienteConectado.getOutputStream());\r
\r
            // El cliente env\xEDa un mensaje\r
            System.out.println("Recibiendo del CLIENTE: " + i + " \\n\\t" + flujoEntrada.readUTF());\r
\r
            // El Servidor responde con un saludo\r
            flujoSalida.writeUTF("Saludos al cliente del servidor");\r
        }\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteConectado.close();\r
        servidorSSL.close();\r
    }\r
}\r
\`\`\`\r
\r
En el cliente el proceso es el mismo, tras la llamada al m\xE9todo createSocket, obtenemos una instancia de SSLSocket que utilizamos igual que si fuese un Socket.\r
\r
\`\`\`java{5,12,13,19,20}\r
public class U6S2_SSLClient {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteSSL = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante c\xF3digo, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicaci\xF3n\r
        // System.setProperty("javax.net.ssl.trustStore", System.getProperty("user.dir") + "/CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
        // Inicializaci\xF3n del ServerSocket SSL\r
        int puerto = 6000;\r
        String host = "localhost";\r
\r
        System.out.println("Programa Cliente iniciado....");\r
        SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
        clienteSSL = (SSLSocket) sfact.createSocket(host, puerto);\r
\r
        // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
        // el c\xF3digo del ejemplo\r
        flujoSalida = new DataOutputStream(clienteSSL.getOutputStream());\r
        flujoEntrada = new DataInputStream(clienteSSL.getInputStream());\r
\r
        // Env\xEDo un saludo al servidor\r
        flujoSalida.writeUTF("Saludos al SERVIDOR DESDE EL CLIENTE");\r
\r
        // El Servidor responde con un mensaje\r
        System.out.println("Recibiendo del SERVIDOR: \\n\\t" + flujoEntrada.readUTF());\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteSSL.close();\r
    }\r
\r
    void mostrarInformacionSesionSSL(SSLSocket cliente) throws SSLPeerUnverifiedException {\r
\r
        //------------------------------------------------------------------------------\r
        //Ejemplo de la m\xFAltiple informaci\xF3n sobre la sesi\xF3n SSL\r
        // que se puede obtener a partir \r
        SSLSession session = ((SSLSocket) cliente).getSession();\r
        System.out.println("Host: " + session.getPeerHost());\r
        System.out.println("Cifrado: " + session.getCipherSuite());\r
        System.out.println("Protocolo: " + session.getProtocol());\r
\r
        System.out.println("IDentificador:" + new BigInteger(session.getId()));\r
\r
        System.out.println("Creaci\xF3n de la sesi\xF3n: " + session.getCreationTime());\r
\r
        X509Certificate certificate = (X509Certificate) session.getPeerCertificates()[0];\r
        System.out.println("Propietario: " + certificate.getSubjectDN());\r
        System.out.println("Algoritmo: " + certificate.getSigAlgName());\r
        System.out.println("Tipo: " + certificate.getType());\r
        System.out.println("Emisor: " + certificate.getIssuerDN());\r
        System.out.println("N\xFAmero Serie: " + certificate.getSerialNumber());\r
        //-----------------------------------------------------------------------------\r
    }\r
}\r
\`\`\`\r
\r
Si ejecutamos el cliente y el servidor directamente, obtendremos el siguiente error\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Exception in thread "main" javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure\r
\`\`\`\r
\r
Para ejecutar el programa servidor es necesario indicar el certificado que se utilizar\xE1. \r
\r
Lo podemos indicar a la hora de ejecutar el programa, a\xF1adiendo a la l\xEDnea de comandos\r
\r
> java -Djavax.net.ssl.keyStore=ClavesServidor -Djavax.net.ssl.keyStorePassword=12345678\r
\r
y en el programa cliente es necesario indicar la ubicaci\xF3n de los certificados de confianza\r
\r
> java -Djavax.net.ssl.trustStore=CertificadosConfianzaCliente -Djavax.net.ssl.trustStorePassword=87654321\r
\r
![Netbeans: Opciones de la JVM](../../media/unit6/VM_Options.png)\r
\r
::: info Par\xE1metros de JVM o c\xF3digo\r
En el c\xF3digo anterior hay unas l\xEDneas comentadas que especifican c\xF3mo podemos configurar el valor de las propiedades desde c\xF3digo mediante el uso del m\xE9todo System.setProperty(String propiedad, String valor).\r
\r
En el programa servidor incluir\xEDamos las siguientes l\xEDneas:\r
\r
System.setProperty("javax.net.ssl.keyStore", "ClavesServidor");\r
System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
\r
Y en el programa cliente ser\xEDan estas:\r
\r
System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
\r
Adem\xE1s del nombre, podemos indicar la ruta donde se encuentran los almacenes, recordando que NO ES RECOMENDABLE el uso de barras invertidas para indicar rutas.\r
:::\r
\r
Una vez hechos los cambios, bien en las opciones de la JVM o bien en el c\xF3digo de las aplicaciones, la salida que obtendremos ser\xE1 esta\r
\r
<CodeGroup>\r
<CodeGroupItem title="Servidor" active>\r
\r
\`\`\`sh:no-line-numbers\r
Esperando al cliente 1\r
Recibiendo del CLIENTE: 1 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 2\r
Recibiendo del CLIENTE: 2 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 3\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Cliente">\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Recibiendo del SERVIDOR: \r
	Saludos al cliente del servidor\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
</CodeGroup>\r
\r
::: warning Default trusted certificates\r
Whenever Java attempts to connect to another application over SSL (e.g.: HTTPS, IMAPS, LDAPS), it will only be able to connect to that application if it can trust it. The way trust is handled in the Java world is that you have a keystore (typically $JAVA_HOME/lib/security/cacerts), also known as the truststore. This contains a list of all known Certificate Authority (CA) certificates, and Java will only trust certificates that are signed by one of those CAs or public certificates that exist within that keystore.\r
\r
If -Djavax.net.ssl.trustStore has been configured, it will override the location of the default truststore, which will need to be checked.\r
:::`]},{title:"6.1 Seguridad",headers:[{level:2,title:"6.1.1. Seguridad digital",slug:"_6-1-1-seguridad-digital",link:"#_6-1-1-seguridad-digital",children:[]},{level:2,title:"6.1.2. Seguridad en Java",slug:"_6-1-2-seguridad-en-java",link:"#_6-1-2-seguridad-en-java",children:[{level:3,title:"JCA: Engines, algoritmos y proveedores",slug:"jca-engines-algoritmos-y-proveedores",link:"#jca-engines-algoritmos-y-proveedores",children:[]}]},{level:2,title:"6.1.3. Proveedores",slug:"_6-1-3-proveedores",link:"#_6-1-3-proveedores",children:[]},{level:2,title:"6.1.4. Engines",slug:"_6-1-4-engines",link:"#_6-1-4-engines",children:[{level:3,title:"6.1.5. Algoritmos",slug:"_6-1-5-algoritmos",link:"#_6-1-5-algoritmos",children:[]}]}],path:"/en/unit6/security.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.1 Seguridad \r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.1 Seguridad" />\r
\r
# 6.1 Seguridad\r
\r
[[toc]]\r
\r
## 6.1.1. Seguridad digital\r
\r
Los aspectos fundamentales de la seguridad en las comunicaciones digitales son los siguientes\r
\r
- **Integridad**: Permite asegurar que los datos que recibe un receptor son id\xE9nticos a los que ha enviado el emisor. Es decir, no se ha modificado en ning\xFAn punto intermedio en **el canal, que como sabemos, es un canal compartido y por tanto, inseguro**. Las modificaciones pueden ser causadas por fallos en la transmisi\xF3n a trav\xE9s del canal o bien por una acci\xF3n intencionada de un tercero.\r
- **Confidencialidad**: Nos asegura que los datos transmitidos son inteligibles s\xF3lo para el receptor del mensaje. Por las caracter\xEDsticas del medio no podemos evitar que el mensaje llegue a otros destinatarios, pero lo que s\xED podemos evitar es que estos puedan ver el contenido original del mensaje. Esto se consigue cifrando el mensaje.\r
- **Autenticaci\xF3n**: Permite asegurar al receptor de un mensaje que el emisor del mensaje es quien dice ser y no cualquier otro. Esto se consigue con los certificados y la firma digital.\r
- **No repudio**: Es una consecuencia de la caracter\xEDstica anterior, ya que un receptor puede demostrar que el mensaje fue enviado por un emisor de forma inequ\xEDvoca.\r
\r
## 6.1.2. Seguridad en Java\r
\r
[oracle Security Developers Guide](https://docs.oracle.com/en/java/javase/11/security/java-cryptography-architecture-jca-reference-guide.html)\r
\r
Desde el punto de vista de la seguridad, el conjunto de clases de seguridad distribuidas con el SDK de Java 2 pueden dividirse en dos subconjuntos:\r
\r
- Clases relacionadas con el control de acceso y la gesti\xF3n de permisos.\r
- Clases relacionadas con la Criptograf\xEDa.\r
\r
Java incluye APIs de acceso a funciones criptogr\xE1ficas de prop\xF3sito general, conocidas como la **Arquitectura Criptogr\xE1fica de Java o Java Cryptography Architecture (JCA)** y la **Extension Criptogr\xE1fica de Java o Java Cryptography Extension (JCE)**.\r
\r
El JCA est\xE1 formado por las clases b\xE1sicas relacionadas con criptograf\xEDa distribuidas con el JDK y el soporte para la encriptaci\xF3n lo proporciona el paquete de extensi\xF3n JCE.\r
\r
Java tambi\xE9n incluye un conjunto de paquetes para la comunicaci\xF3n segura en Internet, conocidos como la **Extensi\xF3n de Sockets Seguros de Java o Java Secure Socket Extension (JSSE)**. Implementa una versi\xF3n Java de los protocolos SSL y TLS, adem\xE1s incluye funcionalidades como cifrado de datos, autenticaci\xF3n del servidor, integridad de mensajes y autenticaci\xF3n del cliente.\r
\r
Por \xFAltimo Java incluye una interfaz que permite a las aplicaciones Java acceder a servicios de control de autenticaci\xF3n y acceso, el **Servicio de Autentificaci\xF3n y Autorizaci\xF3n de Java o Java Authentication and Authorization Service (JAAS)**. Puede usarse con dos fines: la autenticaci\xF3n de usuarios para conocer qui\xE9n est\xE1 ejecutando c\xF3digo Java; y la autorizaci\xF3n de usuarios para garantizar que qui\xE9n lo ejecuta tiene los permisos necesarios para hacerlo.\r
\r
### JCA: Engines, algoritmos y proveedores\r
\r
Java tiene una Arquitectura de Proveedores, que permite que coexistan multiples implementaciones de algoritmos criptogr\xE1ficos (es decir multiples implementaciones del JCE). La plataforma Java 2 extiende substancialmente la JCA, entre otras cosas se ha mejorado la infraestructura de gesti\xF3n de certificados para soportar los certificados X.509 V3.\r
\r
Para comprender el funcionamiento del JCA tenemos que definir algunos t\xE9rminos b\xE1sicos:\r
\r
#### Engine\r
\r
En el contexto del JCA utilizamos el t\xE9rmino motor (engine) para referirnos a una representaci\xF3n abstracta de un servicio criptogr\xE1fico que no tiene una implementaci\xF3n concreta. Un servicio criptogr\xE1fico siempre est\xE1 asociado con un algoritmo o tipo de algoritmo y puede tener alguna de las siguientes funciones:\r
\r
- Proporcionar operaciones criptogr\xE1ficas (como las empleadas en el firmado y el resumen de mensajes)- Generar o proporcionar el material criptogr\xE1fico (claves o par\xE1metros) necesario para realizar las operaciones.\r
- Generar objetos (almacenes de claves o certificados) que agrupen claves criptogr\xE1ficas de modo seguro.\r
\r
#### Algoritmo\r
\r
Un algoritmo es una implementaci\xF3n de un motor. Por ejemplo, el algoritmo MD5 es una implementaci\xF3n del motor de algoritmos de resumen de mensajes. La implementaci\xF3n interna puede variar dependiendo del c\xF3digo que proporcione la clase MD5.\r
\r
#### Proveedor\r
\r
Un proveedor es el encargado de proporcionar la implementaci\xF3n de uno o varios algoritmos al programador (es decir, darle acceso a una implementaci\xF3n interna concreta de los algoritmos).\r
\r
## 6.1.3. Proveedores\r
\r
La JCA define el concepto de proveedor mediante la clase Provider del paquete java.security. Se trata de una clase abstracta que debe ser redefinida por clases proveedor espec\xEDficas.\r
\r
El constructor de una clase proveedor ajusta los valores de varias propiedades que necesita el API de seguridad de Java para localizar los algoritmos u otras facilidades implementadas por el proveedor.\r
\r
La clase Provider tiene m\xE9todos para acceder al nombre del proveedor, el n\xFAmero de versi\xF3n y otras informaciones sobre las implementaciones de los algoritmos para la generaci\xF3n, conversi\xF3n y gesti\xF3n de claves y la generaci\xF3n de firmas y res\xFAmenes.\r
\r
Si un programador desea saber los proveedores disponibles puede emplear los m\xE9todos\r
\r
- getProvider("nombre") para saber si un proveedor concreto est\xE1 instalado\r
- getProviders() que retorna un vector de cadenas con los nombres de los proveedores\r
\r
::: info Archivo java.security\r
%JAVA_HOME%/conf/security/java.security es el archivo que contiene la informaci\xF3n de la configuraci\xF3n de seguridad que utilizan las clases de la JCA.\r
\r
Ah\xED est\xE1n declarados todos los proveedores y algoritmos que est\xE1n disponibles, as\xED como el orden en el que las clases los buscar\xE1n.\r
:::\r
\r
Para entender como funcionan los proveedores daremos un ejemplo. Supongamos que un programa necesita una implementaci\xF3n del algoritmo MD5. Para obtenerla el programador necesita crear una instancia del mismo y lo har\xE1 escribiendo la siguiente l\xEDnea de c\xF3digo:\r
\r
\`\`\`java\r
MessageDigest m = MessageDigest.getInstance("MD5");\r
\`\`\`\r
\r
Internamente, el m\xE9todo getInstance() solicita a la clase java.security.Security que le proporcione el objeto solicitado. Como no se ha especificado proveedor la clase Security consulta a todos los proveedores disponibles, solicitando una implementaci\xF3n del algoritmo "MD5", hasta que encuentra una o se queda sin proveedores. La consulta se realiza seg\xFAn la lista de proveedores del archivo java.security, que por defecto s\xF3lo contiene la entrada:\r
\r
Security.provider.1=sun.security.provider.Sun\r
\r
## 6.1.4. Engines\r
\r
En el JDK el JCA define las siguientes clases Engine\r
\r
| Clase JCA | Funci\xF3n |\r
|---|---|\r
|java.security.MessageDigest | Calculo de resumen de mensajes (hash).|\r
|java.security.Signature| Firma de datos y verificaci\xF3n firmas.|\r
|java.security.KeyPairGenerator | Generar pares de claves (p\xFAblica y privada) para un algoritmo.|\r
|java.security.KeyFactory| Convertir claves de formato criptogr\xE1fico, especificaciones de claves y viceversa|\r
|java.security.certificate.CertificateFactory| Crear certificados de clave p\xFAblica y listas de revocaci\xF3n(CRLs).|\r
|java.security.KeyStore | Crear y gestionar un almac\xE9n de claves (keystore).|\r
|java.security.AlgorithmParameters | Gestionar los par\xE1metros de un algoritmo, incluyendo codificaci\xF3n y descodificaci\xF3n.|\r
|java.security.AlgorithmParameterGenerator | Generar un conjunto de par\xE1metros para un algoritmo.|\r
|java.security.SecureRandom | Generar n\xFAmeros aleatorios o pseudo aleatorios.|\r
\r
Para instanciar una clase motor se debe invocar el m\xE9todo est\xE1tico *getInstance()*, si se le pasa un nombre de algoritmo se intentar\xE1 obtener una implementaci\xF3n de alg\xFAn proveedor.\r
\r
### 6.1.5. Algoritmos\r
\r
Al igual que pasa con las herramientas de l\xEDnea de comandos, debemos saber qu\xE9 algoritmos est\xE1n disponibles para su uso por las aplicaciones en nuestra m\xE1quina virtual.\r
\r
El siguiente programa nos permite saber que proveedores y algoritmos tenemos instalados en nuestro sistema.\r
\r
Adem\xE1s, si lo invocamos con la opci\xF3n -l nos dir\xE1 que algoritmos implementan (leyendo las propiedades del proveedor)\r
\r
Toda la informaci\xF3n mostrada se extrae del archivo *java.security*\r
\r
\`\`\`java\r
class InfoProveedoresJCA {\r
\r
    public static void main(String[] args) {\r
        boolean listarProps = false;\r
        if (args.length > 0 && args[0].equals("-l")) {\r
            listarProps = true;\r
        }\r
        System.out.println("------------------------------------");\r
        System.out.println("Proveedores instalados en su sistema");\r
        System.out.println("------------------------------------");\r
        int i = 0;\r
        for (Provider proveedor: Security.getProviders()) {\r
            System.out.println("N\xFAm. proveedor : " + (i + 1));\r
            System.out.println("Nombre         : " + proveedor.getName());\r
            System.out.println("Versi\xF3n        : " + proveedor.getVersion());\r
            System.out.println("Informaci\xF3n    :\\n  " + proveedor.getInfo());\r
            System.out.println("Propiedades    :");\r
            if (listarProps) {\r
                Enumeration propiedades = proveedor.propertyNames();\r
                while (propiedades.hasMoreElements()) {\r
                    String clave = (String) propiedades.nextElement();\r
                    String valor = proveedor.getProperty(clave);\r
                    System.out.println("  " + clave + " = " + valor);\r
                }\r
            }\r
            System.out.println("------------------------------------");\r
        }\r
    }\r
}\r
\`\`\`\r
`]},{title:"6.3 Encriptaci\xF3n sim\xE9trica",headers:[{level:2,title:"6.3.1. Clave secreta",slug:"_6-3-1-clave-secreta",link:"#_6-3-1-clave-secreta",children:[]},{level:2,title:"6.3.2. Cipher",slug:"_6-3-2-cipher",link:"#_6-3-2-cipher",children:[{level:3,title:"Transformaciones b\xE1sicas en Java",slug:"transformaciones-basicas-en-java",link:"#transformaciones-basicas-en-java",children:[]}]},{level:2,title:"6.3.3. Clases stream para cifrado y descifrado sim\xE9trico",slug:"_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",link:"#_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",children:[]},{level:2,title:"6.3.4. Cifrado sim\xE9trico con GnuPG",slug:"_6-3-4-cifrado-simetrico-con-gnupg",link:"#_6-3-4-cifrado-simetrico-con-gnupg",children:[]}],path:"/en/unit6/symmetric-key.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.3 Encriptaci\xF3n sim\xE9trica\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.3 Encriptaci\xF3n sim\xE9trica" />\r
\r
# 6.3 Encriptaci\xF3n sim\xE9trica\r
\r
[[toc]]\r
\r
## 6.3.1. Clave secreta\r
\r
Ahora nos interesa no s\xF3lo verificar la integridad de la informaci\xF3n intercambiada, sino tambi\xE9n mantener su privacidad, es decir, que no sea "comprensible" durante la transmisi\xF3n, intercambio o almacenamiento. \r
\r
Tenemos un conjunto de algoritmos denominados de **clave sim\xE9trica** (tambi\xE9n conocidos como de clave secreta) en los que, mediante la aplicaci\xF3n de una clave conocida tanto por el emisos como por el receptor, la informaci\xF3n se **encripta o cifra** de forma que s\xF3lo pueda ser **desencriptada o descifrada** utilizando el mismo algoritmo y la misma clave.\r
\r
::: info El c\xF3digo Enigma\r
Como ejemplo de sistema sim\xE9trico est\xE1 Enigma. Este fue un sistema empleado por Alemania durante la Segunda Guerra Mundial, en el que las claves se distribu\xEDan a diario en forma de libros de c\xF3digos. \r
\r
Cada d\xEDa, un operador de radio, receptor o transmisor, consultaba su copia del libro de c\xF3digos para encontrar la clave del d\xEDa. Todo el tr\xE1fico enviado por ondas de radio durante aquel d\xEDa era cifrado y descifrado usando las claves del d\xEDa.\r
\r
Inglaterra us\xF3 m\xE1quinas para descifrar las claves durante aquella guerra y aunque el citado sistema alem\xE1n, Enigma, estaba provisto de un amplio abanico de claves, los ingleses dise\xF1aron m\xE1quinas de c\xF3mputo especializado, los Bombes, para comprobar las claves de modo mec\xE1nico hasta que la clave del d\xEDa era encontrada. \r
\r
Esto significaba que algunas veces encontraban la clave del d\xEDa pocas horas despu\xE9s de que \xE9sta fuera puesta en uso, pero tambi\xE9n que otros d\xEDas no pod\xEDan encontrar la clave correcta. \r
\r
Los Bombes no fueron m\xE1quinas de c\xF3mputo general, sino las precursoras de los ordenadores (computadoras) actuales.\r
:::\r
\r
Entre los algoritmos de cifrado sim\xE9trico m\xE1s utilizados se encuentran\r
\r
- DES\r
- 3DES o Tiple DES\r
- RC5\r
- AES\r
- Blowfish\r
- IDEA\r
\r
![cifrado sim\xE9trico](../../media/unit6/symmetric-encryption-primitive.png)\r
\r
## 6.3.2. Cipher\r
\r
Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
1. Se crea un objeto de la clase *SecretKey* a partir de un KeyGenerator obtenido con el m\xE9todo est\xE1tico *getInstance()*, especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.\r
2. As\xED podemos utilizar una clave prefijada o incluso una clave aleatoria de tipo OTP (One Time Password) ya que cada vez que ejecutemos el programa la clave ser\xE1 diferente.\r
3. Se crea un objeto de tipo Cipher indicando qu\xE9 algoritmo vamos a usar. Y despu\xE9s, con el m\xE9todo *init()* se indica qu\xE9 vamos a hacer (cifrar/descifrar) y con qu\xE9 clave.\r
4. Se a\xF1aden datos con el m\xE9todo *update()*. Se puede a\xF1adir un byte o un array de bytes. Este m\xE9todo se puede invocar varias veces para ir a\xF1adiendo nuevos datos.\r
5. Se obtiene el valor cifrado con el m\xE9todo *doFinal()*.\r
6. Si se quisiera descifrar, s\xF3lo hay que volver a invocar al m\xE9todo *init()* indicando en este caso que queremos descifrar.\r
\r
A continuaci\xF3n podemos ver un ejemplo\r
\r
\`\`\`java\r
public class SecretKeyEncrypt {\r
\r
    public static void main(String[] args) {\r
        SecretKey claveSecreta = null;\r
        \r
        try {\r
\r
            //Generamos clave secreta\r
            // Podemos crear una nueva clave\r
            claveSecreta = getNewKey();\r
            // O bien usar una clave guardada en alg\xFAn almac\xE9n, fichero, etc.\r
            claveSecreta = getKeyFromData();\r
\r
            System.out.println("Clave usada: " + claveSecreta.getFormat());\r
            //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
            Cipher c = Cipher.getInstance("DESede"); // AES/ECB/PKCS5Padding\r
            // Configuramos el modo de CIFRADO\r
            c.init(Cipher.ENCRYPT_MODE, claveSecreta);\r
\r
            // Aqu\xED leemos la informaci\xF3n que queremos cifrar\r
            // Puede ser una cadena o leerla de un archivo\r
            byte[] textoPlano = "Texto que queremos cifrar para la prueba".getBytes();\r
            \r
            // Si queremos ir cifrando poco a poco, vamos haciendo llamadas\r
            // al m\xE9todo update\r
            // c.update(textoPlano);\r
            // Se realiza el proceso final de cifrado de la informaci\xF3n\r
            byte[] textoCifrado = c.doFinal(textoPlano);\r
            System.out.println("Texto cifrado con clave secreta (raw):\\n" + new String(textoCifrado));\r
            System.out.println("Texto cifrado con clave secreta (hex):\\n" + toHexadecimal(textoCifrado));\r
                        \r
            \r
            // El proceso de descifrado es equivalente\r
            // Cambiamos el modo de ENCRYPT a DECRYPT\r
            // Usamos la misma clave\r
            // Pasamos el texto cifrado para obtener el original\r
            c.init(Cipher.DECRYPT_MODE, claveSecreta);\r
            byte[] textoOriginal = c.doFinal(textoCifrado);\r
            //Leemos bloques de bytes del fichero y lo vamos escribiendo ya cifrado en el fichero de salida\r
            System.out.println("Texto descifrado:\\n" + new String(textoOriginal));\r
            \r
        } catch (Exception e) {\r
            e.printStackTrace();\r
        }\r
    }\r
\r
    static SecretKey getNewKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
    \r
            KeyGenerator kg = KeyGenerator.getInstance("DESede");\r
            kg.init(112);\r
            SecretKey clave = kg.generateKey();\r
            \r
            return clave;\r
    }\r
\r
    static SecretKey getNewRandomKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // Clave obtenida usando un generador de n\xFAmero aleatorios seguro\r
        KeyGenerator genClaves = KeyGenerator.getInstance("DESede");\r
        // Utilizamos un algoritmo de generaci\xF3n de aleatorios        \r
        SecureRandom srand = SecureRandom.getInstance("SHA1PRNG");\r
        genClaves.init(srand);\r
        \r
        SecretKey clave = genClaves.generateKey();\r
        System.out.println("Formato de clave: " + clave.getFormat());\r
        \r
        /*\r
        SecretKeyFactory keySpecFactory = SecretKeyFactory.getInstance("DESede");\r
        DESedeKeySpec keySpec = (DESedeKeySpec) keySpecFactory.getKeySpec(clave, DESedeKeySpec.class);\r
        byte[] valorClave = keySpec.getKey();\r
        */\r
        \r
        return clave;\r
    }\r
    \r
    static SecretKey getKeyFromData() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        SecretKeySpec keySpec = new SecretKeySpec (valorClave, "DESede");\r
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DESede");\r
        SecretKey clave = keyFactory.generateSecret(keySpec);\r
        \r
        return clave;\r
    }\r
\r
    static Key getKeyFromData2() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        Key clave = new SecretKeySpec(valorClave, "AES");\r
\r
        return clave;\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
    \r
}\r
\`\`\`\r
\r
y esta ser\xEDa la salida proporcionada\r
\r
\`\`\`sh\r
Texto cifrado con clave secreta:\r
D0A61CD14B5844AD98B2C7BA795B327ACA0795B658C6F93EC6E1586A246BE71AC180B574207E8C4FFEB959B7D4642FCB\r
Texto descifrado:\r
Texto que queremos cifrar para la prueba\r
\`\`\`\r
\r
Hay que tener en cuenta que en el ejemplo la clave se est\xE1 usando primero para cifrar y luego para descifrar. Si esto lo hacemos en programas separados, los programas que quieran comunicarse deber\xE1n tener acceso a la clave.\r
\r
Lo que se suele hacer es almacenar la clave en un archivo y, cuando se necesita para cifrar o descifrar, se lee con un m\xE9todo similar al m\xE9todo *getKeyFromData()* del ejemplo anterior.\r
\r
### Transformaciones b\xE1sicas en Java\r
\r
En la siguiente tabla tenemos los algoritmos, modos y tipos de relleno, junto con la longitud de clave empleada, de los algoritmos de cifrado sim\xE9trico m'as comunes.\r
\r
|Transformaci\xF3n (algoritmo/modo/relleno)|Key Size|\r
|---|---|\r
|AES/CBC/NoPadding|128|\r
|AES/CBC/PKCS5Padding|128|\r
|AES/ECB/NoPadding|128|\r
|AES/ECB/PKCS5Padding|128|\r
|DES/CBC/NoPadding|56|\r
|DES/CBC/PKCS5Padding|56|\r
|DES/ECB/NoPadding|56|\r
|DES/ECB/PKCS5Padding|56|\r
|DESede/CBC/NoPadding|168|\r
|DESede/CBC/PKCS5Padding|168|\r
|DESede/ECB/NoPadding|168|\r
|DESede/ECB/PKCS5Padding|168|\r
|RSA/ECB/PKCS1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-1AndMGF1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-256AndMGF1Padding|1024, 2048|\r
\r
\r
## 6.3.3. Clases stream para cifrado y descifrado sim\xE9trico\r
\r
Existen dos clases stream que permiten cifrar y descifrar directamente. Pertenecen al paquete *java.crypto* pero por lo dem\xE1s funcionan exactamente igual que las clases Stream del paquete *java.io*, de las que adem\xE1s son clases descendientes y y tienen constructores que permiten crear streams encriptados sobre un InputStream y un OutputStream.\r
\r
| Clase |Ejemplo |\r
| --- | --- |\r
| CipherInputStream | CipherInputStream (InputStream is, Cipher c) |\r
| CipherOutputStream | CipherOutputStream (OutputStream os, Cipher c) |\r
\r
Por lo tanto, cuando tenemos que leer o escribir informaci\xF3n, podemos a\xF1adir un envoltorio m\xE1s al wrapper que utilizamos habitualmente y esto nos permite que tanto las lecturas como las escrituras se hagan cifradas, usando el algoritmo y la clave definidos para el objeto Cipher.\r
\r
El uso m\xE1s com\xFAn es para leer o escribir en archivos en los que, de igual forma, cambiando el wrapper nos permite leer o escribir la informaci\xF3n de forma cifrada/descifrada.\r
\r
::: warning Tama\xF1o de bloque\r
Muchos de los algoritmos de cifrado sim\xE9trico trabajan con bloques de datos, por lo que no debemos intentar cifrar o descifrar m\xE1s informaci\xF3n de la que permite el tama\xF1o de bloque.\r
\r
La clase Cipher tiene un m\xE9todo **getBlockSize()** que nos devuelve el tama\xF1o de bloque que permite el algoritmo configurado en su m\xE9todo **init()**.\r
:::\r
\r
Veamos un ejemplo de c\xF3mo quedar\xEDa el wrapper\r
\r
\`\`\`java\r
public class StreamCrypto {\r
\r
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException {\r
        File file;\r
        String filePath = "a.txt";\r
\r
        file = new File(filePath);\r
\r
        //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
        Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding"); //DESede\r
        // Configuramos el modo de CIFRADO\r
        byte[] valorClave = "12345678123456781234567812345678".getBytes();\r
\r
        // CIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.ENCRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (OutputStream outputStream = new BufferedOutputStream(\r
                new CipherOutputStream(new FileOutputStream(file), c))) {\r
            for (int i = 0; i < 10; i++) {\r
                outputStream.write(new String("Hello World\\n").getBytes());\r
            }\r
\r
        }\r
\r
        // DESCIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.DECRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (InputStream inputStream = new BufferedInputStream(\r
                new CipherInputStream(new FileInputStream(file), c))) {\r
\r
            System.out.println("Contenido del fichero (descifrado):\\n" + new String(inputStream.readAllBytes()));\r
        }\r
\r
    }\r
}\r
\`\`\`\r
\r
## 6.3.4. Cifrado sim\xE9trico con GnuPG\r
\r
Con la suite GnuPG tambi\xE9n podemos cifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la informaci\xF3n de los algoritmos disponibles para cada tipo de servicio. En concreto, de res\xFAmenes, en mi versi\xF3n instalada:\r
\r
Cifrado: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,\r
         CAMELLIA128, CAMELLIA192, CAMELLIA256\r
:::\r
\r
Para cifrar y descifrar un archivo, ejecutamos los siguientes comandos\r
\r
\`\`\`sh\r
gpg --symmetric --cipher-algo 3DES filename.ext\r
gpg --decrypt filename.ext.gpg\r
\`\`\`\r
\r
Vemos que para el cifrado nos solicita una clave y que con el par\xE1metro *--cipher-algo* indicamos qu\xE9 algoritmo de encriptaci\xF3n queremos utilizar.\r
\r
El cifrado genera un archivo filename.ext.gpg.\r
\r
Para el descifrado, no hace falta indicar el algoritmo, aunque se puede volver a usar el par\xE1metro *--cipher-algo* y la clave se queda en una cache de GnuPG durante un tiempo, por lo que no siempre la solicita.\r
`]},{title:"1.2 Concurrencia",headers:[{level:2,title:"1.2.1. Concurrencia vs Paralelismo",slug:"_1-2-1-concurrencia-vs-paralelismo",link:"#_1-2-1-concurrencia-vs-paralelismo",children:[{level:3,title:"Monoproceso",slug:"monoproceso",link:"#monoproceso",children:[]},{level:3,title:"Multiprogramaci\xF3n",slug:"multiprogramacion",link:"#multiprogramacion",children:[]},{level:3,title:"Paralelismo",slug:"paralelismo",link:"#paralelismo",children:[]}]},{level:2,title:"1.2.2. Sistemas distribuidos",slug:"_1-2-2-sistemas-distribuidos",link:"#_1-2-2-sistemas-distribuidos",children:[]},{level:2,title:"1.2.3. Ventajas e inconvenientes",slug:"_1-2-3-ventajas-e-inconvenientes",link:"#_1-2-3-ventajas-e-inconvenientes",children:[]},{level:2,title:"1.2.4. Condiciones de Bernstein",slug:"_1-2-4-condiciones-de-bernstein",link:"#_1-2-4-condiciones-de-bernstein",children:[]}],path:"/es/unit1/concurrency.html",pathLocale:"/es/",extraFields:[`---\r
title: 1.2 Concurrencia\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.2. Concurrencia" />\r
\r
# 1.2. Concurrencia\r
\r
[[toc]]\r
\r
Seg\xFAn el diccionario de la [RAE](https://dle.rae.es/concurrencia?m=form) una de las acepciones de concurrencia es\r
> Coincidencia, concurso simult\xE1neo de varias circunstancias.\r
\r
Si cambiamos circunstancias por \`procesos\`, ya tendr\xEDamos una definici\xF3n cercana a lo que significa concurrencia en el mundo digital\r
\r
Si nos fijamos, no es la primera vez que surge la palabra \`proceso\` en este texto, y es que los procesos son una pieza fundamental del puzle, por no decir la parte m\xE1s importante.\r
\r
## 1.2.1. Concurrencia vs Paralelismo\r
\r
Ahora que ya sabemos qu\xE9 es un proceso, vamos a ver la relaci\xF3n que \xE9stos tienen con el hardware en el que se ejecutan.\r
\r
### Monoproceso\r
\r
Por mucho que tengamos varios procesos procesos ejecut\xE1ndose a la vez, si s\xF3lo tenemos un microprocesador para atenderlos a todos, estas tareas nunca van a poder ejecutarse a la vez.\r
\r
Una posibilidad ser\xEDa la ejecuci\xF3n secuencias de las tareas en el sistema. Se empieza a ejecutar una tarea y, hasta que esta no finaliza, el sistema no empieza a ejecutar la siguiente. Esto se corresponder\xEDa con sistemas que s\xF3lo son capaces de hacer una tarea a la vez, algo raro hoy en d\xEDa.\r
\r
![Secuential execution of tasks (monoprocessor system)](./../../media/unit1/gantt_sequential.svg)\r
\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Secuential execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1       :done, t1, 0, 4s\r
Process 2     : active, t2, after t1, 5s\r
Process 3     : crit, t3, after t2, 2s\r
Process 4    : t4, after t3, 5s\r
\`\`\`\r
-->\r
\r
### Multiprogramaci\xF3n\r
\r
Para que los procesos no tengan que esperar a que todos los dem\xE1s se ejecuten, los sistemas aprovechan y exprimen los recursos al m\xE1ximo, permitiendo la ilusi\xF3n de que varios procesos se ejecutan de forma simult\xE1nea. Esto es lo que se conoce como \`multitarea\`.\r
\r
En estos sistemas, se aprovecha el dise\xF1o de los sistemas operativos modernos, y de las operaciones que realizan los procesos que no requieren el uso del procesador (esperar a una operaci\xF3n de E/S, una interacci\xF3n con el usuario, la recepci\xF3n de informaci\xF3n desde la red, etc.) para poder ejecutar otros procesos. La ejecuci\xF3n se multiplexa en el tiempo.\r
\r
![Concurrent execution of tasks (monoprocessor system)](./../../media/unit1/gantt_concurrent.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Concurrent execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 3  :crit, t3, after t2, 2s\r
Process 4  : t4, after t3, 1s\r
Process 1  :done, t5, after t4, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 4  : t7, after t6, 3s\r
Process 2  :active, t8, after t7, 2s\r
Process 4  : t9, after t8, 1s\r
\`\`\`\r
-->\r
\r
Como se puede observar en las dos im\xE1genes anteriores (aunque se trata s\xF3lo de un modelo), el tiempo de uso total del procesador es igual en ambos casos, es decir, que el sistema tardar\xE1 el mismo tiempo en completar todas las tareas. Sin embargo, la sensaci\xF3n es que todas las tareas se est\xE1n realizando a la vez.\r
\r
### Paralelismo\r
\r
Con el avance de la tecnolog\xEDa ahora la gran mayor\xEDa de dispositivos, desde los equipos de escritorio, port\xE1tiles, dispositivos m\xF3viles, ... hasta los dispositivos IoT, tienen capacidades de multiproceso, es decir, tienen m\xE1s de un procesador para poder realizar varias tareas a la vez de forma real, no simulada.\r
A este tipo de ejecuci\xF3n es a lo que llamamos \`paralelismo\`.\r
\r
![Parallel execution of tasks (dual processor system)](./../../media/unit1/gantt_parallel.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Parallel execution of tasks (dual processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 1  :done, t5, after t2, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 2  :active, t8, after t6, 2s\r
section Processor 2\r
Process 3  :crit, t3, 0, 2s\r
Process 4  : t4, after t3, 1s\r
Process 4  : t7, after t4, 3s\r
Process 4  : t9, after t7, 1s\r
\`\`\`\r
-->\r
\r
En este caso, a mayor n\xFAmero de unidades de proceso, menor tiempo tardar\xE1n las tareas en completarse y mayor ser\xE1 la sensaci\xF3n de rapidez que notar\xE1 el usuario. Este es uno de los retos de los sistemas operativos, planificar adecuadamente las tareas para minimizar los tiempos de ejecuci\xF3n, de espera y el uso de los recursos del sistema, el procesador principalmente.\r
\r
::: question n\xFAcleos vs hilos\r
Si hab\xE9is comprado un procesador hace poco, o est\xE1is al d\xEDa en cuanto al hardware, sabr\xE9is que una de las caracter\xEDsticas de los procesadores es su **n\xFAmero de n\xFAcleos** (4, 8, 16).\r
\r
Pero adem\xE1s, al n\xFAmero de n\xFAcleos lo acompa\xF1a otra caracter\xEDstica que es el n\xFAmero de **hilos o threads**, que suele ser el doble que el de n\xFAcleos.\r
\r
\xBFQu\xE9 implicaci\xF3n tienen los threads de un procesador con respecto a la concurrencia? \xBFSi un equipo tiene 8 n\xFAcleos / 16 hilos significa eso que puede ejecutar 16 procesos a la vez?\r
:::\r
\r
## 1.2.2. Sistemas distribuidos\r
\r
> "Un sistema distribuido es una colecci\xF3n de computadores independientes que aparecen ante los usuarios como un \xFAnico sistema coherente"\r
>\r
> "Andrew S. Tanembaum"\r
\r
Posiblemente el ejemplo m\xE1s famoso y conocido de sistema distribuido sea \`Internet\`.Internet aparece ante los usuarios como un enorme repositorio de documentos, es decir, como un \xFAnico sistema capaz de proveer casi cualquier tipo de informaci\xF3n o servicio que se necesite. No obstante, sabemos que est\xE1 compuesta por millones de equipos ubicados en localizaciones diferentes e interconectados entre s\xED.\r
\r
Nace de la necesidad de compartir recursos. Actualmente el m\xE1ximo exponente de este tipo de sistemas es el \`Cloud Computing\` o servicios en la nube. Un sistema es distribuido cuando los componentes software est\xE1n distribuidos en la red, se comunican y coordinan mediante el paso de mensajes.\r
\r
Las caracter\xEDsticas de este tipo de sistemas son::\r
\r
- Concurrencia: ejecuci\xF3n de programas concurrentes.\r
- Inexistencia de un reloj global. Implica sincronizarse con el paso de mensajes.\r
- Fallos independientes: cada componente del sistema puede fallar sin que perjudique la ejecuci\xF3n de los dem\xE1s.\r
\r
## 1.2.3. Ventajas e inconvenientes\r
\r
Ventajas del procesamiento paralelo:\r
\r
- Ejecuci\xF3n simult\xE1nea de tareas.\r
- Disminuye el tiempo total de ejecuci\xF3n\r
- Resuelve problemas complejos y de grandes dimensiones.\r
- Utilizaci\xF3n de recursos no locales distribuidos en la red\r
- Disminuci\xF3n de costos, aprevechando los recursos distribuidos, no es necesario gastar en un \xFAnico supercomputardor, se puede alcanzar el mismo poder de computaci\xF3n con equipos m\xE1s modestos distribuidos.\r
\r
Inconvenientes del procesamiento paralelo:\r
\r
- Los compiladores y entornos de programaci\xF3n para sistemas paralelos son m\xE1s complicados de desarrollar.\r
- Los programas paralelos son m\xE1s dif\xEDciles de escribir\r
- Hay mayor consumo de energ\xEDa\r
- Mayor complejidad en el acceso a datos\r
- Complejidad a la hora de la comunicaci\xF3n y sincronizaci\xF3n de las diferentes subtareas. <Badge type="danger" text="cuidado" vertical="middle" />\r
\r
Ventajas de la programaci\xF3n distribuida\r
\r
- Se comparten recursos y datos\r
- Crecimiento bajo demanda\r
- Mayor flexibildad para distribuir la carga\r
- Alta disponibilidad\r
- Soporte de aplicaciones distribuidas\r
- Filosof\xEDa abierta y hetereog\xE9nea\r
\r
::: question Escalado de sistemas\r
Con escalado nos referimos a la posibilidad de incrementar las capacidades de un sistema.\r
\r
Investiga las diferencias, ventajas e inconvenientes del \`escalado horizontal\` y el \`escalado vertical\`.\r
:::\r
\r
Inconvenientes de la programaci\xF3n distribuida\r
\r
- Aumenta la complejidad\r
- Se necesita software nuevo especializado\r
- Problemas derivados de las comunicaciones (perdidas, saturaciones, etc.)\r
- Problemas de seguridad, ataques DDoS\r
\r
Ejemplos de utilizaci\xF3n de la programaci\xF3n paralela y distribuida\r
\r
- Estudios meteorol\xF3gicos\r
- Estudios del genoma humano\r
- Modelado de la biosfera\r
- Predicciones s\xEDsmicas\r
- Simulaci\xF3n de mol\xE9culas\r
\r
::: info Ejemplo de programaci\xF3n paralela y distribuida\r
[B\xFAsqueda de inteligencia extraterrestre - Proyecto SETI](https://setiathome.berkeley.edu/sah_about.php)\r
:::\r
\r
## 1.2.4. Condiciones de Bernstein\r
\r
Una vez que sabemos qu\xE9 es un programa concurrente y las distintas arquitecturas hardware que pueden soportarlo, vamos a ver qu\xE9 partes de un programa se pueden ejecutar de forma concurrente y cu\xE1les no.\r
\r
Si observamos el siguiente c\xF3digo, queda claro que la primera instrucci\xF3n se debe ejecutar antes que la segunda para que el resultado sea siempre el mismo (para los mismos datos de entrada).\r
\r
\`\`\`java\r
x = x + 1;\r
y = x + 1;\r
\`\`\`\r
\r
Sin embargo, en un c\xF3digo como el siguiente el \xF3rden en el que se ejecuten las instrucciones no influye en el resultado final (valor de las variables). En este caso se pueden ejecutar las tres sentencias a la vez incrementando la velocidad de procesamiento.\r
\r
\`\`\`java\r
x = 1;\r
y = 2;\r
z = 3;\r
\`\`\`\r
\r
A.J. Bernstein defini\xF3 unas condiciones para determinar si dos conjuntos de instrucciones S<sub>i</sub> y S<sub>j</sub> se pueden ejecutar concurrentemente.\r
\r
Para poder determinar si dos conjuntos de instrucciones se pueden ejecutar concurrentemente, se definen en primer lugar los siguientes conjuntos\r
\r
- L(S<sub>k</sub>) = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ...} como el conjunto de lectura formado por todas las variables cuyos valores se leen durante la ejecuci\xF3n de las instrucciones del conjunto k.\r
- E(S<sub>k</sub>) = {b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>, ...} como el conjunto de escritura formado por todas las variables cuyos valores se actualizan durante la ejecuci\xF3n de las instrucciones del conjunto k.\r
\r
Para que dos conjuntos de instrucciones S<sub>i</sub> y S<sub>j</sub> se puedan ejecutar concurrentemente, se deben cumplir estas tres condiciones de forma simult\xE1nea.\r
\r
- L(S<sub>i</sub>) \u2229 E(S<sub>j</sub>)\r
- E(S<sub>i</sub>) \u2229 L(S<sub>j</sub>)\r
- E(S<sub>i</sub>) \u2229 E(S<sub>j</sub>)\r
  \r
::: question Cuales de estas instrucciones se pueden ejecutar de forma concurrente\r
\r
\`\`\`java\r
a = x + y;\r
b = z - 1;\r
c = a - b;\r
w = c + 1;\r
\`\`\`\r
\r
:::\r
\r
Primero deber\xEDamos obtener los conjuntos L y E para cada sentencia\r
\r
> L(S<sub>1</sub>) = {x, y}\r
>\r
> E(S<sub>1</sub>) = {a}\r
\r
> L(S<sub>2</sub>) = {z}\r
>\r
> E(S<sub>2</sub>) = {b}\r
\r
> L(S<sub>3</sub>) = {a, b}\r
>\r
> E(S<sub>3</sub>) = {c}\r
\r
>L(S<sub>4</sub>) = {c}\r
>\r
> E(S<sub>4</sub>) = {w}\r
\r
Y ahora aplicarlas entre cada par de sentencias\r
\r
> L(S<sub>1</sub>) \u2229 E(S<sub>2</sub>) = \u2205\r
> E(S<sub>1</sub>) \u2229 L(S<sub>2</sub>) = \u2205\r
> E(S<sub>1</sub>) \u2229 E(S<sub>2</sub>) = \u2205         // S\xED se pueden ejecutar concurrentemente\r
\r
> L(S<sub>1</sub>) \u2229 E(S<sub>3</sub>) = \u2205\r
> E(S<sub>1</sub>) \u2229 L(S<sub>3</sub>) = {a} \u2260 \u2205\r
> E(S<sub>1</sub>) \u2229 E(S<sub>3</sub>) = \u2205         // NO se pueden ejecutar concurrentemente\r
\r
> L(S<sub>1</sub>) \u2229 E(S<sub>4</sub>) = \u2205\r
> E(S<sub>1</sub>) \u2229 L(S<sub>4</sub>) = \u2205\r
> E(S<sub>1</sub>) \u2229 E(S<sub>4</sub>) = \u2205         // S\xED se pueden ejecutar concurrentemente\r
\r
> L(S<sub>2</sub>) \u2229 E(S<sub>3</sub>) = \u2205\r
> E(S<sub>2</sub>) \u2229 L(S<sub>3</sub>) = {b] \u2260\r
> E(S<sub>2</sub>) \u2229 E(S<sub>3</sub>) = \u2205         // NO se pueden ejecutar concurrentemente\r
\r
> L(S<sub>2</sub>) \u2229 E(S<sub>4</sub>) = \u2205\r
> E(S<sub>2</sub>) \u2229 L(S<sub>4</sub>) = \u2205\r
> E(S<sub>2</sub>) \u2229 E(S<sub>4</sub>) = \u2205         // S\xED se pueden ejecutar concurrentemente\r
\r
> L(S<sub>3</sub>) \u2229 E(S<sub>4</sub>) = \u2205\r
> E(S<sub>3</sub>) \u2229 L(S<sub>4</sub>) = {c} \u2260 \u2205\r
> E(S<sub>3</sub>) \u2229 E(S<sub>4</sub>) = \u2205         // NO se pueden ejecutar concurrentemente\r
`]},{title:"1 Introducci\xF3n",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit1/",pathLocale:"/es/",extraFields:[`---\r
title: 1 Introducci\xF3n\r
---\r
# Tema 1. Programaci\xF3n concurrente\r
\r
En este primer tema vamos a conocer los conceptos b\xE1sicos relacionados con la programaci\xF3n concurrente, as\xED como la mayor\xEDa de la terminolog\xEDa que vamos a trabajar y utilizar durante todo el curso.\r
\r
En un mundo en el que cada vez los dispositivos electr\xF3nicos son cada vez m\xE1s potentes, y veloces, el software debe ser capaz de aprovechar las caracter\xEDsticas que le ofrecen tanto el hardware como los sistemas operativos.\r
\r
Son muchas las tareas que requieren de un procesamiento r\xE1pido de cantidades ingentes de datos. Un par de ejemplos los tenemos en las aplicaciones \`Big Data\` e \`Inteligencia artificial\`. Estos dos campos son unos de los m\xE1ximos exponentes en cuanto a programaci\xF3n concurrente.\r
\r
::: details \xBFQu\xE9 es para ti concurrencia?\r
Vamos a discutirlo en clase.\r
Iremos desgranando y definiendo el concepto a lo largo del tema\r
:::\r
\r
## Objetivos\r
\r
Los objetivos que alcanzaremos tras esta unidad son:\r
\r
- Diferenciar entre programa y proceso\r
- Comprender qu\xE9 es la concurrencia\r
- Conocer el concepto, diferencias y relaci\xF3n existente entre las dos unidades b\xE1sicas de ejecuci\xF3n: procesos e hilos.\r
- Tener nociones sobre programaci\xF3n concurrente\r
- Entender el funcionamiento concurrente del SO y del hardaware\r
\r
`]},{title:"1.3 Procesos en el SO",headers:[{level:2,title:"1.3.1. El kernel del SO",slug:"_1-3-1-el-kernel-del-so",link:"#_1-3-1-el-kernel-del-so",children:[]},{level:2,title:"1.3.2. Control de procesos en GNU/Linux",slug:"_1-3-2-control-de-procesos-en-gnu-linux",link:"#_1-3-2-control-de-procesos-en-gnu-linux",children:[{level:3,title:"Comandos para saber el pid de los procesos",slug:"comandos-para-saber-el-pid-de-los-procesos",link:"#comandos-para-saber-el-pid-de-los-procesos",children:[]},{level:3,title:"Comandos para ver los procesos activos",slug:"comandos-para-ver-los-procesos-activos",link:"#comandos-para-ver-los-procesos-activos",children:[]},{level:3,title:"Control de procesos",slug:"control-de-procesos",link:"#control-de-procesos",children:[]}]},{level:2,title:"1.3.3. Estados de un proceso",slug:"_1-3-3-estados-de-un-proceso",link:"#_1-3-3-estados-de-un-proceso",children:[]},{level:2,title:"1.3.4 Planificaci\xF3n de procesos",slug:"_1-3-4-planificacion-de-procesos",link:"#_1-3-4-planificacion-de-procesos",children:[]},{level:2,title:"1.3.5. Algoritmos de planificaci\xF3n de procesos",slug:"_1-3-5-algoritmos-de-planificacion-de-procesos",link:"#_1-3-5-algoritmos-de-planificacion-de-procesos",children:[{level:3,title:"FCFS - First Come First Served",slug:"fcfs-first-come-first-served",link:"#fcfs-first-come-first-served",children:[]},{level:3,title:"SJF - Shortest Job First",slug:"sjf-shortest-job-first",link:"#sjf-shortest-job-first",children:[]},{level:3,title:"Planificaci\xF3n por prioridad",slug:"planificacion-por-prioridad",link:"#planificacion-por-prioridad",children:[]},{level:3,title:"Round Robin",slug:"round-robin",link:"#round-robin",children:[]},{level:3,title:"Procesos con operaciones de E/S o bloqueos",slug:"procesos-con-operaciones-de-e-s-o-bloqueos",link:"#procesos-con-operaciones-de-e-s-o-bloqueos",children:[]}]}],path:"/es/unit1/operatingsystem.html",pathLocale:"/es/",extraFields:[`---\r
title: 1.3 Procesos en el SO\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.3. Procesos en el SO" />\r
\r
# 1.3. Procesos en el Sistema Operativo\r
\r
[[toc]]\r
\r
## 1.3.1. El kernel del SO\r
\r
El \`kernel o n\xFAcleo de un SO\` se encarga de la funcionalidad b\xE1sica del sistema, el responsable de la gesti\xF3n de los recursos del ordenador, se accede al n\xFAcleo a trav\xE9s de las llamadas al sistema, es la parte m\xE1s peque\xF1a del sistema en comparaci\xF3n con la interfaz. El resto del sistema operativo se le denomina como programas del sistema.\r
\r
Todos los programas que se ejecutan en el ordenador se organizan como un conjunto de procesos. Es el sistema operativo el que decide parar la ejecuci\xF3n , por ejemplo, porque lleva mucho tiempo en la CPu, y decide cu\xE1l ser\xE1 el siguiente proceso que pasar\xE1 a ejecutarse.\r
\r
Cuando se suspende la ejecuci\xF3n de un proceso, luego deber\xE1 reiniciarse en el mismo estado en el que se encontraba antes de ser suspendido. Esto implica que debemos almacenar en alg\xFAn sitio la informaci\xF3n referente a ese proceso para poder luego restaurarla tal como estaba antes. Esta informaci\xF3n se almacena en el \`PCB\` (Bloque de control de procesos).\r
\r
Estos \`cambios de contexto\`, que es como se conoce al reemplazo de un proceso por otro, son bastante costosos (en tiempo y recursos) por toda la informaci\xF3n que hay que guardar. Ya veremos m\xE1s adelante que existe otra unidad de ejecuci\xF3n, los \`hilos\`, que solucionan en parte este problema.\r
\r
![Process Control Block](./../../media/unit1/process_control_blocks.gif)\r
\r
## 1.3.2. Control de procesos en GNU/Linux\r
\r
Los sistemas Linux identifican a los procesos por su PID (Process ID) as\xED como por su PPID (Parent PID). De esta forma, los procesos pueden clasificarse en:\r
\r
- Procesos padre: Son procesos que crean otros procesos durante su ejecuci\xF3n\r
- Procesos hijos: son procesos creados por otros procesos\r
\r
Cuando se arranca el sistema, el kernel lanza el proceso **init** que es la madre de todos los dem\xE1s procesos. Al ser el primero que se lanza es el \xFAnico que no tiene padre. El proceso init se encarga de gestionar todos los dem\xE1s procesos que se van ejecutando en el SO.\r
\r
::: info proceso init\r
El proceso init tiene el pid 1 y, como ya hemos dicho no tiene padre.\r
\r
Este proceso se utiliza como padre "adoptivo" para todos aquellos procesos que se quedan hu\xE9rfanos.\r
:::\r
\r
### Comandos para saber el pid de los procesos\r
\r
El comando \`pidof cmdname\` nos dice el nombre de todos los procesos asociados a ese comando. Es importante recordar que cada vez que ejecutamos un comando, se crea un nuevo proceso.\r
\r
Las variables $$ y $PPID nos indican el pid del proceso actual y su ppid respectivamente.\r
\r
\`\`\`bash\r
# pidof systemd\r
1\r
# pidof top\r
2060\r
# pidof httpd\r
2103 2102 2101 2100 2099 1076\r
# Process pid\r
echo $$\r
2109\r
# Process parent pid\r
echo $PPID\r
2106\r
\`\`\`\r
\r
### Comandos para ver los procesos activos\r
\r
El principal comando para conocer los procesos que se est\xE1n ejecutando en un equipo es el comando \`ps\`. Con este comando podemos ver parte de la informaci\xF3n asociada a un proceso.\r
\r
El comando ps tiene m\xFAltiples opciones que nos permiten ver m\xE1s o menos informaci\xF3n de los procesos, as\xED como los procesos de nuestro usuario o del resto de usuarios, estad\xEDsticas sobre el uso de recursos de cada proceso, etc.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
UID        PID  PPID  C    SZ   RSS PSR STIME TTY          TIME CMD\r
root         1     0  0   223   576   5 11:00 ?        00:00:00 /init\r
root         7     1  0   223    80   3 11:00 ?        00:00:00 /init\r
root         8     7  0   223    80   1 11:00 ?        00:00:00 /init\r
vicente      9     8  0  2508  5032   4 11:00 pts/0    00:00:00 -bash\r
vicente     70     9  0  2650  3224   5 11:06 pts/0    00:00:00 ps -AF\r
vicente@Desktop-Vicente:~$ ps -auxf\r
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\r
root         1  0.0  0.0    892   576 ?        Sl   11:00   0:00 /init\r
root         7  0.0  0.0    892    80 ?        Ss   11:00   0:00 /init\r
root         8  0.0  0.0    892    80 ?        S    11:00   0:00  \\_ /init\r
vicente      9  0.0  0.0  10032  5032 pts/0    Ss   11:00   0:00      \\_ -bash\r
vicente     72  0.0  0.0  10832  3408 pts/0    R+   11:09   0:00          \\_ ps -auxf\r
\`\`\`\r
\r
::: info Useful \u2018ps\u2019 examples for Linux process monitoring\r
[https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/](https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/)\r
:::\r
\r
El otro comando que nos permite ver la informaci\xF3n, en este caso en tiempo real, de los procesos que se est\xE1n ejecutando en l m\xE1quina junto con los recursos que est\xE1n consumiendo, es el comando \`top\`.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
top - 11:14:52 up 14 min,  0 users,  load average: 0.00, 0.00, 0.00\r
Tasks:   5 total,   1 running,   4 sleeping,   0 stopped,   0 zombie\r
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\r
MiB Mem :  12677.3 total,  12556.4 free,     70.6 used,     50.3 buff/cache\r
MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.  12433.8 avail Mem\r
\r
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\r
    1 root      20   0     892    576    516 S   0.0   0.0   0:00.04 init\r
    7 root      20   0     892     80     20 S   0.0   0.0   0:00.00 init\r
    8 root      20   0     892     80     20 S   0.0   0.0   0:00.01 init\r
    9 vicente   20   0   10032   5032   3324 S   0.0   0.0   0:00.11 bash\r
   73 vicente   20   0   10856   3664   3148 R   0.0   0.0   0:00.00 top\r
\`\`\`\r
\r
::: info \u2018top\u2019 examples in Linux\r
[https://www.tecmint.com/12-top-command-examples-in-linux/](https://www.tecmint.com/12-top-command-examples-in-linux/)\r
:::\r
\r
### Control de procesos\r
\r
Linux tiene varios comandos para controlar los procesos, entre los que cabe destacar el comando \`kill\`.\r
\r
La forma de controlar los procesos es envi\xE1ndoles se\xF1ales. Hay multitud de se\xF1ales que se pueden enviar a un proceso. Sin embargo, para responder a una se\xF1al, los procesos deben estar programados para gestionarlas.\r
\r
\`\`\`bash\r
# Get Firefox PID after it freezes\r
$ pidof firefox\r
2687\r
# Send the SIGKILL (9) signal to end the process immediately\r
$ kill 9 2687\r
\`\`\`\r
\r
::: info How to control Linux process Using kill, pkill and kilall\r
[https://www.tecmint.com/how-to-kill-a-process-in-linux/](https://www.tecmint.com/how-to-kill-a-process-in-linux/)\r
:::\r
\r
Otra forma de influir en la ejecuci\xF3n de los procesos es mediante la prioridad. En los sistemas Linux todos los procesos tienen una cierta prioridad. Esto influye a la hora de obtener tiempo de CPU por lo que podemos conseguir que un proceso se ejecute m\xE1s o menos r\xE1pido que los dem\xE1s.\r
\r
Un usuario con privilegios de *root* puede modificar los valores de prioridad de los procesos. Este valor lo podemos ver en la columna NI (nice) del comando top. Este valor influye en la columna PR que indica la prioridad que le da el sistema a un proceso.\r
\r
El rango de asignaci\xF3n de prioridad disponible es de -20 a 19 , siendo -20 la mayor prioridad y 19 la menor. Con el comando \`nice\` podemos asegurarnos que en momentos de usos elevados de CPU los procesos adecuados reciban el mayor % de la misma.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ nice\r
0\r
vicente@Desktop-Vicente:~$ nice -n 10 bash\r
vicente@Desktop-Vicente:~$ nice\r
10\r
vicente@Desktop-Vicente:~$\r
\`\`\`\r
\r
::: tip Control de procesos en Windows\r
En los sistemas operativos Windows, la mayor\xEDa de estas acciones se pueden realizar desde el administrador de tareas, aunque tambi\xE9n tenemos los comandos **tasklist** y **taskkill** para hacerlo desde consola\r
\r
*tasklist /svc /fi \u201Cimagename eq svchost.exe\u201D*\r
Con esta instrucci\xF3n sabremos que servicios se est\xE1n ejecutando bajo el proceso svchost.exe, es el nombre de proceso de host gen\xE9rico para servicios que se ejecutan desde bibliotecas de v\xEDnculos din\xE1micos (DLL), hay tantos para evitar riesgos ya que si estuviera todo en uno u nposible fallo podr\xEDa colapsar el sistema.\r
:::\r
\r
## 1.3.3. Estados de un proceso\r
\r
El siguiente diagrama muestra los tres posibles estados en los que se puede encontrar un proceso. Las l\xEDneas que conectan los estados representan las posibles transiciones que se pueden dar.\r
\r
En todo momento un procesos estar\xE1 en una de los tres estados. Como ya hemos visto, en los sitemas monoprocesador, un \xFAnico proceso podr\xE1 estar en estado de ejecuci\xF3n en un momento dado. El resto de procesos estar\xE1 o bien en espera o bien bbloqueados.\r
\r
Para cada uno de los estados se gestiona una lista de procesos que administra el kernel del SO. Los procesos permanecer\xE1n en la cola hasta que se produzca alg\xFAn evento.\r
\r
![Estados de un proceso](./../../media/unit1/estados_proceso.png)\r
\r
- **Nuevo**. El fichero es creado a partir de un ejecutable.\r
- **Listo**. Est\xE1 parado temporalmente y listo para ejecutarse cuando se le d\xE9 la oportunidad. El sistema oprativo todav\xEDa no le asigno un procesador para ejecutarse. El planificador del S.O. ser\xE1 el responsable de seleccionar el proceso para que pase a estado de ejecuci\xF3n.\r
- **En ejecuci\xF3n**. Est\xE1 usando el procesador. El sistema operativo utiliza el mecanismo de interrupciones para controlar su ejecuci\xF3n. Si el proceso necesitase un recurso, incluyendo la realizaci\xF3n de operaciones de E/S, llamar\xE1 a la llamada al sistema correspondiente. Si un proceso se ejecuta durante el m\xE1ximo tiempo permitido por la pol\xEDtica del sistema, salta un temporizador que lanza una interrupci\xF3n. Si el sistema es de tiempo compartido, lo para y lo pasa a estado de listo.\r
- **Bloqueado**. El proceso se encuentra bloqueado esperando a aque ocurra alg\xFAn suceso. Por ejemplo puede estar esperando a que termine alguna operaci\xF3n de E/S, o bien a sincronizarse con otro proceso. Cuando ocurre el evento que lo desbloquea, el proceso queda pendiente de ser planificado por el S.O. no pasa directamente a ejecuci\xF3n.\r
- **Terminado**. El proceso termina y libera su imagen de memoria. Es el propio proceso el que debe llamar al sistema para indicar que ha terminado, aunque el sistema puede finalizarlo con una excepci\xF3n (que es una interrupci\xF3n especial).\r
\r
Transiciones entre estados:\r
\r
- **De ejecuci\xF3n a bloqueado**: un proceso pasa de ejecuci\xF3n a bloqueado cuando espera la ocurrencia de un evento externo.\r
- **De bloqueado a listo**: cuando ocurre el evento externo que esperaba\r
- **De listo a ejecuci\xF3n**: cuando el sistema le otorga un tiempo de CPU.\r
- **De ejecuci\xF3n a listo**: cuando se le acaba el tiempo asignado por el S.O.\r
\r
## 1.3.4 Planificaci\xF3n de procesos\r
\r
Uno de los objetivos de los sistemas operativos es la multiprogramaci\xF3n, es decir, admitir varios procesos en memoria para maximizar el uso del procesador. Esto funciona ya que los procesos se ir\xE1n intercambiando el uso del procesador para su ejecuci\xF3n de forma concurrente. Para ello, el sistema operativo organiza los procesos en varias colas pas\xE1ndolos de unas colas a otras\r
\r
- Cola de procesos: contiene todos los procesos del sistema\r
- Cola de procesos preparados: todos los procesos listos esperando para ejecutarse.\r
- Varias colas de dispositivos: procesos que est\xE1n esperando alguna operaci\xF3n de E/S.\r
\r
![Colas de procesos del planificador](./../../media/unit1/process_queues.gif)\r
\r
El planificador es el encargado de seleccionar los movimientos de los procesos entre las distintas colas. Existe una planificaci\xF3n a corto plazo y otra a largo plazo, veamos cada una:\r
\r
- Corto plazo: selecciona los procesos de la cola de preparados para pasarlos a ejecuci\xF3n, se invoca con mucha frecuencia, del orden de milisegundos, por lo que el algoritmo debe ser muy sencillo.\r
  - Planificaci\xF3n sin desalojo: un proceso en ejecuci\xF3n s\xF3lo se saca si termina o bien se queda bloqueado.\r
  - Planificaci\xF3n apropiativa: solo se saca un proceso de ejecuci\xF3n si termina, se bloquea o por \xFAltimo aparece un proceso con mayor prioridad.\r
  - Tiempo compartido: cada cierto tiempo (cuanto), se desaloja un proceso y se mete otro, Se considera que todos los procesos tienen la misma prioridad.\r
- Largo plazo: selecciona que procesos nuevos pasan a la cola de preparados. Hace un control del grado de multiprogramaci\xF3n del proceso para tomar sus decisiones.\r
\r
::: warning Cambios de contexto\r
El cambio de contexto que se hace al cambiar un proceso es tiempo perdido, ya no se hace trabajo \xFAtil. Cambiar el estado del proceso, el estado del procesador (cambio valores de registro) e informaci\xF3n de la gesti\xF3n de memoria, por muy r\xE1pido que se haga si se hace con mucha frecuencia puede provocar una ralentizaci\xF3n del sistema, por eso tener muchos programas abiertos provoca una disminuci\xF3n importante en el rendimiento del sistema.\r
:::\r
\r
## 1.3.5. Algoritmos de planificaci\xF3n de procesos\r
\r
Los algoritmos de planificaci\xF3n se utilizan para intentar mejorar el rendimiento del sistema y, por ende, la experiencia de usuario.\r
\r
Para establecer par\xE1metros objetivos que permitan comparar los diferentes resultados, vamos a tomar como referencia los siguientes criterios:\r
\r
- **Tiempo de espera**: tiempo que un proceso permanece en la cola de preparados o de bloqueados esperando a ser ejecutado.\r
- **Tiempo de retorno**: tiempo transcurrido entre la llegada de un proceso y su finalizaci\xF3n.\r
- **Uso de CPU**: % de tiempo que la CPU est\xE1 siendo utilizada\r
  \r
> En un sistema con 1 unidad de proceso  \r
> ![Uso 1 CPU](./../../media/unit1/uso1cpu.gif)\r
<!--$\\frac{\\#\\ instantes\\ de\\ tiempo\\ que \\ el\\ procesador\\ esta\\ ocupado}{instante\\ de\\ tiempo\\ en\\ el\\ que\\ acaba\\ el\\ ultimo\\ proceso}$\\  \\ x \\ 100-->\r
> En un sistema con N unidades de proceso  \r
> ![Uso 2 CPU](./../../media/unit1/uso2cpu.gif)\r
<!--$\\frac{\\sum_{n=1}^{N}\\#\\ instantes\\ de\\ tiempo\\ que\\ el \\ procesador_n\\ esta\\ ocupado}{instante\\ de\\ tiempo\\ en\\ el\\ que\\ acaba\\ el\\ ultimo\\ proceso\\ *\\ N}$ x100-->\r
\r
- **Rendimiento/Productividad (throughput)**: n\xFAmero de procesos que se completan por unidad de tiempo\r
![Rendimiento](./../../media/unit1/rendimiento.gif)\r
<!-- $\\frac{nmero\\ de\\ procesos}{instante\\ de\\ tiempo\\ en\\ el\\ que\\ acaba\\ el\\ \xFAltimo\\ proceso}$-->\r
\r
| Procesos | LLegada | Tiempo uso CPU | Prioridad |\r
| :------: | :-----: | :------------: | :-------: |\r
|    P1    |    0    |       10       |     5     |\r
|    P2    |    1    |       6        |    10     |\r
|    P3    |    2    |       3        |     7     |\r
\r
Con esta informaci\xF3n, vamos a ver c\xF3mo se comportan los diferentes algoritmos\r
\r
### FCFS - First Come First Served\r
\r
En esta pol\xEDtica de planificaci\xF3n, el procesador ejecuta cada proceso hasta que termina o pasa al estado de bloqueado, por tanto, los procesos que est\xE1n en la cola de procesos preparados permanecer\xE1n en el orden en que lleguen hasta que les toque su ejecuci\xF3n. Este m\xE9todo se conoce tambi\xE9n como FIFO (Fist In, First Out).\r
\r
Se trata de una pol\xEDtica muy simple y sencilla de llevar a la pr\xE1ctica, pero muy pobre en cuanto a su comportamiento.\r
\r
La cantidad de tiempo de espera de cada proceso depende del n\xFAmero de procesos que se encuentren en la cola en el momento de su petici\xF3n de ejecuci\xF3n y del tiempo que cada uno de ellos tenga en uso al procesador, y es independiente de las necesidades del propio proceso.\r
\r
![FCFS monoprocessor](./../../media/unit1/fcfs-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 2     : active,t2, after t1, 6s\r
Process 3     : crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       9       |        15         |           |\r
|    P3    |      14       |        17         |           |\r
|          |\r
|  Medias  |      7,6      |        14         |   100%    |     0,15      |\r
\r
![FCFS dual processor](./../../media/unit1/fcfs-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       5       |         8         |           |\r
|          |\r
|  Medias  |      1,6      |         6         |    95%    |      0,3      |\r
\r
### SJF - Shortest Job First\r
\r
Este algoritmo siempre prioriza los procesos m\xE1s cortos primero independientemente de su llegada y en caso de que los procesos sean iguales utilizara el m\xE9todo FIFO anterior, es decir, el orden seg\xFAn entrada. Este sistema tiene el riesgo de poner siempre al final de la cola los procesos m\xE1s largos por lo que nunca se ejecutar\xE1n, esto se conoce como \`inanici\xF3n\`.\r
\r
![SJF monoprocessor](./../../media/unit1/sjf-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title SJF (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |      12       |        18         |           |\r
|    P3    |       8       |        11         |           |\r
|          |\r
|  Medias  |      7,3      |        13         |   100%    |     0,15      |\r
\r
![SJF dual processor](./../../media/unit1/sjf-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       5       |         8         |           |\r
|          |\r
|  Medias  |      1,6      |         6         |    95%    |      0,3      |\r
\r
### Planificaci\xF3n por prioridad\r
\r
Cada proceso tiene una prioridad, ejecut\xE1ndose primero el que tenga mayor prioridad, independientemente de su llegada y en caso de que las prioridades sean iguales utilizar\xE1 el m\xE9todo FIFO anterior, es decir, el orden seg\xFAn entrada.\r
\r
Como ocurr\xEDa con SJF, con este algoritmo son los procesos de prioridad m\xE1s baja los que tienen riesgo de\r
inanici\xF3n.\r
\r
![Prioridad monoprocessor](./../../media/unit1/prioridad-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |      12       |        18         |           |\r
|    P3    |       8       |        11         |           |\r
|          |\r
|  Medias  |      6,6      |        13         |   100%    |     0,15      |\r
\r
![Prioridad dual processor](./../../media/unit1/prioridad-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       5       |         8         |           |\r
|          |\r
|  Medias  |      1,6      |         6         |    95%    |      0,3      |\r
\r
### Round Robin\r
\r
Este algoritmo de planificaci\xF3n es uno de los m\xE1s complejos y dif\xEDciles de implementar, asigna a cada proceso un tiempo equitativo tratando a todos los procesos por igual y con la misma prioridad.\r
\r
Este algoritmo es circular, volviendo siempre al primer proceso una vez terminado con el \xFAltimo. Para controlar que todos los procesos tienen su tiempo de CPU este m\xE9todo asigna a cada proceso un intervalo de tiempo llamado \`quantum\`.\r
\r
Se pueden dar dos casu\xEDsticas con este m\xE9todo :\r
\r
- El proceso, o lo que le queda por ejecutar, es menor que el quantum: Al terminar antes se planifica un nuevo proceso.\r
- El proceso, o lo que le queda por ejecutar, es mayor que el quantum: Al terminar el quantum se expulsa el proceso dando paso al siguiente proceso en la lista. Al terminar la iteraci\xF3n se volver\xE1 para terminar el primer proceso expulsado.\r
\r
![RR monoprocessor](./../../media/unit1/roundrobin-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 2s\r
Process 2     : active,t2, after t1, 2s\r
Process 3     : crit, t3, after t2, 2s\r
Process 1      :done, t4, after t3, 2s\r
Process 2     : active,t5, after t4, 2s\r
Process 3     : crit, t6, after t5, 1s\r
Process 1      :done, t7, after t6, 2s\r
Process 2     : active,t8, after t7, 2s\r
Process 1      :done, t9, after t8, 2s\r
Process 1      :done, t10, after t9, 2s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       9       |        19         |           |\r
|    P2    |       8       |        14         |           |\r
|    P3    |       6       |         9         |           |\r
|          |\r
|  Medias  |      7,6      |        14         |   100%    |     0,15      |\r
\r
![RR dual processor](./../../media/unit1/roundrobin-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1_1, 0, 2s\r
Process 3     :crit, t3_1, after t1_1, 2s\r
Process 1     :done, t1_2, after t3_1, 2s\r
Process 3     :crit, t3_2, after t1_2, 1s\r
Process 1     :done, t1_3, after t3_2, 2s\r
Process 1     :done, t1_4, after t1_3, 2s\r
Process 1     :done, t1_5, after t1_4, 2s\r
section Processor 2\r
.     :active, ., 0, 0s\r
Process 2     :active, t2_1, 1, 2s\r
Process 2     :active, t2_2, after t2_1, 2s\r
Process 2     :active, t2_3, after t2_2, 2s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       3       |        13         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       2       |         5         |           |\r
|          |\r
|  Medias  |      1,6      |       7,6         |    73%    |      0,23     |\r
\r
::: question Planificador combinado\r
En realidad, no se usa una \xFAnica estrategia de planificaci\xF3n, sino que lo m\xE1s com\xFAn es que se combinen varias de ellas. De hecho en Round-Robin hemos usado tambi\xE9n FCFS.\r
\r
\xBFTe atreves a ver c\xF3mo ser\xEDa una planificaci\xF3n Round-Robin con prioridad? Ten en cuenta que funcionar\xE1 con el quantum y a la hora de escoger el siguiente proceso a ejecutar, se basar\xE1 en la prioridad de los que haya en la lista.\r
:::\r
\r
### Procesos con operaciones de E/S o bloqueos\r
\r
En los ejemplos anteriores hemos visto que todos los procesos pasan su tiempo en el procesador, pero esto no es un reflejo de la realidad, m\xE1s bien al contrario. Los procesos en determinados momentos deben dejar el procesador para esperar una entrada de usuario, leer o almacenar informaci\xF3n en disco, o s\xEDmplemente esperar a que otro proceso termine una acci\xF3n y le envie un dato que necesita para continuar.\r
\r
En esos instantes, el proceso deja el procesador libre para que otros puedan hacer uso de \xE9l. En el momento en que ha terminado su espera o bloqueo, se vuelve a poner en cola de preparado para seguir ejecut\xE1ndose.\r
\r
En el siguiente gr\xE1fico tenemos una especificaci\xF3n de la actividad de 2 procesosen el que, antes de realizar el \xFAltimo paso de ambos, debe haber acabado la operaci\xF3n de E/S que realiza el proceso1.\r
\r
![Procesos con E/S](./../../media/unit1/operaciones_es.svg)\r
<!--\r
\`\`\`mermaid\r
graph LR\r
\r
subgraph Process 2\r
    p2_1["run for 2"]--p2_2["E/S for 3"]--p2_3["run for 4"]--p2_5["run for 3"]\r
end\r
subgraph Process 1\r
    p1_1["run for 3"]--p1_2["E/S for 1"]--p1_3["run for 5"]--p1_4["E/S for 2"]--p1_5["run for 4"]\r
    p1_4--p2_5\r
end\r
\`\`\`\r
-->\r
\r
Veamos c\xF3mo se materializa esto en una ejecuci\xF3n de los procesos, suponiendo que ambos llegan a la vez a la cola.\r
\r
![RR dual processor](./../../media/unit1/roundrobin-3.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Task 1\r
P1 runs 2 (exits because of q expiration)      :done, t1_1, 0, 2s\r
P1 runs 1 (exits and has to wait 1 for E/S)      :done, t1_2, after t2_1, 1s\r
E/S :crit, es1_1, after t1_2, 1s\r
P1 runs 2 (exits because of q expiration)      :done, t1_3, after es1_1, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_4, after t2_2, 2s\r
P1 runs 2 (exits and has to wait 1 for E/S)      :done, t1_5, after t2_3, 1s\r
E/S :crit, es1_2, after t1_5, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_6, after es1_2, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_7, after t2_4, 2s\r
\r
section Task 2 \r
P2 runs 2 (exits and has to wait 3 for E/S) :active, t2_1, after t1_1, 2s\r
E/S :crit, es2_1, after t2_1, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_2, after t1_3, 2s\r
P2 runs 2 (exits because of q expiration)      :active, t2_3, after t1_4, 2s\r
Locked waiting :crit, es2_2, after t2_3, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_4, after t1_6, 2s\r
P2 runs 2 (ends execution)      :active, t2_5, after t1_7, 1s\r
'''\r
-->\r
`]},{title:"1.1 Procesos, programas, hilos",headers:[{level:2,title:"1.1.1. Procesos y programas",slug:"_1-1-1-procesos-y-programas",link:"#_1-1-1-procesos-y-programas",children:[]},{level:2,title:"1.1.2. Programaci\xF3n concurrente",slug:"_1-1-2-programacion-concurrente",link:"#_1-1-2-programacion-concurrente",children:[{level:3,title:"\xBFPara qu\xE9?",slug:"\xBFpara-que",link:"#\xBFpara-que",children:[]},{level:3,title:"Comunicaci\xF3n y sincronizaci\xF3n entre procesos",slug:"comunicacion-y-sincronizacion-entre-procesos",link:"#comunicacion-y-sincronizacion-entre-procesos",children:[]}]},{level:2,title:"1.1.3. Servicios e hilos",slug:"_1-1-3-servicios-e-hilos",link:"#_1-1-3-servicios-e-hilos",children:[{level:3,title:"Programa secuencial (Arquitectura Von Newmann)",slug:"programa-secuencial-arquitectura-von-newmann",link:"#programa-secuencial-arquitectura-von-newmann",children:[]},{level:3,title:"Programa concurrente",slug:"programa-concurrente",link:"#programa-concurrente",children:[]},{level:3,title:"Hilos vs procesos",slug:"hilos-vs-procesos",link:"#hilos-vs-procesos",children:[]}]}],path:"/es/unit1/process.html",pathLocale:"/es/",extraFields:[`---\r
title: 1.1 Procesos, programas, hilos\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.1. Procesos, programas, hilos" />\r
\r
# 1.1. Procesos, Programas, hilos\r
\r
[[toc]]\r
\r
\r
## 1.1.1. Procesos y programas\r
\r
Un \`programa\` no es m\xE1s que un conjunto de instrucciones u \xF3rdenes que le indican a un dispositivo qu\xE9 acciones debe realizar con los datos recibidos.\r
\r
::: tip Caja negra\r
Seg\xFAn la visi\xF3n de un sistema como caja negra, un programa le indica al sistema c\xF3mo obtener unos datos de salida a partir de unos datos de entrada.\r
:::\r
\r
Sin embargo, un \`proceso\` es un programa en ejecuci\xF3n. Esto es, un proceso es una entidad activa y un programa es una entidad pasiva.\r
\r
El proceso, por tanto, est\xE1 representado por el contador del programa, el valor de los registros, la pila, el *c\xF3digo ejecutable*, su estado, ... todo lo necesario para la ejecuci\xF3n del programa por parte del SO.\r
\r
![Proceso en memoria](./../../media/unit1/proceso_memoria.png)\r
\r
Cada proceso es una entidad independiente. Cuando un programa se ejecuta, el sistema operativo crea un proceso. Si ese mismo programa se vuelve a ejecutar, se crear\xEDa un proceso distinto, teniendo en memoria dos instancias del mismo programa. Pero es importante recalcar que los dos procesos son independientes.\r
\r
\r
## 1.1.2. Programaci\xF3n concurrente\r
\r
Podemos decir que dos procesos son concurrentes cuando la primera instrucci\xF3n de uno de los procesos se ejecuta despu\xE9s de la primera y antes de la \xFAltima de otro proceso.\r
\r
La planificaci\xF3n alternando los instantes de ejecuci\xF3n, \`multitarea\`, hace que los procesos se ejecuten de forma concurrente. Tambi\xE9n la disponibilidad de varias unidades de proceso, \`multiproceso\`, permite la ejecuci\xF3n simult\xE1nea o paralela de procesos en el sistema.\r
\r
![Concurrencia vs paralelismo](./../../media/unit1/concurrencia_vs_paralelismo.jpg)\r
\r
::: tip Concurrencia\r
A los dos escenarios descritos anteriormente es a lo que vamos a denominar, de forma general, **concurrencia**.\r
:::\r
\r
### \xBFPara qu\xE9?\r
\r
Las principales razones por las que se utiliza una estructura concurrente son:\r
\r
- Optimizar la utilizaci\xF3n de los recursos: Podremos simultanear las operaciones de E/S en los procesos. La CPU estar\xE1 menos tiempo ociosa.\r
- Proporcionar interactividad a los usuarios (y animaci\xF3n gr\xE1fica).\r
- Mejorar la disponibilidad: Servidor que no realice tareas de forma concurrente, no podr\xE1 atender peticiones de clientes simult\xE1neamente.\r
- Conseguir un dise\xF1o conceptualmente m\xE1s comprensible y mantenible: El dise\xF1o concurrente de un programa nos llevar\xE1 a una mayor modularidad y claridad.\r
- Aumentar la protecci\xF3n: Tener cada tarea aislada en un proceso permitir\xE1 depurar la seguridad de cada proceso y poder finalizarlo en caso de mal funcionamiento sin que suponga la ca\xEDda del sistema.\r
\r
Adem\xE1s, los actuales avances tecnol\xF3gicos hacen necesario tener en cuenta la concurrencia en el dise\xF1o de las aplicaciones para aprovechar su potencial. Los nuevos entornos hardware son:\r
\r
- Microprocesadores con m\xFAltiples n\xFAcleos que comparten la memoria principal del sistema.\r
- Entornos multiprocesador con memoria compartida.\r
- Entornos distribuidos y servicios cloud.\r
\r
### Comunicaci\xF3n y sincronizaci\xF3n entre procesos\r
\r
Cuando varios procesos se ejecutan concurrentemente puede haber procesos que colaboren para un determinado fin mientras que puede haber otros que compitan por los recursos del sistema.\r
\r
En ambos casos se hace necesaria la introducci\xF3n de mecanismos de comunicaci\xF3n y sincronizaci\xF3n entre procesos.\r
\r
:::info Programaci\xF3n concurrente\r
Precisamente del estudio de esos **mecanismos de sincronizaci\xF3n y comunicaci\xF3n** trata la programaci\xF3n concurrente y este m\xF3dulo de PSP.\r
:::\r
\r
Si pensamos en la forma en la que un proceso puede comunicarse con otro, se nos plantean estas dos:\r
\r
- Intercambio de mensajes: Es la forma que se utiliza habitualmente cuando los procesos se encuentran en m\xE1quinas diferentes. Los procesos intercambian informaci\xF3n siguiendo un protocolo previamente establecido.\r
- Recursos (o memoria) compartidos: S\xF3lo se puede utilizar cuando los dos procesos se encuentran en la misma m\xE1quina y permite la sincronizaci\xF3n de los procesos en funci\xF3n del valor o estado de un recurso compartido.\r
\r
Tambi\xE9n podemos ver el tipo de comunicaci\xF3n en funci\xF3n de la sincron\xEDa que mantengan los procesos durante la comunicaci\xF3n:\r
\r
- S\xEDncrona: El emisor queda bloqueado hasta que el receptor recibe el mensaje. Ambos\r
se sincronizan en el momento de la recepci\xF3n del mensaje.\r
- As\xEDncrona: El emisor contin\xFAa con su ejecuci\xF3n inmediatamente despu\xE9s de emitir el\r
mensaje, sin quedar bloqueado.\r
\r
\r
## 1.1.3. Servicios e hilos\r
\r
Un programa, como ya hemos dicho, se compone de un conjunto de sentencias (operaciones y verificaciones) y un flujo de ejecuci\xF3n. La l\xEDnea de flujo de control establece, de acuerdo con la estructura del propio programa y de los datos que maneja, el orden en que deben ejecutarse las sentencias.\r
\r
Atendiendo al n\xFAmero de l\xEDneas de flujo de control que tiene un programa, los procesos pueden ser:\r
\r
- Secuenciales: Poseen un \xFAnico flujo de control (monohilo)\r
- Concurrentes: Poseen varios hilos de ejecuci\xF3n (multihilo).\r
\r
\r
### Programa secuencial (Arquitectura Von Newmann)\r
\r
Cuando empezamos a programar, usamos el estilo de programaci\xF3n cl\xE1sico, en el que se sigue el modelo conceptual de Von Newmann\r
\r
Los programas secuenciales presentan una l\xEDnea simple de control de flujo. Las operaciones de este tipo de programas est\xE1n estrictamente ordenados como una secuencia temporal lineal.\r
\r
El comportamiento del programa es solo funci\xF3n de la naturaleza de las operaciones individuales que constituye el programa y del orden en que se ejecutan (determinado por el conjunto de entradas que recibe).\r
\r
En los programas secuenciales, el tiempo que tarda cada operaci\xF3n en ejecutarse no tiene consecuencias sobre el resultado.\r
\r
![Sequential flowchat example](./../../media/unit1/sequential_flowchart.png)\r
\r
La comprobaci\xF3n del correcto funcionamiento (\`verificaci\xF3n\` o \`depuraci\xF3n\`) de un programa secuencial es sencilla:\r
\r
- Cada sentencia produce la respuesta correcta.\r
- Las sentencias se ejecutan en el orden esperado.\r
\r
De aqu\xED surgen algunos de los m\xE9todos b\xE1sicos de pruebas de sistemas, como el de *caja blanca*.\r
\r
### Programa concurrente\r
\r
En los programas concurrentes existen m\xFAltiples l\xEDneas de control de flujo. Las sentencias que constituyen el programa no se ejecutan siguiendo un \xF3rden que corresponda a una secuencia temporal lineal.\r
\r
En los programas concurrentes el concepto de secuencialidad entre sentencias continua siendo muy importante. Sin embargo en los programas concurrentes es de orden parcial, mientras que, tal y como hemos comentado anteriormente, en los programas secuenciales era de orden estricto.\r
\r
![Concurrent flowchat example](./../../media/unit1/concurrent_flowchart.png)\r
\r
En los programas concurrentes la *secuencializaci\xF3n* entre procesos concurrentes se llama **sincronizaci\xF3n**.\r
\r
Este orden parcial implica que los programas concurrentes no tienen porqu\xE9 ser deterministas, es decir, que ante el mismo conjunto de datos de entrada no siempre se va a obtener el mismo resultado.\r
\r
::: danger Indeterminismo\r
Que existan diferentes salidas para el mismo conjunto de datos de entrada no significa necesariamente que un programa concurrente sea incorrecto.\r
:::\r
\r
Si observamos el siguiente ejemplo de pseudoc\xF3digo\r
\r
\`\`\`java {16-17,25-28}\r
public class TestClass {\r
    int x;\r
\r
    public void testMethod1() {\r
        for (int i=1; i <= 5; i++) {\r
            x++;\r
        }\r
    }\r
    public void testMethod2() {\r
        for (int j=1; j <= 5; j++) {\r
            x++;\r
        }\r
    }\r
    public void sequential() {\r
        x = 0;\r
        testMethod1();\r
        testMethod2();\r
        System.out.println(x);\r
    }\r
    public void parallel() {\r
        x = 0;\r
        // cobegin-coend means that both methods are run simultaneously\r
        // These sentences doesn't exist in Java. They are used for \r
        // sample purposes\r
        cobegin\r
            testMethod1();\r
            testMethod2();\r
        coend\r
        System.out.println(x);\r
    }\r
}\r
\`\`\`\r
\r
::: question\r
\xBFQu\xE9 valor tendr\xE1 x tras ejecutar el m\xE9todo sequential?\r
\r
\xBFQu\xE9 valor tendr\xE1 x tras ejecutar el m\xE9todo parallel?\r
:::\r
\r
::: info Rese\xF1a hist\xF3rica\r
La naturaleza y los modelos de interacci\xF3n entre procesos de un programa concurrente fueron estudiados y descritos por **Dijkstra** (1968), Brinch **Hansen** (1973) y **Hoare** (1974). \r
\r
Estos trabajos constituyeron los principios en que se basaron los sistemas operativos multiproceso de la d\xE9cada de los 70 y 80.\r
:::\r
\r
El indeterminismo inherente a los programas concurrentes hace que su an\xE1lisis y validaci\xF3n sea m\xE1s complejo. No obstante, para la comprobaci\xF3n del correcto funcionamiento (\`verificaci\xF3n\` o \`depuraci\xF3n\`) de un programa concurrente se requiere comprobar los mismos aspectos que en los programas secuenciales, pero con los siguientes nuevos aspectos:\r
\r
- Las sentencias se pueden validar individualmente solo si no est\xE1n acopladas por variables compartidas.\r
- Cuando existen variables compartidas, los efectos de interferencia entre las sentencias concurrentes pueden ser muy variados y la validaci\xF3n es muy dif\xEDcil. <Badge type="danger" text="cuidado" vertical="middle" />\r
- Siempre que la secuencialidad entre tareas se lleve a cabo por sentencias expl\xEDcitas de **sincronizaci\xF3n**, el tiempo es un elemento que no influye sobre el resultado\r
\r
::: warning Importante\r
Estos tres aspectos que se acaban de describir forman la base de toda la programaci\xF3n concurrente.\r
\r
:eye: Conocerlos, entenderlos y saber aplicarlos es a lo que dedicaremos una parte importante de este curso.\r
:::\r
\r
\r
### Hilos vs procesos\r
\r
Un hilo no es m\xE1s que cada una de esas l\xEDneas de flujo que puede tener un proceso ejecut\xE1ndose de forma concurrente. Un procesos es una unidad pesada de ejecuci\xF3n.\r
\r
As\xED, un proceso estar\xE1 formado por, al menos, un hilo de ejecuci\xF3n, el hilo principal. Si el proceso tiene varios hilos, cada uno es una unidad de ejecuci\xF3n ligera.\r
\r
| Procesos                         | Hilos                                               |\r
| :------------------------------- | :-------------------------------------------------- |\r
| Constan de uno o m\xE1s hilos       | Un hilo siempre existe dentro de un proceso         |\r
| Son independientes unos de otros | Comparten los recursos del proceso de forma directa |\r
| Son gestionados por el SO        | Son gestionados por el proceso                      |\r
| Se comunican a trav\xE9s del SO     | La comunicaci\xF3n la controla el proceso              |\r
\r
![Threads vs Processes](./../../media/unit1/threads_vs_process.jpg)\r
\r
En la imagen anterior se puede observar la relaci\xF3n existente entre la creaci\xF3n de un thread y la de su proceso asociado.\r
\r
- El proceso define un espacio de memoria en el que reside. Los hilos comparten ese espacio de memoria. Dentro de ese espacio de memoria cada hilo tiene su espacio reservado, pero todos pueden compartir la memoria global del proceso y los recursos (ficheros, sockets, etc.) que el proceso tenga abiertos.\r
- Como ya hemos visto, cada proceso tiene su PCB con informaci\xF3n relativa al proceso.\r
- Los hilos, de forma similar, tienen su TCB (Thread Control Block) en el que guardan la informaci\xF3n espec\xEDfica de cada hilo (Contador de programa, puntero a la pila, estado del thread, registros y un puntero al PCB). \r
\r
::: info Servicios\r
Un servicio es un proceso que, normalmente, es cargado durante el arranque del sistema operativo. Al no necesitar interacci\xF3n con el usuario, los servicios suelen ejecutarse en forma de **demonios*, quedan su ejecuci\xF3n en *segundo plano*.\r
\r
Recibe el nombre de servicio ya que es un proceso que queda a la espera de que otro le pida que realice una tarea. Como deben atender las solicitudes de varios procesos, los servicios suelen ser programas multihilo.\r
:::\r
`]},{title:"2.4 Anexo I - Curl",headers:[{level:2,title:"2.4.1 C\xF3mo obtener curl",slug:"_2-4-1-como-obtener-curl",link:"#_2-4-1-como-obtener-curl",children:[]},{level:2,title:"2.4.2 Realizando una petici\xF3n GET",slug:"_2-4-2-realizando-una-peticion-get",link:"#_2-4-2-realizando-una-peticion-get",children:[]},{level:2,title:"2.4.2 Puntos finales y rutas",slug:"_2-4-2-puntos-finales-y-rutas",link:"#_2-4-2-puntos-finales-y-rutas",children:[]},{level:2,title:"2.4.3 M\xE9todos HTTP y cabeceras",slug:"_2-4-3-metodos-http-y-cabeceras",link:"#_2-4-3-metodos-http-y-cabeceras",children:[]},{level:2,title:"2.4.4 Authentication",slug:"_2-4-4-authentication",link:"#_2-4-4-authentication",children:[]},{level:2,title:"2.4.5 References",slug:"_2-4-5-references",link:"#_2-4-5-references",children:[]}],path:"/es/unit2/curl_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.4 Anexo I - Curl\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.4 Anexo I - Curl" />\r
\r
# 2.4 Anexo I - Curl\r
\r
 Curl est\xE1 dise\xF1ado para funcionar como una forma de verificar la conectividad a las URL y como una gran herramienta para transferir datos. Tiene especial relevancia e inter\xE9s cunado se trata de usar servicios basados en API REST, tanto para comprobar su funcionamiento durante la fase de pruebas o bien para cuando el sistema ya est\xE1 en producci\xF3n.\r
\r
Curl es una herramienta de l\xEDnea de comandos que nos permite hacer peticiones HTTP desde la consola. Su principal uso es obtener una respuesta de un sitio web (pro ejemplo, para saber que no est\xE1 ca\xEDdo) o para comprobar tiempos de respuesta.\r
\r
::: info curl means ...\r
La herramienta fu\xE9 pensada para subir y descargar informaci\xF3n usando una URL. Es una aplicaci\xF3n cliente (de ah\xED la 'c'), y a su vez es un cliente de URLs. Por lo tanto, 'c' de cliente y URL: cURL.\r
\r
En ingl\xE9s "curl" se pronuncia con un sonido inicial /k/, rimando con la pronunciaci\xF3n de la palabra girl.\r
\r
Por el contrario, si lo deletreamos como c-URL, entonces us significado tambi\xE9n adquiere un sentido l\xF3gico, ver-URL (see-URL), lo cual tambi\xE9n es una buena definici\xF3n de la utilidad de esta herramienta.\r
:::\r
\r
Curl funciona con protocolos que permiten la transferencia de datos en una o dos direcciones. Soporta protocolos basados en una "URI" y que est\xE9n descritos en una RFC, por lo que curl funciona principalmente con URLs (URIs en realidad) como el origen y/o destino de las transferencias e intercambios de informaci\xF3n que realiza.\r
\r
Actualmente curl ofrece soporte para los siguiente protocolos:\r
\r
>DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP.\r
\r
## 2.4.1 C\xF3mo obtener curl\r
\r
curl es una utilidad libre, abierta y disponible en varios formatos. Podemos descargarla y configurarla en la mayor\xEDa de los sistemas operativos y arquitecturas hardware. Algunos SO ya la incluyen en sus distribuciones.\r
\r
La fuente principal de informaci\xF3n y descarga siempre deber\xEDa ser el [sitio oficial de CURL](http://curl.se) donde podemos descargar, entre otros, los instaladores para nuestros sistemas.\r
\r
- Linux (Ubuntu / Debian). curl viene instalado por defecto. De todas formas, podemos actualizarlo e instalarlo usando el gesto de paquetes APT\r
  > apt install curl\r
- Windows 10 viene con la herramienta curl instalada en sus sistemas desde la versi\xF3n 1804\r
    > podemos descargar e instalar la \xFAltima versi\xF3n oficial de curl para windows desde [curl windows binaries](http://curl.se/windows)\r
- MacOS tambi\xE9n trae de serie la herramienta curl desde hace ya bastantes a\xF1os. Si necesitamos actualizar la versi\xF3n que tenemos en el sistema, se recomienda instalar homebrew (un gesto de paquetes para macOS)\r
    > brew install curl\r
\r
## 2.4.2 Realizando una petici\xF3n GET\r
\r
La sintaxis b\xE1sica de Curl se ve as\xED:\r
\r
curl [OPTIONS] [URL]\r
El uso m\xE1s simple de Curl es mostrar el contenido de una p\xE1gina. El siguiente comando mostrar\xE1 la p\xE1gina de inicio de testdomain.com.\r
\r
> curl testdomain.com\r
\r
Esto generar\xE1 el c\xF3digo fuente completo de la p\xE1gina de inicio del dominio. Si no se especifica ning\xFAn protocolo, curl lo interpretar\xE1 a HTTP.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl http://www.net.net\r
<head><title>Document Moved</title></head>\r
<body><h1>Object Moved</h1>This document may be found <a HREF="http://net.net">here</a></body>\r
\r
\`\`\`\r
\r
Si no se indica lo contrario, curl realiza una solicitud HTTP con el m\xE9todo GET a la URL indicada. La salida del programa para el comando enviado ser\xE1 el cuerpo de la respuesta HTTP, en el caos anterior, el c\xF3digo HTML de la URL solicitada.\r
\r
Si en vez de mostrar la salida recibida por pantalla nos interesa guardar la informaci\xF3n en un archivo, podemos usar el par\xE1metro \`-o (--output)\`:\r
\r
> curl -o output.html www.net.net\r
>\r
> // Es equivalente a hacer esto en el SO\r
>\r
> curl www.net.net > output.html\r
\r
Como hemos visto en la sintaxis, por norma general la URL debe ponerse al final del comando. Opcionalmente podemos especificar la URL en cualquier lugar del comando si usamos el modificador \`-s (--silent)\`, pudiendo as\xED alterar el orden de los argumentos de curl.\r
\r
curl -s http://www.net.net -o output.html\r
\r
En los ejemplos anteriores, el resultado que estamos obteniendo no es el deseado ya que el recurso se ha cambiado de ubicaci\xF3n o bien el sitio nos est\xE1 redirigiendo a otra URI. Si usamos el par\xE1metro \`-L (--location)\`  podemos hacer que curl siga las redirecciones y obtenga el contenido final que buscamos.\r
\r
\`\`\`bash:no-line-numbers{1,3,5}\r
$> curl http://www.dataden.tech\r
Redirecting\r
$> curl -L http://www.dataden.tech\r
<html><head><title>Loading...</title></head><body><script type='text/javascript'>window.location.replace('http://www.dataden.tech/?js=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJKb2tlbiIsImV4cCI6MTYzMzM4OTE3OSwiaWF0IjoxNjMzMzgxOTc5LCJpc3MiOiJKb2tlbiIsImpzIjoxLCJqdGkiOiIycWxmMGdkZmg2YWlzaHMxdjgwdWx0aTQiLCJuYmYiOjE2MzMzODE5NzksInRzIjoxNjMzMzgxOTc5NzgzNzQ1fQ.y5LwDoSoZCpe2tzro_FbX7cSGIw4nx1XweNBqjpLXoo&sid=da601018-2557-11ec-a001-58f389072b17');<\/script></body></html>\r
$> curl -L http://www.net.net\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        <body>\r
                <!-- Begin: Google Analytics -->\r
                <script>\r
                  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r
                  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r
                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r
                  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\r
                  ga('create', 'UA-32196-28', 'auto');\r
                  ga('send', 'pageview');\r
                <\/script>\r
                <!-- End: Google Analytics -->\r
                <center>\r
                        <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />\r
                        <font face="impact, Arial, Helvetica, sans-serif" size="14">\r
                                NET.NET\r
                        </font>\r
                        <br /><br /><br /><br />\r
                        <font face="Arial, Helvetica, sans-serif" size="1">\r
                                <a href="http://who.godaddy.com/whoischeck.aspx?domain=NET.NET" target="_blank">NET.NET</a> is the first and the best domain name on the Internet!\r
                                <br />\r
                                Coming Soon...\r
                        </font>\r
                </center>\r
        </body>\r
</html>\r
\`\`\`\r
\r
De momento s\xF3lo hemos obtenido el HTML del recurso solicitado. Si queremos ver las cabeceras HTTP de nuestra solicitud y de la respuesta recibida podemos usar el par\xE1metro \`-v (--verbose)\` que mostrar\xE1 toda la informaci\xF3n que intercambia el protocolo HTTP..\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl -v  http://www.net.net\r
*   Trying 34.250.90.28:80...\r
* TCP_NODELAY set\r
* Connected to net.net (34.250.90.28) port 80 (#0)\r
> GET / HTTP/1.1\r
> Host: net.net\r
> User-Agent: curl/7.68.0\r
> Accept: */*\r
>\r
* Mark bundle as not supporting multiuse\r
< HTTP/1.1 200 OK\r
< Cache-Control: private\r
< Content-Type: text/html\r
< Server: Microsoft-IIS/10.0\r
< Set-Cookie: ASPSESSIONIDASRSRRAR=IMFFLMBBBIFJNLNDHLOACDAI; path=/\r
< X-Powered-By: ASP.NET\r
< Date: Mon, 04 Oct 2021 21:40:49 GMT\r
< Content-Length: 1080\r
<\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        ...\r
\`\`\`\r
\r
En el ejemplo anterior podemos ver las cabeceras de nuestra solicitud (REQUEST) precedidas del caracter \`>\` mientras que las cabeceras de la respuesta (RESPONSE) se muestran precedidas dek caracter \`<\`.\r
\r
::: info formato corto y largo de los par\xE1metros\r
Como ya hemos visto, los par\xE1metros sirven para modificar el comportamiento por defecto de curl en funci\xF3n de las necesidades.\r
\r
Los par\xE1metros de una sola letra son r\xE1pidos de usar y recordar, pero tenemos un n\xFAmero limitado de par\xE1metros de este tipo por lo que no podemos tener uno para cada opci\xF3n.\r
Los par\xE1metros que usan palabras est\xE1n para solucionar la falta de opciones con formato corto. Por otro lado, su uso hace que los comandos sean m\xE1s legibles, por este motivo la mayor\xEDa de par\xE1metros cortos tienen su equivalente largo.\r
\r
En el formato corto, los par\xE1metros est\xE1n formados por un gui\xF3n seguido de la letra correspondiente a la opci\xF3n. Se puede usar un gui\xF3n para cada opci\xF3n, o incluir varias opciones detr\xE1s de un \xFAnico gui\xF3n.\r
\r
> $> curl -v -L http://example.com\r
> $> curl -vL http://example.com\r
\r
En el formato largo, los par\xE1metros se preceden de dos guiones y la palabra o palabras que forman la opci\xF3n. Tras cada doble gui\xF3n s\xF3lo se puede indicar una opci\xF3n.\r
\r
> $> curl --verbose --location http://example.com\r
\r
:::\r
\r
Por \xFAltimo, aunque ya hemos visto como obtener la informaci\xF3n de las cabeceras, podemos visualizar la informaci\xF3n de la respuesta de forma completa usando la opci\xF3n \`-i (--include)\` or obtener s\xF3lo las cabeceras de la respuesta con el uso de la opci\xF3n \`-I (--head)\`. Esto s\xF3lo afecta al informaci\xF3n de la respuesta (HTTP RESPONSE) y en el primer caso veremos  la respuesta completa (headers & data) o s\xF3lo los headers con la segunda opci\xF3n.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$>  curl -I https://jsonplaceholder.typicode.com/todos/1\r
HTTP/2 200\r
date: Mon, 04 Oct 2021 21:57:55 GMT\r
content-type: application/json; charset=utf-8\r
content-length: 83\r
x-powered-by: Express\r
x-ratelimit-limit: 1000\r
x-ratelimit-remaining: 999\r
x-ratelimit-reset: 1631546224\r
vary: Origin, Accept-Encoding\r
access-control-allow-credentials: true\r
cache-control: max-age=43200\r
pragma: no-cache\r
expires: -1\r
x-content-type-options: nosniff\r
etag: W/"53-hfEnumeNh6YirfjyjaujcOPPT+s"\r
via: 1.1 vegur\r
cf-cache-status: HIT\r
age: 10926\r
accept-ranges: bytes\r
expect-ct: max-age=604800, report-uri="https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"\r
report-to: {"endpoints":[{"url":"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=LxJlkSosQdWmBFBOx1fB6zrbjSbU0iStl7jjtlVL27CtOEPxem%2Ffl9y%2BCajMUopcZINOEsaufiU8A2glOLEmNpO5a40%2FyWb%2B4dBuspS8VGWnCRW4jxBBmh%2F3FbupAEaxy66TUPariKJLqe3PL5iq"}],"group":"cf-nel","max_age":604800}\r
nel: {"success_fraction":0,"report_to":"cf-nel","max_age":604800}\r
server: cloudflare\r
cf-ray: 6991ab2c1a5037c7-MAD\r
alt-svc: h3=":443"; ma=86400, h3-29=":443"; ma=86400, h3-28=":443"; ma=86400, h3-27=":443"; ma=86400\r
\`\`\`\r
\r
Para acabar, y como curiosidad, a\xF1adiendo la opci\xF3n \`-w "%{time_total}\\n"\` podremos ver el tiempo total que se ha tardado en recibir la respuesta del servidor.\r
\r
## 2.4.2 Puntos finales y rutas\r
\r
El t\xE9rmino t\xE9cnico \`endpoint\` hace referencia la la URL que se utiliza URL para hacer una petici\xF3n. Para un mismo servicio, esta URL suele ser siempre la misma y es una de las caracter\xEDsticas de las API REST.\r
\r
Para un API, los *puntos finales* son URLs y se describen en la documentaci\xF3n de la APU de forma que los programadores sepan c\xF3mo usarla y acceder a los recursos y servicios que proporciona.\r
\r
En el siguiente ejemplo tenemos una API con el siguiente endpoint.\r
\r
> GET https://my-api.com/Library/Books\r
\r
Esto devolver\xEDa una lista completa de los libros que hay en la biblioteca.\r
\r
Una ruta ("route") no es m\xE1s que la parte de la URL que completa al endpoint y que se utiliza para seleccionar y/o acceder a diferentes componentes del servicio o API.\r
\r
> GET https://my-api.com/Library/Books/341\r
\r
El ejemplo anterior devolver\xEDa el libro con identificador 341 de los que hay en la biblioteca.\r
\r
Como ejemplo en [SWAPI (Star Wars API)](https://swapi.dev/) el endpoint es \`https://swapi.dev/api/\`. Este es el punto de entrada para todas las peticiones.\r
\r
Adem\xE1s, hay muchas rutas dependiendo de la informaci\xF3n que queramos recuperar/a\xF1adir/modificar/borrar..\r
\r
\`\`\`java:no-line-numbers\r
$> curl https://swapi.dev/api/people/1\r
$> curl https://swapi.dev/api/planet/3\r
$> curl https://swapi.dev/api/vehicles\r
\`\`\`\r
\r
## 2.4.3 M\xE9todos HTTP y cabeceras\r
\r
Todas las peticiones HTTP tienen un m\xE9todo asociado, tambi\xE9n llamado verbo. Por defecto ya hemos visto que se usa GET, pero tambi\xE9n tenemos POST, HEAD y PUT que se utilizan bastante.\r
\r
POST es el m\xE9todo HTTP que se ide\xF3 para enviar y recibir informaci\xF3n de una aplicaci\xF3n web y es el que utilizan, entre otros, los formularios web.\r
\r
Cuando los datos de un formulario se env\xEDan desde un navegador se mandan \`URL encoded\`, como una serie de pares nombre=valor separados con s\xEDmbolos ampersand (&).\r
\r
Para enviar datos con curl lo indicamos con la opci\xF3n \`-d (--data)\` con el siguiente formato:\r
\r
> curl -d 'name=admin&shoesize=12' http://example.com/\r
\r
Curl es capaz de seleccionar el m\xE9todo HTTP que debe utilizar en funci\xF3n de las opciones que recibe. Si utilizamos \`-d\` curl har\xE1 un POST, con \`-I\` har\xE1 un HEAD, etc. Con la opci\xF3n \`-X (--request)\` podemos indicar qu\xE9 m\xE9todo queremos que use curl.\r
\r
> curl -X POST -d 'imageSize=big&imageType=jpg' http://example.org/\r
\r
Si usamos la opci\xF3n POSTing with curl's \`-d\` ya hemos visto que por defecto se hace POST. Adem\xE1s de eso, se incluye una cabecera para indicar el formato de los datos enviados \`Content-Type: application/x-www-form-urlencoded\`. Esto es lo que hace un navegador cuando enviamos un formulario.\r
\r
Puede ocurrir que los datos que estamos enviando no tengan ese formato, bien porque estemos subiendo alg\xFAn archivo, enviando informaci\xF3n binaria, usando JSON, XML, ... en estos casos podemos, a trav\xE9s de la misma cabecera Content-Type, indicar el formato de la informaci\xF3n que estamos enviando.\r
\r
Por ejemplo si queremos enviar informaci\xF3n en formato jSON:\r
\r
> curl -X "POST" -d '{"imageSize":"big","imageType":"jpg","scale":"false"}' -H 'Content-Type: application/json' https://example.com\r
\r
## 2.4.4 Authentication\r
\r
Cada solicitud HTTP puede ser autenticada. Un servidor o proxy puede necesitar que el usuario confirme su identidad o que tiene los permisos necesarios para acceder a una URL para realizar una acci\xF3n. En ese caso se le enviar\xE1 al cliente una respuesta en la que se le indique que debe proporcionar informaci\xF3n de autenticaci\xF3n en la cabecera HTTP para que se le permita completar esa solicitud.\r
\r
En curl, la forma de realizar una petici\xF3n HTTP autenticadaes con la opci\xF3n \`-u (--user)\` y proporcionando un usuario y contrase\xF1a (separados por \`:\`).\r
\r
> curl --user daniel:secret http://example.com/\r
\r
Esto har\xE1 que curl utilice el m\xE9todo de autenticaci\xF3n HTTP por defecto, denominado "Basic"\r
\r
Otras aplicaciones hacen uso de una clave secreta \`secret key\` o testigos de autorizaci\xF3n \`Authorization token\`. Esta informaci\xF3n nos la proporciona del servicio cuando lo creamos y configuramos.\r
\r
[Trello API Introduction](https://developer.atlassian.com/cloud/trello/guides/rest-api/api-introduction/)\r
\r
[Azure Translator API Reference](https://docs.microsoft.com/es-es/azure/cognitive-services/translator/reference/v3-0-translate)\r
\r
Por ejemplo, si queremos usar el servicio \`translate\` de Azure tendremos que obtener una *secret key* y utilizarla en la cabecera de cada solicitud que realicemos\r
\r
\`\`\`java:no-line-numbers\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Ocp-Apim-Subscription-Key: <here goes your susbcription key>" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
\r
Otras veces, para no enviar siempre la secret key, solicitamos una autorizaci\xF3n temporal, obteniendo un \`Authorization token\` que podemos usar para acceder al servicio durante un breve per\xEDodo de tiempo. Una vez que el token expire, debemos solicitar otro.\r
Para el env\xEDo de tokens se utiliza la cabecera \`Authorization: Bearer <token>\`.\r
\r
\`\`\`java:no-line-numbers{1,3,5}\r
$> curl -X POST "https://api.cognitive.microsoft.com/sts/v1.0/issueToken" \r
        -H "Ocp-Apim-Subscription-Key: <here goes the secret key>" -d {}\r
eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE\r
$> curl -X POST \r
"https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" \r
-H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzMwMTUxNywiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.0hyyBNr22E2sIO_ZBlTiBePXM_KE_5hQOCeHxz3US44" \r
-H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
{"error":{"code":401000,"message":"The request is not authorized because credentials are missing or invalid."}}\r
$> curl -X POST \r
"https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" \r
-H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE" \r
-H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
\r
## 2.4.5 References\r
\r
[Everything curl](https://everything.curl.dev/) es un libro gratuito que cubre con detalle pr\xE1cticamente todo lo que hay que saber sobre curl.\r
\r
[freecodecamp.org](https://www.freecodecamp.org/news/how-to-start-using-curl-and-why-a-hands-on-introduction-ea1c913caaaa/)\r
\r
[Sitio oficial de curl](https://curl.se/)\r
`]},{title:"2 Introducci\xF3n",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit2/",pathLocale:"/es/",extraFields:[`---\r
title: 2 Introducci\xF3n\r
---\r
\r
# Tema 2. Programaci\xF3n de procesos\r
\r
Una vez hemos aprendido a diferenciar entre programas, procesos e hilos, en este segundo tema vamos a aprender c\xF3mo desde un programa creado por nosotros podemos lanzar otros programas, es decir, desde un proceso en ejecuci\xF3n, podemos crear otro proceso.\r
\r
Adem\xE1s de lanzarlos, al establecerse una relaci\xF3n padre-hijo estos procesos pueden comunicarse entre s\xED intercambiando informaci\xF3n. De esta forma nuestros programas podr\xE1n lanzar otras aplicaciones, comandos del SO e incluso otras aplicaciones nuestras, permitiendo cierto grado de sincronizaci\xF3n y comunicaci\xF3n entre ellas.\r
\r
## Objetivos\r
\r
Los objetivos que alcanzaremos tras esta unidad son:\r
\r
- Conocer las clases de Java para la creaci\xF3n de procesos\r
- Monitorizar y controlar el ciclo de vida de un proceso\r
- Controlar la comunicaci\xF3n entre procesos padre/hijo\r
- Usar m\xE9todos para la sincronizaci\xF3n entre procesos y subprocesos\r
- Entender el mecanismo de comunicaci\xF3n mediante tuber\xEDas (pipes)\r
- Aprender la sintaxis y uso del comando curl para probar API REST desde un programa\r
- Crear programas que ejecuten tareas en paralelo.\r
`]},{title:"2.3 Gesti\xF3n de la E-S de un proceso",headers:[{level:2,title:"2.3.1  Redirecci\xF3n de la E/S est\xE1ndar",slug:"_2-3-1-redireccion-de-la-e-s-estandar",link:"#_2-3-1-redireccion-de-la-e-s-estandar",children:[{level:3,title:"getInputStream()",slug:"getinputstream",link:"#getinputstream",children:[]},{level:3,title:"getErrorStream()",slug:"geterrorstream",link:"#geterrorstream",children:[]},{level:3,title:"getOutputStream()",slug:"getoutputstream",link:"#getoutputstream",children:[]},{level:3,title:"Heredar la E/S del proceso padre",slug:"heredar-la-e-s-del-proceso-padre",link:"#heredar-la-e-s-del-proceso-padre",children:[]},{level:3,title:"Pipelines",slug:"pipelines",link:"#pipelines",children:[]}]},{level:2,title:"2.3.2 Redirecci\xF3n de las Entradas y Salidas Est\xE1ndar",slug:"_2-3-2-redireccion-de-las-entradas-y-salidas-estandar",link:"#_2-3-2-redireccion-de-las-entradas-y-salidas-estandar",children:[]},{level:2,title:"2.3.3 Informaci\xF3n de los procesos en Java",slug:"_2-3-3-informacion-de-los-procesos-en-java",link:"#_2-3-3-informacion-de-los-procesos-en-java",children:[]}],path:"/es/unit2/iostreams.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.3 Gesti\xF3n de la E-S de un proceso\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.3 Gesti\xF3n de la E-S de un proceso" />\r
\r
# 2.3 Gesti\xF3n de la E-S de un proceso\r
\r
[[toc]]\r
\r
## 2.3.1  Redirecci\xF3n de la E/S est\xE1ndar\r
\r
Ya hemos comentado que un subproceso no tiene terminal o consola en el que poder mostrar su informaci\xF3n. Toda la E/S por defecto ((stdin - teclado -, stdout y stderr - pantalla- ) por defecto se redirige al proceso padre. Es el proceso padre el que puede usar estos streams para recoger o enviar informaci\xF3n al proceso hijo.\r
\r
::: danger C\xF3digo del proceso hijo\r
En ning\xFAn momento, cuando estamos programando un proceso, debemos pensar si va a ser lanzado como padre o como hijo.\r
\r
Es m\xE1s, todos los programas que hacemos son lanzados como hijos por el IDE (Netbeans) y eso no hace que cambiemos nuestra forma de programarlos.\r
\r
Un proceso que vayamos a lanzar como hijo deber\xEDa funcionar perfectamente como proceso independiente y puede ser ejecutado directamente sin tener que hacerle ning\xFAn tipo de cambio.\r
:::\r
\r
Este intercambio de informaci\xF3n nos da mucha flexibilidad y proporciona una forma de control y comunicaci\xF3n sobre el proceso hijo.\r
\r
::: info La E/S en el SO y las tuber\xEDas\r
La E/S en sistemas Linux, como casi todo lo dem\xE1s, es tratada como un fichero.\r
\r
Dentro de cada proceso, cuando se accede a un fichero, se le asigna un identificador \xFAnico. Hay tres identificadores que se crean y se abren con la creaci\xF3n del proceso, y que adem\xE1s siempre tienen el mismo identificador:\r
\r
- 0: stdin\r
- 1: stdout\r
- 2: stderr\r
\r
Estos *descriptores de fichero* permiten gestionar sus streams asociados de diferentes formas. Podemos redirigir la salida de un proceso (stdout) a un archivo y seguir viendo los mensajes de error (stderr) en la consola, o bien podemos hacer que la entrada de datos a un programa se lea desde un fichero en vez del teclado, lo que permitir\xEDa automatizar pruebas, por ejemplo.\r
\r
Estos son algunos ejemplos de c\xF3mo se hacen estas redirecciones a nivel de So:\r
\r
\`\`\`bash:no-line-numbers\r
# Redirecciona la salida de ls a un archivo\r
ls > capture.txt  \r
# Redirecciona la salida de ls a la entrada de cat (doble redirecci\xF3n)\r
# Esto es una tuber\xEDa\r
ls | cat  \r
# Cambia la salida de program.sh a capture.txt y los errores a error.txt\r
./program.sh 1> capture.txt 2> error.txt \r
# Redirige la salida y los errores de program.sh al mismo archivo, capture.txt\r
./program.sh > capture.txt 2>&1\r
# Cambia la entrada de program.sh al contenido de dummy.txt\r
./program.sh < dummy.txt\r
# Redirige la salida del primer comando y la pone como entrada del segundo\r
# Esto es una tuber\xEDa\r
cat dummy.txt | ./program.sh\r
\`\`\`\r
\r
[Redirecciones E/S en Linux](https://www.digitalocean.com/community/tutorials/an-introduction-to-linux-i-o-redirection)\r
:::\r
\r
En la relaci\xF3n padre-hijo que se crea entre procesos los descriptores tambi\xE9n se redirigen desde ek hijo hacia el padre, usando 3 tuber\xEDas (pipes), una por cada stream de E/S por defecto. Esas tuber\xEDas pueden usarse de forma similar a c\xF3mo se hace en los sistemas Linux.\r
\r
![alt_text](./../../media/unit2/pipe_with_two.jpg)\r
\r
### getInputStream()\r
\r
No s\xF3lo es importante recoger el valor de retorno de un comando, sino que muchas veces nos va a ser de mucha utilidad el poder obtener la informaci\xF3n que el proceso genera por la salida est\xE1ndar o por la salida de error.\r
\r
Para esto vamos a utilizar el m\xE9todo \`public abstract InputStream getInputStream()\` de la clase \`Process\` para leer el stream de salida del proceso, es decir, para leer lo que el comando ejecutado (proceso hijo) ha enviado a la consola.\r
\r
\`\`\`java{3}\r
Process p = pbuilder.start();\r
BufferedReader processOutput = \r
    new BufferedReader(new InputStreamReader(p.getInputStream()));\r
\r
String linea;    \r
while ((linea = processOutput.readLine()) != null) {\r
    System.out.println("> " + linea);        \r
}            \r
processOutput.close();    \r
\`\`\`\r
\r
![alt_text](./../../media/unit2/Java_Stream_Readers_BufferedReaders.jpg)\r
\r
::: warning Charsets y encodings\r
Desde el inicio de la inform\xE1tica los juegos de caracteres y las codificaciones han supuesto un aut\xE9ntico quebradero de cabeza para los programadores, especialmente cuando trabajamos con juegos de caracteres no anglosajones. Pues bien, la consola de Windows no iba a ser una excepci\xF3n.\r
\r
La consola de windows, conocida como *"DOS prompt"* o *cmd*, es la forma de ejecutar programas y comandos DOS en Windows, por lo tanto esos programas mantienen la codificaci\xF3n de DOS. A Microsoft no le gustan hacer cambios que pierdan la compatibilidad hacia atr\xE1s, es decir, que sean compatibles con versiones anteriores, as\xED que cuando hagamos una aplicaci\xF3n que trabaje con la consola debemos tener en cuenta esta circunstancia.\r
\r
En Wikipedia comentan que la codificaci\xF3n  **CP850** te\xF3ricamente ha sido ampliamente reemplazada por **Windows-1252** y posteriormente Unicode, pero a\xFAn as\xED **CP850** sigue presente en la consola de comandos.\r
\r
Por lo tanto, si quetemos mostrar informaci\xF3n de la consola en nuestras aplicaciones, debemos trabajar con el charset adecuado, a saber, CP-850.\r
\r
Para usar un encoding concreto, la clase InputStreamReader, que pasa de gestionar bytes a caracteres, tiene un constructor que permite especificar el tipo de codificaci\xF3n usado en el stream de bytes que recibimos, as\xED que que debemos usar este constructor cuando trabajemos con aplicaciones de consola.\r
\r
\`\`\`java:no-line-numbers\r
new InputStreamReader(p.getInputStream(), "CP850");\r
\`\`\`\r
\r
> Adem\xE1s, para usar una codificaci\xF3n universal, podemos forzar que Netbeans, o mejor dicho la m\xE1quina virtual que usa Netbeans, utilice **por defecto el charset \`UTF-8\`**. Para hacerlo, debemos modificar el archivo de configuraci\xF3n de Netbeans \`C:/Program Files/Netbeeans-xx.x/netbeans/etc/netbeans.conf\`, y modificar la directiva \`netbeans_default_option\` a\xF1adiendo al final **-J-Dfile.encoding=UTF-8**.\r
\r
:::\r
\r
### getErrorStream()\r
\r
Curiosamente, o no tanto, adem\xE1s de la salida est\xE1ndar, tambi\xE9n podemos obtener la salida de error (stderr) que genera el proceso hijo para procesarla desde el padre.\r
\r
Si la salida de error ha sido previamente redirigida usando el m\xE9todo \`ProcessBuilder.redirectErrorStream(true)\` entonces la salida de error y la salida est\xE1ndar llegan juntas con getInputStream() y no es necesario hacer un tratamiento adicional.\r
\r
Si por el contrario queremos hacer un tratamiento diferenciado de los dos tipos de salid, podemos usar un schema similar al usado anteriormente, con la salvedad de que ahora en vez du llamar a \`getInputStream()\` lo hacemos con \`getErrorStream()\`.\r
\r
\`\`\`java{3}\r
Process p = pbuilder.start();\r
BufferedReader processError = \r
    new BufferedReader(new InputStreamReader(p.getErrorStream()));\r
// En este ejemplo, por ver una forma diferente de recoger la informaci\xF3n,\r
// en vez de leer todas las l\xEDneas que llegan, recogemos la primera l\xEDnea\r
// y suponemos que nos han enviado un entero.    \r
int value = Integer.parseInt(processError.readLine());\r
processError.close();\r
\`\`\`\r
\r
::: info Patr\xF3n de dise\xF1o Decorator o Wrapper\r
En ambos tipos de streams de entrada (input y error) estamos recogiendo la informaci\xF3n de un objeto de tipo BufferedReader. Podr\xEDamos usar directamente el InputStream que nos devuelven los m\xE9todos de Process, pero tendr\xEDamos que encargarnos nosotros de convertir los bytes a caracteres, de leer el stream caracter a caracter y de controlar el flujo al no disponer de un buffer.\r
\r
Todo esto nos lo podemos ahorrar usando clases que gestionan el flujo a un nivel de concreci\xF3n m\xE1s alto, usando sin llegar a ser conscientes otro patr\xF3n de dise\xF1o bastante com\xFAn, **Patr\xF3n de dise\xF1o Decorator** tambi\xE9n llamado **wrapper o envoltorio**.\r
\r
> Decorator es un patr\xF3n de dise\xF1o estructural que te permite a\xF1adir funcionalidades a objetos colocando estos objetos dentro de objetos encapsuladores especiales que contienen estas funcionalidades.\r
\r
[Refactoring.Guru patrones de dise\xF1o](https://refactoring.guru/design-patterns/java)\r
:::\r
\r
Vamos a ver un ejemplo completo de uso de todas las funcionalidad anteriores\r
\r
\`\`\`java{5,8,10,14,17}\r
import java.io.*;\r
public class Ejercicio2 {\r
    public static void main(String[] args) {\r
        String comando = "notepad";\r
        ProcessBuilder pbuilder = new ProcessBuilder (comando);\r
        Process p = null;\r
        try {\r
            p = pbuilder.start();\r
            // 1- Procedemos a leer lo que devuelve el proceso hijo\r
            InputStream is = p.getInputStream();\r
            // 2- Lo convertimos en un InputStreamReader\r
            // De esta forma podemos leer caracteres en vez de bytes\r
            // El InputStreamReader nos permite gestionar diferentes codificaciones\r
            InputStreamReader isr = new InputStreamReader(is);\r
            // 2- Para mejorar el rendimiento hacemos un wrapper sobre un BufferedReader\r
            // De esta forma podemos leer enteros, cadenas o incluso l\xEDneas.\r
            BufferedReader br = new BufferedReader(isr);\r
\r
            // A Continuaci\xF3n leemos todo como una cadena, l\xEDnea a l\xEDnea\r
            String linea;\r
            while ((linea = br.readLine()) != null) \r
                System.out.println(linea);\r
        } catch (Exception e) {\r
            System.out.println("Error en: "+comando);\r
            e.printStackTrace();\r
        } finally {\r
            // Para finalizar, cerramos los recursos abiertos\r
            br.close();\r
            isr.close();\r
            is.close();\r
        }    \r
    }\r
}\r
\`\`\`\r
\r
### getOutputStream()\r
\r
No s\xF3lo podemos recoger la informaci\xF3n que env\xEDa el proceso hijo sino que, adem\xE1s, tambi\xE9n podemos enviar informaci\xF3n desde el proceso padre al proceso hijo, usando el \xFAltimo de los tres streams que nos queda, el \`stdin\`.\r
\r
Igual que con las entradas que llegan desde el proceso hijo, podemos enviar la informaci\xF3n usando directamente el OutputStream del proceso, pero lo haremos de nuevo con un Decorator.\r
\r
En este caso, el *wrapper* de mayor nivel nivel para usar un OutputStream es la clase PrintWriter que nos ofrece m\xE9todos similares a los de \`System.out.printxxxxx\` para gestionar el flujo de comunicaci\xF3n con el proceso hijo.\r
\r
\`\`\`java{4}\r
PrintWriter toProcess = new PrintWriter(\r
    new BufferedWriter(\r
        new OutputStreamWriter(\r
            p.getOutputStream(), "UTF-8")), true);\r
toProcess.println("sent to child");\r
\`\`\`\r
\r
### Heredar la E/S del proceso padre\r
\r
Con el m\xE9todo \`inheritIO()\` podemos redireccionar todos los flujos de E/S del proceso hijo a la E/S est\xE1ndar del proceso padre.\r
\r
\`\`\`java{3}\r
ProcessBuilder processBuilder = new ProcessBuilder("/bin/sh", "-c", "echo hello");\r
\r
processBuilder.inheritIO();\r
Process process = processBuilder.start();\r
\r
int exitCode = process.waitFor();\r
\`\`\`\r
\r
En el ejemplo anterior, tras invocar al m\xE9todo inheritIO() podemos ver la salida del comando ejecutado en la consola del proceso padre dentro del IDE Netbeans.\r
\r
### Pipelines\r
\r
Java 9 introdujo el concepto de \`pipelines\` en el API de ProcessBuilder:\r
\r
\`\`\`java:no-line-numbers\r
public static List<Process> startPipeline\u200B(List<ProcessBuilder> builders)\r
\`\`\`\r
\r
El m\xE9todo \`startPipeline\` usa un lista de objetos ProcessBuilder. Este m\xE9todo est\xE1tico se encarga de lanzar un proceso para cada uno de los ProcessBuilder recibidos. Y lo que automatiza es la creaci\xF3n de tuber\xEDas encadenadas (pipeline) haciendo que la salida de cada proceso est\xE9 enlazada con la entrada del siguiente..\r
\r
Por ejemplo, si queremos realizar este tipo de operaciones tan comunes en shellscript:\r
\r
> find . -name *.java -type f | wc -l\r
\r
Lo que haremos ser\xE1 crear un ProcessBuilder para cada uno de los comandos, y  pas\xE1rselos todos al m\xE9todo startPipeline para que los ejecute y los encadene.\r
\r
\`\`\`java\r
List builders = Arrays.asList(\r
    new ProcessBuilder("find", "src", "-name", "*.java", "-type", "f"), \r
    new ProcessBuilder("wc", "-l"));\r
\r
List processes = ProcessBuilder.startPipeline(builders);\r
Process last = processes.get(processes.size() - 1);\r
\r
// Desde el proceso padre podemos recoger la salida del \xFAltimo proceso para \r
// el resultado final del pipeline\r
\`\`\`\r
\r
El ejemplo anterior busca todos los archivos .java  dentro del directorio src, encadena la salida hacia el comando wc para contar cuantos ficheros ha encontrado, siendo este el resultado final del pipeline.\r
\r
## 2.3.2 Redirecci\xF3n de las Entradas y Salidas Est\xE1ndar\r
\r
En un sistema real, probablemente necesitemos guardar los resultados de un proceso en un archivo de log o de errores para su posterior an\xE1lisis. Afortunadamente lo podemos hacer sin modificar el c\xF3digo de nuestras aplicaciones usando los m\xE9todos que proporciona el API de ProcessBuilder para hacer exactamente eso.\r
\r
Por defecto, tal y como ya hemos visto, los procesos hijos reciben la entrada a trav\xE9s de una tuber\xEDa a la que podemos acceder usando el OutputStream que nos devuelve \`Process.getOutputStream()\`.\r
\r
Sin embargo, tal y como veremos a continuaci\xF3n, esa entrada est\xE1ndar se puede cambiar y redirigirse a otros destinos como un fichero usando el m\xE9todo \`redirectOutput(File)\`. Si modificamos la salida est\xE1ndar, el m\xE9todo getOutputStream() devolver\xE1 *ProcessBuilder.NullOutputStream*.\r
\r
::: info Redirecci\xF3n antes de ejecutar\r
Es importante fijarse en qu\xE9 momento se realiza cada acci\xF3n sobre un proceso.\r
\r
Antes hemos visto que los flujos de E/S se consultan y gestionan una vez que el proceso est\xE1 en ejecuci\xF3n, por lo tanto los m\xE9otodos que nos dan acceso a esos *streams* son m\xE9todos de la clase \`Process\`.\r
\r
Si lo que queremos es redirigir la E/S, como vamos a ver a continuaci\xF3n, lo haremos mientras preparamos el proceso para ser ejecutado. De forma que cuando se lance sus streams de E/S se modifiquen. Por eso en esta ocasi\xF3n los m\xE9todos que nos permiten redireccionar la E/S de los procesos son m\xE9todos de la clase \`ProcessBuilder\`.\r
::::\r
\r
Vamos a ver con un ejemplo c\xF3mo hacer un programa que muestre la versi\xF3n de Java. Ahora bien, en esta ocasi\xF3n la salida se va a guardar en un archivo de log en vez de enviarla al padre por la tuber\xEDa de salida est\xE1ndar:\r
\r
\`\`\`java{7}\r
ProcessBuilder processBuilder = new ProcessBuilder("java", "-version");\r
\r
// La salida de error se enviar\xE1 al mismo sitio que la est\xE1ndar\r
processBuilder.redirectErrorStream(true);\r
\r
File log = folder.newFile("java-version.log");\r
processBuilder.redirectOutput(log);\r
\r
Process process = processBuilder.start();\r
\`\`\`\r
\r
En el ejemplo anterior podemos observar como se crea un archivo temporal llamado *java-version.log* e indicamos a ProcessBuilder que la salida la redirija a este archivo.\r
\r
Es lo mismo que si llam\xE1semos a nuestra aplicacion usando el operador de redirecci\xF3n de salida:\r
\r
> java ejemplo-java-version > java-version.log\r
\r
Ahora vamos a fijarnos en una variaci\xF3n del ejemplo anterior. Lo que queremos hacer ahora es a\xF1adir (\`append to\`) informaci\xF3n al archivo de log file en vez de sobreescribir el archivo cada vez que se ejecuta el proceso. Con sobreeescribir nos referimos a crear el archivo vac\xEDo si no existe, o bien borrar el contenido del archivo si \xE9ste ya existe.\r
\r
\`\`\`java{3}\r
File log = tempFolder.newFile("java-version-append.log");\r
processBuilder.redirectErrorStream(true);\r
processBuilder.redirectOutput(Redirect.appendTo(log));\r
\`\`\`\r
\r
Otra vez m\xE1s, es importante hacer notar la llamada a  \`redirectErrorStream(true)\`. En el caso de que se produzca alg\xFAn error, se mezclar\xE1n con los mensajes de salida en el fichero..\r
\r
En el APi de ProcessBuilder encontramos m\xE9todos para redireccionar tambi\xE9n la salida de error est\xE1ndar y la entrada est\xE1ndar de los procesos.\r
\r
- redirectError(File)\r
- redirectInput(File)\r
\r
Para hacer las redirecciones tambi\xE9n podemos utilizar la clase \`ProcessBuilder.Redirect\` como par\xE1metro para los m\xE9todos anteriores, utilizando uno de los siguientes valores\r
\r
| Valor                   | Significado                                                              |\r
| ----------------------- | ------------------------------------------------------------------------ |\r
| Redirect.DISCARD        | La informaci\xF3n se descarta                                               |\r
| Redirect.to(File)       | La informaci\xF3n se guardar\xE1 en el fichero indicado. Si existe, se vac\xEDa.  |\r
| Redirect.from(File)     | La informaci\xF3n se leer\xE1 del fichero indicado                             |\r
| Redirect.appendTo(File) | La informaci\xF3n se a\xF1adir\xE1 en el fichero indicado. Si existe, no se vac\xEDa |\r
\r
## 2.3.3 Informaci\xF3n de los procesos en Java\r
\r
Una vez que un proceso est\xE1 en ejecuci\xF3n podemos obtener informaci\xF3n acerca de ese proceso usando los m\xE9todos de la clase \`java.lang.ProcessHandle.Info\`:\r
\r
- el comando usado para lanzar el proceso\r
- Los argumentos/par\xE1metros que recibi\xF3 el proceso\r
- El instante de tiempo en el que se inici\xF3 el proceso\r
- El tiempo de CPU que ha usado el proceso y el usuario que lo ha lanzado\r
\r
Aqu\xED tenemos un sencillo ejemplo de c\xF3mo hacerlo\r
\r
\`\`\`java{1-2}\r
ProcessHandle processHandle = ProcessHandle.current();\r
ProcessHandle.Info processInfo = processHandle.info();\r
\r
System.out.println("PID: " + processHandle.pid());\r
System.out.println("Arguments: " + processInfo.arguments());\r
System.out.println("Command: " + processInfo.command());\r
System.out.println("Instant: " + processInfo.startInstant());\r
System.out.println("Total CPU duration: " + processInfo.totalCpuDuration());\r
System.out.println("User: " + processInfo.user());\r
\`\`\`\r
\r
En el ejemplo anterior hemos obtenido la informaci\xF3n del proceso actual (\`ProcessHandle.current()\`), as\xED que si estamos en el proceso padre, s\xF3lo podemos mostrar su informaci\xF3n, pero no la de su hijo.\r
\r
Tambi\xE9n es posible acceder a la informaci\xF3n de un proceso lanzado (proceso hijo). En este caso necesitamos la instancia de \`java.lang.Process\` para llamar a su m\xE9todo \`toHandle()\` y obtener la instancia de  \`java.lang.ProcessHandle\` del proceso hijo..\r
\r
\`\`\`java{2-3}\r
Process process = processBuilder.inheritIO().start();\r
ProcessHandle childProcessHandle = process.toHandle();\r
ProcessHandle.Info child processInfo = processHandle.info();\r
\`\`\`\r
\r
A partir de ah\xED, el c\xF3digo para acceder a la informaci\xF3n y detalles del proceso hijo es id\xE9ntico al ejemplo anterior.\r
`]},{title:"2.2 Gesti\xF3n de procesos en Java - ProcessBuilder y Process",headers:[{level:2,title:"2.2.1 Preparaci\xF3n y configuraci\xF3n de un proceso",slug:"_2-2-1-preparacion-y-configuracion-de-un-proceso",link:"#_2-2-1-preparacion-y-configuracion-de-un-proceso",children:[{level:3,title:"Modificar el comando en tiempo de ejecuci\xF3n",slug:"modificar-el-comando-en-tiempo-de-ejecucion",link:"#modificar-el-comando-en-tiempo-de-ejecucion",children:[]},{level:3,title:"Configuraciones adicionales de un proceso",slug:"configuraciones-adicionales-de-un-proceso",link:"#configuraciones-adicionales-de-un-proceso",children:[]}]},{level:2,title:"2.2.2 Acceso al proceso una vez en ejecuci\xF3n",slug:"_2-2-2-acceso-al-proceso-una-vez-en-ejecucion",link:"#_2-2-2-acceso-al-proceso-una-vez-en-ejecucion",children:[{level:3,title:"Lanzar una clase Java como proceso desde otra clase java en el mismo proyecto",slug:"lanzar-una-clase-java-como-proceso-desde-otra-clase-java-en-el-mismo-proyecto",link:"#lanzar-una-clase-java-como-proceso-desde-otra-clase-java-en-el-mismo-proyecto",children:[]}]}],path:"/es/unit2/processbuilder.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.2 Gesti\xF3n de procesos en Java - ProcessBuilder y Process\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="2.2 Gesti\xF3n de procesos en Java - ProcessBuilder y Process" />\r
\r
# 2.2 Gesti\xF3n de procesos en Java - ProcessBuilder y Process\r
\r
[[toc]]\r
\r
## 2.2.1 Preparaci\xF3n y configuraci\xF3n de un proceso\r
\r
En el paquete \`java.lang\` tenemos dos clases para la gesti\xF3n de procesos.\r
\r
* \`java.lang.ProcessBuilder\` [Referencia API Java](https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html)\r
* \`java.lang.Process\` [Referencia API Java](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ProcessBuilder.html)\r
\r
Las instancias de **ProcessBuilder** gestionan los atributos de los procesos, mientras que las instancias de **Process** controlan la ejecuci\xF3n de esos mismos procesos cuando se ejecutan.\r
\r
Antes de ejecutar un nuevo proceso, podemos configurar los par\xE1metros de ejecuci\xF3n del mismo usando la clase \`ProcessBuilder\`.\r
\r
ProcessBuilder es una clase auxiliar de la clase Process, que veremos m\xE1s adelante, y se utiliza para controlar algunos par\xE1metros de ejecuci\xF3n que afectar\xE1n al proceso. A trav\xE9s de la llamada al m\xE9todo \`start\` se crea un nuevo proceso en el sistema con los atributos definidos en la instancia de ProcessBuilder.\r
\r
\`\`\`java\r
    ProcessBuilder pb = new ProcessBuilder("CMD", "/C", "DIR");\r
    Process p = pb.start();\r
\`\`\`\r
\r
Si llamamos varias veces al m\xE9todo start, se crear\xE1n tantos nuevos procesos como llamadas hagamos, todos ellos con los mismos atributos.\r
\r
La clase ProcessBuilder define un par de constructores:\r
\r
\`\`\`java:no-line-numbers\r
ProcessBuilder(List<String> command)\r
ProcessBuilder(String... command)\r
\`\`\`\r
\r
El funcionamiento de ambos es el mismo. En el primer constructor se pasa el comando a ejecutar y la lista de argumentos como una lista de cadenas. Por contra, en el segundo constructor, el comando y sus argumentos se pasan a trav\xE9s de un n\xFAmero variable de cadenas (String ... es lo que en Java se llama varargs). La versi\xF3n que utilicemos depende del formato en que tengamos los datos.\r
\r
::: danger Argumentos y par\xE1metros\r
Si queremos lanzar un programa con par\xE1metros (modificadores que hacen que cambie la forma de funcionar un programa como -h /s ...) el comando no puede ser pasado al constructor directamente como un \xFAnico string, debe ser preprocesado para convertirlo en una lista y que funcione.\r
\r
\`\`\`java\r
// Formas diferentes de pasar el comando a los constructores de ProcessBuilder\r
// 1\xAA forma: usando una cadena. Falla con par\xE1metros\r
// S\xF3lo funciona con programas que tengan argumentos\r
String command1 = "notepad.exe prueba1.txt"\r
ProcessBuilder pb = new ProcessBuilder(command1);\r
\r
// 2\xAA forma: usando un array de cadenas. Funciona con par\xE1metros\r
String[] command2 = {"cmd", "/c", "dir", "/o"};\r
ProcessBuilder pb = new ProcessBuilder(command2);\r
\r
// 3\xAA forma: usando una cadena y dividi\xE9ndola para convertirla en una lista\r
String command3 =  "c:/windows/system32/shutdown -s -t 0";  \r
// La expresi\xF3n regular \\s significa partir por los espacios en blanco\r
ProcessBuilder pb = new ProcessBuilder(command3.split("\\\\s"));\r
// ESTA ES LA MEJOR FORMA PARA QUE FUNCIONE EN TODOS LOS CASOS\r
\`\`\`\r
\r
:::\r
\r
::: warning Apagar el sistema operativo\r
El comando \`shutdown -s\` sirve para apagar el sistema. En windows es necesario proporcionar la ruta completa al comando, por ejemplo C:\\Windows\\System32\\shutdown.\r
\r
Podemos usar como par\xE1metro -s para apagar el sistema, , -r para reiniciar , -h para hibernar y -t para indicar un tiempo de espera antes de apagar.\r
\r
[Referencia del comando shutdown de Windows](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/shutdown)\r
:::\r
\r
::: question Activity psp.activities.U2A1_Shutdowner\r
Crea una nuevo proyecto Java (package psp.actividades y como clase principal U2A1_Shutdowner). \r
Usando la l\xEDnea de comandos, pide al usuario qu\xE9 acci\xF3n quiere realizar (apagar, reiniciar o suspender) y cu\xE1nto tiempo quiere dejar antes de realizar la acci\xF3n de apagado del sistema..\r
\r
Busca informaci\xF3n sobre el funcionamiento del comando shutdown en GNU/Linux y haz que tu aplicaci\xF3n funcione para ambos sistemas..\r
\r
La aplicaci\xF3n tiene que preparar el comando correcto para la selecci\xF3n que haya hecho el usuario y para el sistema operativo en el que la est\xE9 ejecutando.\r
\r
Muestra por consola el resultado del m\xE9todo ProcessBuilder.command() de forma legible.\r
:::\r
\r
:::details Soluci\xF3n de U2A1_Shutdowner\r
\r
\`\`\`java\r
public class U2A1_Shutdowner {\r
\r
    public static void main(String[] args) throws IOException {\r
        // Ask for the required information to prepare the command\r
        Scanner keyboard = new Scanner(System.in);\r
        \r
        System.out.print("Select your option (s-shutdown / r-reboot / h-hibernate): ");\r
        String shutdownOption = keyboard.nextLine();        \r
        \r
        System.out.print("How much seconds will the command wait to be run? (0 means immediately): ");\r
        String shutdownTime = keyboard.nextLine();        \r
        \r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "C:/Windows/System32/shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        } else {\r
            command = "shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        }\r
        \r
        // Prepare the process and launch it\r
        ProcessBuilder shutdowner = new ProcessBuilder(command.split("\\\\s"));\r
        //shutdowner.start();\r
        \r
        // Show the command to be run\r
        System.out.print("El comando a ejecutar es:  ");\r
        for (String commandPart: shutdowner.command()) {\r
            System.out.print(commandPart + " ");\r
        }\r
        System.out.println("");\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
### Modificar el comando en tiempo de ejecuci\xF3n\r
\r
Puede ser que todo el comando, o parte del mismo, no lo tengamos en el momento de llamar a los constructores de ProcessBuilder. Se puede cambiar, modificar y consultar a posteriori con el m\xE9todo \`command\`\r
\r
Al igual que con los constructores, tenemos dos versiones del m\xE9todo command\r
\r
\`\`\`java:no-line-numbers\r
    command(List<String> command)\r
    command(String... command)\r
\`\`\`\r
\r
y la tercera forma de este m\xE9todo (sin par\xE1metros) sirve para obtener una lista del comando pasado al constructor o puesto con alguna de las formas anterior del m\xE9todo command. Lo interesante es que una vez que tenemos la lista, podemos modificarla usando los m\xE9todos de la clase List.\r
\r
En el siguiente ejemplo, en el momento de definir el comando, nos falta saber la \xFAltima parte, el directorio temporal. Adem\xE1s, si queremos hacer que la ejecuci\xF3n sea multiplataforma, el shell a ejecutar tampoco lo sabemos.\r
Dependiendo del SO se a\xF1aden dos valores al principio y un valor al final, con el m\xE9todo add de la clase List.\r
\r
\`\`\`java\r
// Sets and modifies the command after ProcessBuilder object is created\r
String command = "java -jar install.jar -install"; // tmp dir is missing\r
ProcessBuilder pbuilder = new ProcessBuilder(command.split("\\\\s"));\r
if (isWindows) {\r
    pbuilder.command().add(0, "cmd"); // Sets the 1st element\r
    pbuilder.command().add(1, "/c"); // Sets the 2nd element\r
    pbuilder.command().add("c:/temp"); // Sets the last element\r
    // Command to run cmd /c java -jar install.jar -install c:/temp\r
} else {\r
    pbuilder.command().add(0, "sh"); // Sets the 1st element\r
    pbuilder.command().add(1, "-c"); // Sets the 2nd element\r
    pbuilder.command().add("/tmp"); // Sets the last element\r
    // Command to run: sh -c java -jar install.jar -install /tmp\r
}\r
\r
// Starts the process\r
pbuilder.start();\r
\`\`\`\r
\r
### Configuraciones adicionales de un proceso\r
\r
Algunos de los atributos que podemos configurar para un proceso son:\r
\r
* Establecer el directorio de trabajo donde el proceso se ejecutar\xE1\r
  \r
  Podemos cambiar el directorio de trabajo por defecto llamando al m\xE9todo \`directory\` y pas\xE1ndole un objeto de tipo File. **Por defecto, el directorio de trabajo se establece al valor de la variable del sistema user.dir**. Este directorio es el punto de partida para acceder a ficheros, im\xE1genes y todos los recursos que necesite nuestra aplicaci\xF3n.\r
\r
    \`\`\`java\r
    // Cambia el directorio de trabajo a la carpeta personal del usuario\r
    pbuilder.directory(new File(System.getProperty("user.home")));\r
    \`\`\`\r
\r
* Configurar o modificar variables de entorno para el proceso con el m\xE9todo \`environment()\`\r
\r
    \`\`\`java\r
    // Retrieve and modify the process environment\r
    Map<String, String> environment = pbuilder.environment();\r
    // Get the PATH environment variable and add a new directory\r
    String systemPath = environment.get("path") + ";c:/users/public";\r
    environment.replace("path", systemPath);\r
    // Add a new environment variable and use it as a part of the command\r
    environment.put("GREETING", "Hola Mundo");\r
    processBuilder.command("/bin/bash", "-c", "echo $GREETING");\r
    \`\`\`\r
\r
    \`\`\`java\r
    // Indicamos el directorio donde se encuentra el ejecutable\r
    File directorio = new File ("bin");\r
    pb.directory(directorio);\r
\r
    // Mostramos la informaci\xF3n de las variables de entorno\r
    Map variablesEntorno = pb.environment();\r
    System.out.println(variablesEntorno);\r
\r
    // Mostramos el nombre del proceso y sus argumentos\r
    List command = pb.command();\r
    Iterator iter = l.iterator();\r
    while (iter.hasNext()) {\r
        System.out.println(iter.next());\r
    }\r
    \`\`\`\r
\r
    ::: info Variables de entorno vs Propiedades del sistema\r
    Con la clase Runtime accedemos a las variables del sistema mientras que con ProcessBuilder lo hacemos a las propiedades del sistema, que son diferentes.\r
    :::\r
\r
* Redireccionar la entrada y salida est\xE1ndar\r
* Heredar la E/S est\xE1ndar del proceso padre usando el m\xE9todo ProcessBuilder.inheritIO()\r
  \r
  *Estas dos configuraciones se ver\xE1n en el siguiente apartado.*\r
\r
::: question Actividad psp.activities.U2A2_DirectorioTrabajo\r
Crea un nuevo proyecto Java (Ant > Java Application) (configura como nombre del proyecto U2A2_DirectorioTrabajo y como clase principal psp.activities.U2A2_WorkingDirectory)\r
Escribe un programa que ejecute el comando ls o dir.\r
Modifica el valor de la propiedad user.dir.\r
En la misma aplicaci\xF3n, cambiar el directorio de trabajo a la carpeta c:/temp o /tmp, dependiendo del sistema operativo.\r
\r
Muestra el valor devuelto por el m\xE9todo directory()\r
\r
* Despu\xE9s de crear la instancia de ProcessBuilder\r
* Despu\xE9s de cambiar el valor de user.dir\r
* Despu\xE9s de cambiar el directorio de trabajo al directorio temporal del sistema.\r
\r
*En este momento tu programa todav\xEDa no mostrar\xE1 ning\xFAn listado.*\r
:::\r
\r
::: details Soluci\xF3n de U2A2_DirectorioTrabajo\r
\r
\`\`\`java\r
public class U2A2_WorkingDirectory {\r
\r
    public static void main(String[] args) throws IOException {\r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "cmd /c dir";\r
        } else {\r
            command = "sh -c ls";\r
        }\r
        \r
        // Prepare the process and launch it\r
        ProcessBuilder commander = new ProcessBuilder(command.split("\\\\s"));\r
        \r
        //1st - Default working directory\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        //2nd - Set the user.dir\r
        System.setProperty("user.dir", System.getProperty("user.home"));\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        // 3rd - Change the working directory\r
        commander.directory(new File(System.getProperty("user.home")));\r
        System.out.println("Working directory: " + commander.directory().toString());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        commander.start();        \r
    }\r
}\r
\`\`\`\r
\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.2 Acceso al proceso una vez en ejecuci\xF3n\r
\r
LA clase \`Process\` es una clase abstracta definida en el paquete java.lang y contiene la informaci\xF3n del proceso en ejecuci\xF3n. Tras invocar al m\xE9todo \`start\` de ProcessBuilder, \xE9ste devuelve una referencia al proceso en forma de objeto Process.\r
\r
Los m\xE9todos de la clase Process pueden ser usados para realizar operaciones de E/S desde el proceso, para comprobar su estado, su valor de retorno, para esperar a que termine de ejecutarse y para forzar la terminaci\xF3n del proceso. Sin embargo estos m\xE9todos no funcionan sobre procesos especiales del SO como pueden ser servicios, shell scripts, demonios, etc.\r
\r
> [Especificaci\xF3n java.lang.Process](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Process.html)\r
\r
::: warning Entrada / Salida desde el proceso hijo\r
Curiosamente  **los procesos lanzados con el m\xE9todo start() no tienen una consola asignada.**. Por contra, estos procesos redireccionan los streams de E/S est\xE1ndar (stdin, stdout, stderr) al proceso padre. Si se necesita, se puede acceder a ellos a trav\xE9s de los streams obtenidos con los m\xE9todos definidos en la clase Process como getInputStream(), getOutputStream() y  getErrorSteam(). Esta es la forma de enviar y recibir informaci\xF3n desde los subprocesos.\r
:::\r
\r
Los principales m\xE9todos de esta clase son:\r
\r
| M\xE9todo                                       | Descripci\xF3n                                                                                                                                                                                                                                                                                                      |\r
| :------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| int exitValue()                              | C\xF3digo de finalizaci\xF3n devuelto por el proceso hijo (ver Info m\xE1s abajo)                                                                                                                                                                                                                                         |\r
| Boolean isAlive()                            | Comprueba si el proceso todav\xEDa est\xE1 en ejecuci\xF3n                                                                                                                                                                                                                                                                |\r
| int waitFor()                                | hace que el proceso padre se quede esperando a que el proceso hijo termine. El entrono que devuelve es el c\xF3digo de finalizaci\xF3n del proceso hijo                                                                                                                                                                |\r
| Boolean waitFor(long timeOut, TimeUnit unit) | El funcionamiento es el mismo que en el caos anterior s\xF3lo que en esta ocasi\xF3n podemos especificar cu\xE1nto tiempo queremos esperar a que el proceso hijo termine. El m\xE9todo devuelve true si el proceso termina antes de que pase el tiempo indicado y false si ha pasado el tiempo y el proceso no ha terminado. |\r
| void destroy()                               | Estos dos m\xE9todos se utilizan para matar al proceso. El segundo lo hace de forma forzosa.                                                                                                                                                                                                                        |\r
| Process destroyForcibly()                    |\r
\r
 Veamos un sencillo ejemplo. Una vez lanzado el programa espera durante 10 segundos y a continuaci\xF3n mata el proceso.\r
\r
\`\`\`java\r
public class ProcessDemo {\r
\r
   public static void main(String[] args) throws Exception {\r
\r
      ProcessBuilder pb = new ProcessBuilder("C:\\Program Files\\Mozilla Firefox\\firefox.exe");\r
      // Effectively launch the process\r
      Process p = pb.start();\r
      // Check is process is alive or not\r
      boolean alive = p.isAlive();\r
      // Wait for the process to end for 10 seconds.\r
      if (p.waitFor(10, TimeUnit.SECONDS)) {\r
          System.out.println("Process has finished");\r
      } else {\r
          System.out.println("Timeout. Process hasn't finished");\r
      }\r
      // Force process termination.\r
      p.destroy();\r
      // Check again if process remains alive\r
      boolean alive = p.isAlive();\r
      // Get the process exit value\r
      int status = p.exitValue();        \r
   }\r
}\r
\`\`\`\r
\r
::: info C\xF3digos de terminaci\xF3n\r
Un c\xF3digo de salida (exit code o a veces tambi\xE9n return code) es el valor que un proceso le devuelve a su proceso padre para indicarle c\xF3mo ha acabado. Si un proceso acaba con un valor de finalizaci\xF3n 0 es que todo ha ido bien, cualquier otro valor entre 1 to 255 indica alguna causa de error.\r
:::\r
\r
::: question Actividad psp.activities.U2A3_ExitValue\r
Crea un nuevo proyecto Java (Ant > Java Application) (configura como nombre del proyecto U2A3_ExitValue y como clase principal psp.activities.U2A3_ExitValue).\r
Prepara un programa que ejecute varios comandos (notepad, calc, comandos shell) uno detr\xE1s de otro, de forma secuencial y haz que tu programa obtenga el c\xF3digo de finalizaci\xF3n de cada uno de ellos.\r
Para cada programa imprime el nombre y su c\xF3digo de finalizaci\xF3n.\r
\r
Prueba a poner aplicaciones que no existan o comandos con par\xE1metros incorrectos.\r
\r
\xBFQu\xE9 hace Netbeans si pones System.exit(10) para acabar tu programa?. F\xEDjate en la consola.\r
\xBFQu\xE9 hace Netbeans si pones System.exit(0) para acabar tu programa.?\r
Cu\xE1l es entonces el valor por defecto?\r
:::\r
\r
::: details Soluci\xF3n de U2A3_ExitValue\r
\r
\`\`\`java\r
public class U2A3_ExitValue {\r
\r
    public static void main(String[] args) {\r
        do {\r
            // C\xF3digo para pedir un programa/comando a ejecutar\r
            Scanner teclado = new Scanner(System.in);\r
            System.out.println("Introduce el programa / comando que quieres ejecutar (intro para acabar): ");\r
            String comando = teclado.nextLine();\r
            \r
            if (comando.equals("")) System.exit(0);\r
\r
            try {\r
                // Preparamos el entrono de ejecuci\xF3n del proceso\r
                // Como no sabemos el contenido del comando, forzamos su conversi\xF3n\r
                // a una lista para que no haya problemas con su ejecuci\xF3n\r
                ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
\r
                // Lanzamos el proceso hijo\r
                Process p = pb.start();          \r
\r
                // Esperamos a que acabe para recoger el valor de salida\r
                int exitValue = p.waitFor();\r
\r
                if (exitValue == 0) {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
                } else {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. C\xF3digo (" + exitValue + ")");\r
                }\r
\r
            } catch (InterruptedException | IOException ex) {\r
                System.err.println(ex.getLocalizedMessage());\r
                ex.printStackTrace();\r
            }                       \r
        } while (true);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
\r
::: danger Gesti\xF3n de excepciones\r
La llamada al m\xE9todo **waitFor** hace que el proceso padre se bloquee hasta que el proceso hijo termina o bien hasta que el bloqueo es interrumpido por alguna se\xF1al del sistema (Excepci\xF3n) que recibe el proceso padre.\r
\r
Es mejor gestionar las excepciones lo m\xE1s cerca posible del origen en vez de pasarlas a niveles superiores.\r
:::\r
\r
### Lanzar una clase Java como proceso desde otra clase java en el mismo proyecto\r
\r
Para las actividades os pedir\xE9 que program\xE9is tanto el proceso padre como el proceso hijo. Para hacer eso, una de las clases tendr\xE1 que lanzar a la otra.\r
\r
Para hacer esto, ambas clases deben tener un m\xE9todo main. As\xED que en las propiedades del proyecto Netbeans deberemos seleccionar cu\xE1l de las clases se ejecutar\xE1 primero, normalmente la clase \`Lanzador o Launcher\` (proceso padre).\r
\r
![Seleccionar clase principal](../../media/unit2/seleccionmain.png)\r
\r
Antes de que una clase pueda lanzar a otra, al menos la segunda (proceso hijo) debe estar compilada, es decir, el archivo .class debe haberse creado dentro del directorio build/classes.\r
\r
![Seleccionar directorio de trabajo ](../../media/unit2/comandotree.png)\r
\r
Entonces y s\xF3lo entonces, previa configuraci\xF3n de los par\xE1metros de ejecuci\xF3n del proceso tal y como se muestra en el ejemplo, se podr\xE1 ejecutar una clase desde otra.\r
\r
::: info Directorio de trabajo\r
\r
Si nos fijamos en la estructura de directorios de un proyecto y entendemos c\xF3mo se invocan unas clases a otras, entenderemos porqu\xE9 el directorio de trabajo debe ser *build/classes*.\r
\r
En Java, cuando se ejecuta una clase \`java paquete.clase\`, la MV Java espera encontrar los directorios que forman el paquete (psp/u2/actividad10) a partir del punto donde se est\xE1 invocando el comando. Por eso, para que pueda encontrar la clase (el archivo .class), debemos ubicarnos previamente en el directorio \`build/classes\`\r
\`\`\`java\r
// Prepare the environment and the command\r
ProcessBuilder pb = new ProcessBuilder("java", "psp.u2.actividad10.Sumador");\r
pb.directory(new File("build/classes"));\r
Process p = pb.start();\r
\`\`\`\r
\r
:::\r
\r
::: question Actividad psp.activities.U2A4_Lanzador\r
Crea un nuevo proyecto Java (Ant > Java Application) (configura como nombre del proyecto U2A3_Lanzador y como clase principal psp.activities.U2A4_Lanzador).\r
\r
Ahora, en el mismo proyecto y dentro del mismo paquete crea otra clase, Lanzado, con un m\xE9todo main que recibir\xE1 el nombre del programa que debe ejecutar como par\xE1metro del m\xE9todo main(args). Haz que esta aplicaci\xF3n cree un nuevo proceso para ejecutar el programa recibido como par\xE1metro.\r
\r
La clase terminar\xE1 devolviendo como c\xF3digo de finalizaci\xF3n el que el programa lanzado le haya devuelto a ella.\r
\r
> M\xE9todo System.exit()\r
>\r
> * Cero. El c\xF3digo cero debe devolverse cuando la ejecuci\xF3n del proceso haya ido bien, esto es, que ha terminado su ejecuci\xF3n sin problemas.\r
> * Distinto de cero. AUn c\xF3digo distinto de cero indica una terminaci\xF3n con errores. Java nos permite usar c\xF3digos diferentes para los diferentes tipos de error.\r
\r
Por \xFAltimo, podemos hacer que U2A4_Lanzador pregunte al usuario qu\xE9 aplicaci\xF3n quiere ejecutar y pas\xE1rsela a la clase U2A4_Mandado.\r
\r
En Lanzador recoge el c\xF3digo de finalizaci\xF3n de Mandado y muestra un mensaje indicando si el proceso termin\xF3 bien o con errores.\r
:::\r
\r
::: details Soluci\xF3n de U2A4_Lanzador\r
\r
\`\`\`java\r
public class U2A4_Launcher {\r
\r
    public static void main(String[] args) {\r
\r
        // C\xF3digo para pedir un programa/comando a ejecutar\r
        Scanner teclado = new Scanner(System.in);\r
        System.out.println("Introduce el programa / comando que quieres ejecutar: ");\r
        String comando = teclado.nextLine();\r
\r
        try {\r
            // Preparamos el entrono de ejecuci\xF3n del proceso\r
            // Como no sabemos el contenido del comando, forzamos su conversi\xF3n\r
            // a una lista para que no haya problemas con su ejecuci\xF3n\r
            comando = "java psp.activities.U2A4_Commander " + comando;\r
            ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
            pb.directory(new File("build/classes"));\r
\r
            // Lanzamos el proceso hijo\r
            Process p = pb.start();          \r
\r
            // Esperamos a que acabe para recoger el valor de salida\r
            int exitValue = p.waitFor();\r
\r
            if (exitValue == 0) {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
            } else {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. C\xF3digo (" + exitValue + ")");                \r
            }\r
        } catch (InterruptedException | IOException ex) {\r
            System.err.println(ex.getLocalizedMessage());\r
            ex.printStackTrace();\r
        }                       \r
    }\r
}\r
\r
public class U2A4_Commander {\r
\r
    public static void main(String[] args) throws Exception {       \r
        // Lectura de informaci\xF3n desde los par\xE1metros de entrada \r
        // Se supone que recibimos: args[0] args[1] args[2] ..... args[args.length-1 --> comando a ejecutar\r
        String comando = "";\r
        for (int i = 0; i < args.length; i++) {\r
            comando += args[i] + " ";\r
        }\r
        comando.trim();\r
                \r
        ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));            \r
\r
        // Lanzamos el proceso hijo\r
        Process p = pb.start();          \r
\r
        // Esperamos a que acabe para recoger el valor de salida\r
        int exitValue = p.waitFor();\r
\r
        System.exit(exitValue);\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
::: warning Programaci\xF3n de clases "hijas"\r
Debemos tener en cuenta que una clase se puede ejecutar de forma independiente o puede ser llamada desde otro proceso.\r
\r
Por eso, el c\xF3digo de las clases, hijas o padres, se hace sin tener en cuenta c\xF3mo van a ser llamadas. Debe ser **independiente** tal y como lo son unos procesos de otros.\r
\r
As\xED, en el anterior proyecto yo podr\xEDa ejecutar la clase psp.activities.U2A4_Commander de forma independiente, pas\xE1ndole el nombre de los programas.\r
\r
Puedo hacerlo invoc\xE1ndola desde l\xEDnea de comandos o desde Netbeans:\r
- java psp.activities.U2A4_Commander programa1 programa2 programa3\r
- En las propiedades del proyecto, en el apartado Run, seleccionando U2A4_Commander como clase principal y poniendo como Arguments: programa1 programa2 programa3\r
:::\r
`]},{title:"2.1 Creaci\xF3n de procesos en Java con Runtime",headers:[{level:2,title:"2.1.1. Creaci\xF3n r\xE1pida de procesos",slug:"_2-1-1-creacion-rapida-de-procesos",link:"#_2-1-1-creacion-rapida-de-procesos",children:[]},{level:2,title:"2.1.2 Propiedades del sistema y comandos del sistema",slug:"_2-1-2-propiedades-del-sistema-y-comandos-del-sistema",link:"#_2-1-2-propiedades-del-sistema-y-comandos-del-sistema",children:[]}],path:"/es/unit2/runtime.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.1 Creaci\xF3n de procesos en Java con Runtime\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.1. Creaci\xF3n de procesos con Java con Runtime" />\r
\r
# 2.1. Creaci\xF3n r\xE1pida de procesos con Java con Runtime\r
\r
[[toc]]\r
\r
## 2.1.1. Creaci\xF3n r\xE1pida de procesos\r
\r
La clase java.lang.Runtime se usa principalmente para interactuar con el JRE de Java. Esta clase proporciona m\xE9todos para lanzar procesos, llamar al recolector de basura (Garbage Collector), saber la cantidad de memoria disponible y libre, etc.\r
\r
> [Especificaci\xF3n java.lang.Runtime](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html)\r
\r
Cada aplicaci\xF3n en Java tiene acceso a una \xFAnica instancia de *java.lang.Runtime* a trav\xE9s del m\xE9todo \`Runtime.getRuntime()\` que devuelve la instancia **singleton** de la clase Runtime.\r
\r
::: question Patrones de dise\xF1o: Singleton\r
\xBFQu\xE9 son los patrones de dise\xF1o? \xBFQu\xE9 es y para qu\xE9 se usa el patr\xF3n de dise\xF1o singleton?\r
\r
Investiga c\xF3mo realizar una clase que siga el patr\xF3n de dise\xF1o singleton.\r
\r
[Refactoring.Guru Patrones de dise\xF1o](https://refactoring.guru/es/design-patterns/java)\r
:::\r
\r
El m\xE9todo que nos interesa a nosotros para la creaci\xF3n de procesos es\r
\r
> public Process exec(String command) throws IOException\r
\r
Veamos un ejemplo sencillo de uso de este m\xE9todo\r
\r
\`\`\`java\r
public static void main(String[] args) throws IOException {\r
    // Launch notepad app\r
    Runtime.getRuntime().exec("notepad.exe");\r
\r
    // This way always works\r
    // String separator = System.getProperty("file.separator");\r
    // Runtime.getRuntime()\r
    //    .exec("c:"+separator+"windows"+separator+"notepad.exe");\r
\r
    // This way used to work (UNIX style paths)\r
    // Runtime.getRuntime().exec("c:/windows/notepad.exe");\r
}\r
\`\`\`\r
\r
Se puede observar que en el par\xE1metro que pasamos al m\xE9todo \`exec\` indicamos el programa que queremos ejecutar. En este caso, como el *notepad* se encuentra en el PATH del sistema, no es necesario indicar la ruta donde se encuentra el programa. En otro caso, s\xED tendr\xEDamos que hacerlo.\r
\r
<div class="pagebreak"></div>\r
\r
## 2.1.2 Propiedades del sistema y comandos del sistema\r
\r
Si tenemos pensado desarrollar aplicaciones que funcionen en diferentes SO tendremos que enfrentarnos a la problem\xE1tica del funcionamiento diferente de los distintos SO.\r
\r
Vamos a ver algunos ejemplos que pueden servir como gu\xEDa para otros problemas similares a los expuestos.\r
\r
::: danger File separator\r
Para indicar las rutas en un sistema los sistemas UNIX emplean el caracter  **/** como separador mientras que los sistemas Windows usan el caracter **\\\\** . En resumen, / en *X y \\ en Windows.\r
\r
\xBFC\xF3mo podemos hacer entonces que nuestras aplicaciones sean independientes del SO en el que se ejecutan?\r
\r
Para este tipo de cuestiones vamos a utilizar de forma recurrente las propiedades del sistema mediante \`System.getProperty(String propName)\`. Estas propiedades se configuran con el propio sistema operativo, aunque las podemos modificar usando los par\xE1metros de ejecuci\xF3n de la m\xE1quina virtual\r
\r
> String separator = System.getProperty("file.separator");\r
\r
o\r
\r
> -Dfile.separator\r
\r
Aunque siempre es una buena pr\xE1ctica usar el caracter **/** en las rutas ya que Java es capaz de convertirlas al sistema en el que se ejecuta.\r
:::\r
\r
Si lo que queremos es ejecutar un comando del SO, tenemos que hacerlo, al igual que si lo hacemos manualmente, a trav\xE9s del shell del sistema, donde volvemos a encontrar la dicotom\xEDa entre sistemas UNIX y sistemas Windows.\r
\r
Vamos a ver el c\xF3digo que, a trav\xE9s de las propiedades del sistema, nos permite obtener un listado de los archivos existentes en la carpeta personal del usuario.\r
\r
\`\`\`java\r
// Primero obtenemos la carpeta del usuario\r
String homeDirectory = System.getProperty("user.home");\r
boolean isWindows = System.getProperty("os.name")\r
  .toLowerCase().startsWith("windows");\r
\r
if (isWindows) {\r
    Runtime.getRuntime()\r
      .exec(String.format("cmd.exe /c dir %s", homeDirectory));\r
} else {\r
    Runtime.getRuntime()\r
      .exec(String.format("sh -c ls %s", homeDirectory));\r
}\r
\`\`\`\r
\r
::: info Modo shell no interactivo\r
Como se puede observar, tanto para Windows como UNIX se ha usado el modificador **c** del comando. Este modificador indica que se abra un shell, se ejecute el comando recibido y se cierre el proceso del shell.\r
:::\r
\r
A continuaci\xF3n podemos ver un ejemplo de respuesta ante la pulsaci\xF3n de un bot\xF3n, en una app gr\xE1fica, paraabrir una p\xE1gina en el navegador. Tenemos c\xF3mo se har\xEDa en sistemas *X y comentado una de las formas de hacerlo en Windows.\r
\r
\`\`\`java\r
// Calling app example\r
public void mouseClicked(MouseEvent e) {\r
  // Launch Page\r
  try {\r
    // Linux version\r
    Runtime.getRuntime().exec("open http://localhost:8153/go");\r
    // Windows version\r
    // Runtime.getRuntime().exec("explorer http://localhost:8153/go");\r
  } catch (IOException e1) {\r
    // Don't care\r
  }\r
}\r
\`\`\`\r
\r
::: question System properties\r
Vamos a crear nuestro primer programa en Java, que no va a ser tan sencillo como pueda parecer\r
\r
Usando m\xE9todos de las clases System y Runtime hacer un programa que muestre\r
\r
- todas las propiedades establecidas en el sistema operativo y sus valores.\r
- memoria total, memoria libre, memoria en uso y los procesadores disponibles\r
\r
Mira los m\xE9todos que proporcionan las clases Runtime  y system. Intenta obtener una lista u otra estructura de datos que te permita recorrer las propiedades para ir mostrando sus nombres y valores.\r
:::\r
\r
::: details Soluci\xF3n propuesta para la actividad anterior\r
\r
\`\`\`java{22,25,32,38,44}\r
long freeMemory = Runtime.getRuntime().freeMemory();\r
long availableMemory = Runtime.getRuntime().totalMemory();\r
long usedMemory = availableMemory - freeMemory;\r
\r
/*** Runtime.getRuntime() usage ***/\r
// Show system information\r
// Memory will be shown in MBytes formatted with 2-decimal places\r
DecimalFormat megabytes = new DecimalFormat("#.00");\r
System.out.println("Available memory in JVM(Mbytes): " + \r
        megabytes.format((double)availableMemory/(1024*1024)));\r
System.out.println("Free memory in JVM(Mbytes): " + \r
        megabytes.format((double)freeMemory/(1024*1024)));\r
System.out.println("Used memory in JVM(Mbytes): " + \r
        megabytes.format((double)usedMemory/(1024*1024)));\r
\r
System.out.println ("Processors in the system: " \r
        + Runtime.getRuntime().availableProcessors());\r
\r
/*** System.getProperties() usage ***/\r
// Show each pair of property:value from System properties\r
\r
// 1st. As a lambda expression using anonymous classes\r
System.getProperties().forEach((k,v) -> System.out.println(k + " => " + v));\r
\r
// 2nd. As a Map.entrySet \r
for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\r
    Object key = entry.getKey();\r
    Object val = entry.getValue();\r
    System.out.println("> " + key + " => " + val);\r
}\r
\r
// 3rd. As a Map.keySet\r
for (Object key : System.getProperties().keySet().toArray())\r
{\r
    System.out.println(">> " + key+":"+System.getProperty(key.toString()));\r
}\r
\r
// Other methods found by students, based on a Properties object methods.\r
Properties prop = System.getProperties();\r
for (String propName: prop.stringPropertyNames()) {\r
  System.out.println(propName +  ":" + System.getProperty(propName));\r
}\r
        \r
// Or directly to the console using \r
prop.list(System.out);\r
\`\`\`\r
:::\r
\r
::: info Formato num\xE9rico\r
Todos los lenguajes de programaci\xF3n tienen varias formas de mostrar la informaci\xF3n al usuario. Cuando se trata de mostrar informaci\xF3n a a trav\xE9s de la consola, tenemos un par de alternativas para formatear la informaci\xF3n num\xE9rica.\r
\r
- [NumberFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DecimalFormat.html)\r
\r
Si usamos la clase NumberFormat o cualquiera de sus descendientes podemos controlar con bastante precisi\xF3n c\xF3mo se ver\xE1n los n\xFAmeros, usando patrones.\r
\r
\`\`\`java:no-line-numbers\r
DecimalFormat numberFormat = new DecimalFormat("#.00");\r
// Si usamos hashes en vez de ceros permitimos que .30 se vea como 0.3\r
// (los d\xEDgitos adicionales son opcionales)\r
System.out.println(numberFormat.format(number));\r
\`\`\`\r
\r
- [System.out.printf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html)\r
\r
Heredado de la sintaxis de la funci\xF3n printf de C, podemos utilizar la sintaxis de java.util.Formatter para configurar c\xF3mo ser\xE1 visualizada la informaci\xF3n.\r
\r
\`\`\`java:no-line-numbers\r
System.out.printf("\\n$%10.2f",shippingCost);\r
// % rellena con hasta 10 posiciones los n\xFAmeros\r
// para justificarlos a la derchan.\r
System.out.printf("%n$%.2f",shippingCost);\r
\`\`\`\r
\r
:::\r
\r
::: info Usando colores en la salida por consola\r
\r
Hay una forma sencilla de mostrar informaci\xF3n por consola usando diferentes colores. Os dejo un ejemplo de c\xF3digo con la definici\xF3n de algunos colores y la forma de usarlos.\r
\r
\`\`\`java:no-line-numbers\r
public class UsarColoresEnConsola {\r
\r
public static final String ANSI_RESET = "\\u001B[0m";\r
public static final String ANSI_BLACK = "\\u001B[30m";\r
public static final String ANSI_RED = "\\u001B[31m";\r
public static final String ANSI_GREEN = "\\u001B[32m";\r
public static final String ANSI_YELLOW = "\\u001B[33m";\r
public static final String ANSI_BLUE = "\\u001B[34m";\r
public static final String ANSI_PURPLE = "\\u001B[35m";\r
public static final String ANSI_CYAN = "\\u001B[36m";\r
public static final String ANSI_WHITE = "\\u001B[37m";\r
\r
public static final String ANSI_BLACK_BACKGROUND = "\\u001B[40m";\r
public static final String ANSI_RED_BACKGROUND = "\\u001B[41m";\r
public static final String ANSI_GREEN_BACKGROUND = "\\u001B[42m";\r
public static final String ANSI_YELLOW_BACKGROUND = "\\u001B[43m";\r
public static final String ANSI_BLUE_BACKGROUND = "\\u001B[44m";\r
public static final String ANSI_PURPLE_BACKGROUND = "\\u001B[45m";\r
public static final String ANSI_CYAN_BACKGROUND = "\\u001B[46m";\r
public static final String ANSI_WHITE_BACKGROUND = "\\u001B[47m";\r
\r
    public static void main(String[] args) {\r
        System.out.println(ANSI_GREEN + ANSI_WHITE_BACKGROUND + "Hola" + ANSI_BLUE + ANSI_YELLOW_BACKGROUND + " Adi\xF3s" + ANSI_RESET);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
`]},{title:"3.4 Mecanismos alternativos de sincronizaci\xF3n",headers:[{level:2,title:"3.4.1. Sem\xE1foros",slug:"_3-4-1-semaforos",link:"#_3-4-1-semaforos",children:[]},{level:2,title:"3.4.2. Mecanismos de alto nivel",slug:"_3-4-2-mecanismos-de-alto-nivel",link:"#_3-4-2-mecanismos-de-alto-nivel",children:[{level:3,title:"Colas concurrentes",slug:"colas-concurrentes",link:"#colas-concurrentes",children:[]},{level:3,title:"Colecciones concurrentes",slug:"colecciones-concurrentes",link:"#colecciones-concurrentes",children:[]},{level:3,title:"Variables at\xF3micas",slug:"variables-atomicas",link:"#variables-atomicas",children:[]}]},{level:2,title:"3.4.3 Executors, Callables y Future",slug:"_3-4-3-executors-callables-y-future",link:"#_3-4-3-executors-callables-y-future",children:[]}],path:"/es/unit3/alternatives.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.4 Mecanismos alternativos de sincronizaci\xF3n\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.4 Mecanismos alternativos de sincronizaci\xF3n" />\r
\r
# 3.4 Mecanismos alternativos de sincronizaci\xF3n\r
\r
[[toc]]\r
\r
## 3.4.1. Sem\xE1foros\r
\r
Otro posible mecanismos para sincronizar hilos son los \`sem\xE1foros\`. Un sem\xE1foro es un mecanismo para permitir, o restringir, el acceso a recursos compartidos en un entorno de multiprocesamiento, con varios hilos ejecut\xE1ndose de forma concurrente.\r
\r
> Especificaci\xF3n de [java.util.concurrent.Semaphore](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Semaphore.html)\r
\r
Los sem\xE1foros se emplean para permitir el acceso a diferentes partes de programas (llamados secciones cr\xEDticas) donde se manipulan variables o recursos que deben ser accedidos de forma especial. Seg\xFAn el valor con que son inicializados se permiten a m\xE1s o menos procesos utilizar el recurso de forma simult\xE1nea.\r
\r
El funcionamiento de los sem\xE1foros se basa en el uso de dos m\xE9todos, as\xED como en el valor inicial \`permits\` con el que se crea el sem\xE1foro:\r
\r
- release(): Ejecutado por un hilo para liberar el sem\xE1foro cuando el hilo ha terminado de ejecutar la secci\xF3n cr\xEDtica. Por defecto se incrementa la variable \`permits\` en 1, aunque puede recibir un valor e incrementarla en esa cantidad.\r
- acquire(): Ejecutado por un hilo para acceder al sem\xE1foro. Para que un hilo pueda tomar el control del sem\xE1foro y no quedarse bloqueado, la variable \`permits\`debe tener un valor mayor que cero. Tambi\xE9n puede recibir un valor, por lo que \`permits\` tendr\xE1 que ser mayor que dicho valor.\r
- permits: Se inicializa a la cantidad de recursos existentes o hilos que queramos que puedan acceder simult\xE1neamente. As\xED, cada proceso, al ir solicitando un recurso, verificar\xE1 que el valor del sem\xE1foro sea mayor de 0; si es as\xED es que existen recursos libres, seguidamente acaparar\xE1 el recurso y restar\xE1 el valor del sem\xE1foro.\r
Cuando el sem\xE1foro alcance el valor 0, significar\xE1 que todos los recursos est\xE1n siendo utilizados, y los procesos que quieran solicitar un recurso deber\xE1n esperar a que el sem\xE1foro sea positivo (alg\xFAn hilo haga un release).\r
\r
:::info Mutex\r
Un tipo simple de sem\xE1foro es el binario, que puede tomar solamente los valores 0 y 1.\r
\r
Se inicializan en 1 y son usados cuando s\xF3lo un proceso puede acceder a un recurso a la vez. Se les suele llamar mutex.\r
\r
Tienen un funcionamiento similar a synchronized, funcionando en exclusi\xF3n mutua (**mut**ual **ex**clusion).\r
:::\r
\r
Veamos un ejemplo en el que varios Productores y Consumidores acceden de forma simult\xE1nea a un objeto compartido\r
\r
\`\`\`java {class="line-numbers",5-7,13,15,20,27,37,39,44,51}\r
public class Almacen {\r
\r
  private final int MAX_LIMITE = 20;\r
  private int producto = 0;\r
  private Semaphore productor = new Semaphore(MAX_LIMITE);\r
  private Semaphore consumidor = new Semaphore(0);\r
  private Semaphore mutex = new Semaphore(1);\r
\r
  public void producir(String nombreProductor) {\r
    System.out.println(nombreProductor + " intentando almacenar un producto");\r
    try {\r
        // En el ejemplo, hasta 20 productores pueden acceder a la vez      \r
        productor.acquire();\r
        // Sin embargo, s\xF3lo 1 (consumidor/productor) a la vez podr\xE1 actualizar \r
        mutex.acquire();\r
\r
        producto++;\r
        System.out.println(nombreProductor + " almacena un producto. "\r
            + "Almac\xE9n con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
      \r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // El productor permite que un consumidor pueda acceder\r
      consumidor.release();\r
    }\r
\r
  }\r
\r
  public void consumir(String nombreConsumidor) {\r
    System.out.println(nombreConsumidor + " intentando retirar un producto");\r
    try {\r
        // En el ejemplo siempre tiene que llegar un consumidor antes que un productor\r
        consumidor.acquire();\r
        // Sin embargo, s\xF3lo 1 (consumidor/productor) a la vez podr\xE1 actualizar \r
        mutex.acquire();\r
\r
        producto--;\r
        System.out.println(nombreConsumidor + " retira un producto. "\r
            + "Almac\xE9n con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // El consumidor avisa para que un productor pueda volver a dejar productos.\r
      productor.release();\r
\r
    }\r
  }\r
\r
}\r
\`\`\`\r
\r
## 3.4.2. Mecanismos de alto nivel\r
\r
Java, en su paquete \`java.util.concurrent\` proporciona varias clases \`thread-safe\` que nos permiten acceder a los elementos de colecciones y tipos de datos sin preocuparnos de la concurrencia.\r
\r
Es un paquete muy amplio que contiene multitud de clases que podemos utilizar en nuestros desarrollos multihilo para simplificar la complejidad de los mismos.\r
\r
### Colas concurrentes\r
\r
La interfaz **BlockingQueue** define una cola \`FIFO\` que bloquea hilos que intentan extraer un elemento si la cola est\xE1 vac\xEDa, hasta que vuelva a haber elementos. Tambi\xE9n permite establecer un n\xFAmero m\xE1ximo de elementos, de marea que se bloquean los procesos cuando intentan a\xF1adir por encima de ese l\xEDmite, a la espera que se extraigan.\r
\r
Las clases LinkedBlockingQueue, ArrayBlockingQueue, SynchronousQueue, PriorityBlockingQueue y DelayQueue implementan la interfaz BlockingQueue.\r
\r
### Colecciones concurrentes\r
\r
El uso de colecciones simult\xE1neas es una forma recomendada de crear estructuras de datos compatibles con procesos. Dichas colecciones incluyen ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArraylist y CopyOnWriteArraySet.\r
\r
**ConcurrentMap** es una subinterfaz de \`java.util.Map\` con operaciones at\xF3micas para eliminar o reemplazar pares clave/valor existentes o a\xF1adir pares clave/valor no existentes. ConcurrentHashMap es la versi\xF3n thread-safe an\xE1loga a HashMap.\r
\r
### Variables at\xF3micas\r
\r
El paquete \`java.util.concurrent.atomic\` incluye clases que proporcionan acciones at\xF3micas sobre tipos de datos b\xE1sicos. Tenemos AtomicBoolean, AtomicInteger, AtomicDouble, .... y proporcionan m\xE9todos para recuperar su valor, incrementar, decrementar, etc.\r
\r
## 3.4.3 Executors, Callables y Future\r
\r
Existen muchas aproximaciones y librer\xEDas que permiten en uso y gesti\xF3n de hilos desde un programa. Una de las que nos ofrece Java como parte del JDK es la interfaz Executors.\r
\r
\`Executors\` nos va a permitir definir un pool de threads (un conjunto de hilos) que se encargar\xE1n de ejecutar las tareas, pero con un l\xEDmite en cuanto al n\xFAmero de hilos creados y gestionando el la JVM la cola de hilos que ser\xE1n ejecutados en ese pool.\r
\r
Se sale del \xE1mbito de este m\xF3dulo estudiar y analizar el funcionamiento de Executors y todas sus posibilidades. Aqu\xED os dejo un enlace a un art\xEDculo que lo explica con un ejemplo muy ilustrativo.\r
\r
[Executors: Ejemplo supermercado](https://jarroba.com/multitarea-e-hilos-en-java-con-ejemplos-ii-runnable-executors/)\r
\r
\`Callable\` viene a poner soluci\xF3n a uno de los problemas que tenemos con la interfaz Runnable, la posibilidad de devolver un valor desde este m\xE9todo.\r
\r
Si se necesita que un proceso devuelva datos al finalizar, se debe crear una clase que implemente la interfaz Callable y defina un m\xE9todo \`call()\` que desempe\xF1e la misma funci\xF3n que run() en Runnable. En este caso se tendr\xE1n que crear los procesos de forma diferente; la clase Thread no acepta un objeto Callable como argumento. Por contra, la clase Executors ofrece diversos m\xE9todos est\xE1ticos que crean un proceso a partir de su clase Callable.\r
\r
\`Future\` es una interfaz que implementa el objeto que devuelve el resultado de la ejecuci\xF3n de un Callable. Se puede seguir ejecutando una aplicaci\xF3n hasta que necesite obtener el resultado del hilo *Callable*, momento en el que se invoca el m\xE9todo get() en la instancia Future. Si el resultado ya est\xE1 disponible se recoge y en caso contrario se bloquear\xE1 en la llamada hasta que su m\xE9todo call() devuelva el resultado.\r
`]},{title:"3.6 Annex III - ArrayList hoja de referencia de los alumnos",headers:[{level:2,title:"A. Definici\xF3n y creaci\xF3n",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de ArrayList",slug:"a-1-constructores-de-arraylist",link:"#a-1-constructores-de-arraylist",children:[]}]},{level:2,title:"B. M\xE9todos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creaci\xF3n de un ArrayList",slug:"b-1-creacion-de-un-arraylist",link:"#b-1-creacion-de-un-arraylist",children:[]},{level:3,title:"B.2. A\xF1adir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si un elemento ya existe",slug:"b-3-comprobar-si-un-elemento-ya-existe",link:"#b-3-comprobar-si-un-elemento-ya-existe",children:[]},{level:3,title:"B.4. Acceder a un elemento del ArrayList",slug:"b-4-acceder-a-un-elemento-del-arraylist",link:"#b-4-acceder-a-un-elemento-del-arraylist",children:[]},{level:3,title:"B.5. Otras funciones de utilidad",slug:"b-5-otras-funciones-de-utilidad",link:"#b-5-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. A\xF1adir datos a un ArrayList",slug:"c-anadir-datos-a-un-arraylist",link:"#c-anadir-datos-a-un-arraylist",children:[{level:3,title:"C.1. A\xF1adir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. A\xF1adir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. A\xF1adir / eliminar elementos desde c\xF3digo",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la colecci\xF3n",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el m\xE9todo forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la colecci\xF3n",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. B\xFAsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. B\xFAsqueda usando los m\xE9todos de la clase",slug:"e-1-busqueda-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. B\xFAsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. B\xFAsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. B\xFAsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtenci\xF3n de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenaci\xF3n de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar usando m\xE9todos de Collection",slug:"g-1-ordenar-usando-metodos-de-collection",link:"#g-1-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.3. Ordenar con expresiones lambda",slug:"g-3-ordenar-con-expresiones-lambda",link:"#g-3-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.4. Ordenar con API Stream",slug:"g-4-ordenar-con-api-stream",link:"#g-4-ordenar-con-api-stream",children:[]}]}],path:"/es/unit3/arraylist_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.6 Annex III - ArrayList hoja de referencia de los alumnos\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.6 Annex III - ArrayList hoja de referencia de los alumnos" />\r
\r
# 3.6 Annex III - ArrayList hoja de referencia de los alumnos\r
\r
::: info Autor\xEDa\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del m\xF3dulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la informaci\xF3n a la que podr\xE9is acceder durante los ex\xE1menes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definici\xF3n y creaci\xF3n\r
\r
Una colecci\xF3n representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almac\xE9n donde poder guardarlos. En Java, se emplea la interfaz gen\xE9rica \`Collection\` para este prop\xF3sito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de m\xE9todos comunes, como pueden ser: a\xF1adir, eliminar, obtener el tama\xF1o de la colecci\xF3n.\r
\r
Partiendo de la interfaz gen\xE9rica Collection extienden otra serie de interfaces gen\xE9ricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
La clase ArrayList en Java permite almacenar datos en memoria de forma similar a los Arrays con la ventaja de que el numero de elementos que almacena lo hace de forma din\xE1mica, es decir, que no es necesario declarar su tama\xF1o como pasa con los Arrays. Los elementos pueden a\xF1adirse o eliminarse seg\xFAn necesidad.\r
\r
### A.1. Constructores de ArrayList\r
\r
ArrayList proporciona 3 constructores que definen la capacidad inicial de la colecci\xF3n o si la inicializamos a partir de los valores de otra colecci\xF3n.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de ArrayList vac\xEDa.\r
ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\r
// ArrayList(int initialCapacity). Crea una instancia de ArrayList con una capacidad inicial especificada. \r
ArrayList<Persona> listaPersonas = new ArrayList<>(10);\r
\r
// ArrayList(Collection c). Crea una instancia de ArrayList a partir de otra colecci\xF3n de datos. Los datos se a\xF1aden en el orden en el que el Iterator de la otra colecci\xF3n los recorra.\r
ArrayList<Persona> listaPersonas = new ArrayList<>(c);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. M\xE9todos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendr\xEDamos con la ejecuci\xF3n de estos m\xE9todos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "Garc\xEDa", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Mart\xEDnez", 65, 1.84d, 82, "Hombre");\r
  Persona p3 = new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre");\r
  Persona p4 = new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer");\r
\`\`\`\r
\r
### B.1. Creaci\xF3n de un ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un ArrayList de Personas\r
  ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\`\`\`\r
\r
### B.2. A\xF1adir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // A\xF1adir un objeto Persona al final del ArrayList\r
  listaPersonas.add(p1);\r
\r
  // A\xF1ade el elemento al ArrayList en la posici\xF3n 'n+1'. \r
  // Cuidado, no podemos insertar en posiciones que no existen.\r
  listaPersonas.add(1, p1);\r
  \r
  // Borra el elemento de la posici\xF3n 'n+1' del ArrayList   \r
  // Cuidado, no podemos eliminar de posiciones que no existen.\r
  listaPersonas.remove(2);\r
\r
  // Borra el primer objeto pasado encontrado en el ArrayList que se le pasa como par\xE1metro.  \r
  listaPersonas.remove(p1);  \r
\`\`\`\r
\r
::: info Duplicados\r
Si ya existe un elemento en el ArrayList, esta colecci\xF3n no controla la existencia de duplicados, por lo que tendremos el mismo objeto en dos posiciones diferentes.\r
Podemos evitarlo comprobando previamente si ya existe ese objeto, como veremos a continuaci\xF3n.\r
:::\r
\r
### B.3. Comprobar si un elemento ya existe\r
\r
\`\`\`java:no-line-numbers\r
  // Comprueba si existe del objeto que se le pasa como par\xE1metro\r
  listaPersonas.contains(p4);\r
\r
  // Devuelve la posici\xF3n del primer objeto pasado encontrado en el ArrayList  \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.indexOf(p1);\r
\r
  // Devuelve la posici\xF3n del \xFAltimo objeto pasado en el ArrayList   \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### B.4. Acceder a un elemento del ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el elemento que esta en la posici\xF3n 'n+1' del ArrayList\r
  listaPersonas.get(2);\r
\`\`\`\r
\r
### B.5. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el numero de elementos del ArrayList\r
  listaPersonas.size();\r
\r
  //Borra todos los elementos de ArrayList   \r
  listaPersonas.clear();\r
\r
  // Devuelve true si el ArrayList esta vac\xEDo. Sino Devuelve false   \r
  listaPersonas.isEmpty();\r
\r
  // Pasa el ArrayList a un Array \r
  Object[] array = listaPersonas.toArray();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. A\xF1adir datos a un ArrayList\r
\r
::: info Orden de los elementos en un ArrayList\r
Cuando a\xF1adimos elementos a un ArrayList, el orden de inserci\xF3n se conserva.\r
\r
Una Lista, por definici\xF3n, siempre mantiene el orden de los elementos. Esto no es solo para ArrayList, sino para todo tipo de listas como LinkedList, Vector, y el resto de clases que implementan el interfaz \`java.util.List\` .\r
\r
:::\r
\r
### C.1. A\xF1adir elementos desde el constructor\r
\r
A la hora de crear el ArrayList, podemos a\xF1adirle datos, usando la sintaxis del doble corchete o bien con la construcci\xF3n List.of o Arrays.asList\r
\r
\`\`\`java:no-line-numbers\r
  // Crea una nueva lista y a la vez la inicializa con valores  \r
  ArrayList<Persona> lista1 = new ArrayList<>() {{\r
      add(p1);\r
      add(p2);\r
  }};\r
\r
  // En este caso indicamos los valores como si de par\xE1metros se tratase\r
  // De esta forma podemos a\xF1adir hasta un m\xE1ximo de 10 elementos\r
  ArrayList<Persona> lista2 = new ArrayList<>(\r
        List.of(p1, p2, p3)\r
  );\r
\r
  // De forma similar al caso anterior, con una construcci\xF3n a partir de un Array\r
  ArrayList<Persona> lista3 = new ArrayList<>(\r
        Arrays.asList(p1, p2, p3)\r
  );       \r
\`\`\`\r
\r
### C.2. A\xF1adir elementos desde otras colecciones\r
\r
Podemos inicializar un ArrayList, como hemos visto en los ejemplos anteriores, desde varios tipos de colecciones (listas) que poseen caracter\xEDsticas similares.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del c\xF3digo anterior, creamos un nuevo ArrayList a partir de lista2\r
  ArrayList<Persona> lista4 = new ArrayList<>(lista3);  \r
  \r
  // A\xF1ade todos los elementos de la lista que indiquemos como argumento al final del ArrayList\r
  lista4.addAll(lista3);\r
\r
  // Hace lo mismo, pero lo inserta en la posici\xF3n indicada (debe existir al menos la posici\xF3n anterior)  \r
  lista4.addAll(lista3,2);\r
\`\`\`\r
\r
### C.3. A\xF1adir / eliminar elementos desde c\xF3digo\r
\r
\`\`\`java:no-line-numbers\r
  // A\xF1adir un elemento al final de la lista\r
  lista4.add(p4);\r
  // A\xF1ade un elemento en la posici\xF3n indicada. El elemento que ocupaba esa posici\xF3n y todos los que hab\xEDa detr\xE1s, se mueven una posici\xF3n a la derecha.\r
  // En el ejemplo, inserta p1 al principio de la lista.\r
  lista4.add(0,p1);   // Inserta p1 al principio de la lista.\r
  \r
  // Eliminar un elemento. Si existe lo elimina y devuelve true, si no devuelve false\r
  boolean existe = lista4.remove(p1);  \r
  // Eliminar un elemento por \xEDndice. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = lista4.remove(2);  \r
  // Elimina del ArrayList todos aquellos elementos que coinciden con los indicados en la lista que pasamos como argumento \r
  lista4.removeAll(lista3);\r
  // Elimina del ArrayList todos aquellos elementos que cumplen con el predicado (la condici\xF3n) descrita como argumento en el m\xE9todo e indicada como expresi\xF3n lambda\r
  lista4.removeIf(p->p.getEdad()<18);   // Elimina los menores de 18\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la colecci\xF3n\r
\r
Vamos a preparar un ArrayList para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList creation\r
  ArrayList<Persona> grupoPersonas = new ArrayList<>() {{\r
    add(new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
    add(new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
    add(new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
    add(new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
    add(new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
    add(new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\r
\`\`\`\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por \xEDndice\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(i));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el ArrayList es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : colecci\xF3n)\r
\r
\`\`\`java:no-line-numbers\r
    // Obtenemos un objeto de tipo Persona en cada iteraci\xF3n del bucle\r
    for (Persona p: grupoPersonas) {\r
        System.out.println(p);\r
    }\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una colecci\xF3n y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un m\xE9todo iterator() que devuelve una instancia de Iterator para recorrer la colecci\xF3n.\r
\r
Iterator tiene 4 m\xE9todos:\r
\r
- **hasNext()** - devuelve true si hay un elemento m\xE1s en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el \xFAltimo elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la acci\xF3n indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la lista\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el m\xE9todo forEach con expresiones lambda\r
\r
En este caso aprovechamos el m\xE9todo foreach de las colecciones para poder realizar una acci\xF3n concreta sobre cada uno de los elementos de la misma.\r
\r
De forma similar al bucle foreach, indicamos un elemento de la lista y la acci\xF3n a realizar sobre el mismo\r
\r
\`\`\`java:no-line-numbers\r
  // Para cada persona (p) -> Acci\xF3n a realizar\r
  grupoPersonas.forEach(p -> System.out.println(p));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la colecci\xF3n\r
\r
Mientras se est\xE1 recorriendo una colecci\xF3n, no con todos los tipos de bucles se puede modificar (a\xF1adir/eliminar elementos) de la colecci\xF3n. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendr\xEDamos problemas. Al acceder por \xEDndice, podemos a\xF1adir o eliminar elementos mientras se recorre la colecci\xF3n.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.get(i).getNombre().equals("Jordi")) {\r
      grupoPersonas.remove(i);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, s\xF3lo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colecci\xF3n.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Persona p : grupoPersonas) {\r
    if (p.getPeso()>100) {\r
      grupoPersonas.remove(p);\r
    }\r
    System.out.println("Eliminada: " + p);\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Siempre que usemos el m\xE9todo remove de Iterator para eliminar elementos de la colecci\xF3n mientras la recorremos, podremos hacerlo sin que se genere ninguna excepci\xF3n.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Persona> iterator = grupoPersonas.iterator();\r
  while (iterator.hasNext()) {\r
    Persona p = iterator.next();\r
    if (p.getAltura() < 100) {\r
      // Si borramos usando iterator.remove funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el m\xE9todo forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, s\xF3lo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colecci\xF3n.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.forEach((p) -> {if (p.getNombre().equals("Jordi")) grupoPersonas.remove(p);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la colecci\xF3n, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. B\xFAsqueda de elementos\r
\r
Para buscar elementos en un ArrayList hay distintas formas de hacerlo. Desde los propios m\xE9todos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. B\xFAsqueda usando los m\xE9todos de la clase\r
\r
La clase ArrayList nos ofrece diferentes alternativas para buscar y/o saber si un elemento est\xE1 presente en la colecci\xF3n. As\xED, podemos usar los m\xE9todos\r
\r
\`\`\`java:no-line-numbers\r
  // Comprobar si est\xE1 el objeto en la colecci\xF3n\r
  boolean existe = grupoPersonas.contains(p1);\r
  // O simplemente obtener su posici\xF3n, si lo encuentra\r
  grupoPersonas.indexOf(p1);\r
  grupoPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### E.2. B\xFAsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la colecci\xF3n hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> it = grupoPersonas.iterator();\r
  while (it.hasNext()) {\r
    Persona p = it.next();\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado: " + p);\r
      break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. B\xFAsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber m\xE1s de un elemento que cumpla el criterio de b\xFAsqueda\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado:: " + p);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. B\xFAsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gesti\xF3n de las colecciones.\r
Podemos emplear varios m\xE9todos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcolecci\xF3n\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber m\xE1s de un elemento que cumpla el criterio de b\xFAsqueda\r
\r
  // Obtener un subarray con los elementos que cumplan el criterio\r
  grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList());\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);   \r
  }\r
\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cu\xE1ntos cumplen el criterio de b\xFAsqueda\r
  grupoPersonas.stream().filter(p -> p.getAltura() > 170).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Persona> first = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .findFirst();\r
\r
  // Obtener cualquiera que cumpla el criterio, o null si no hay ninguno\r
  Persona any = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)                \r
          .findAny()\r
          .orElse(null);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtenci\xF3n de subcolecciones\r
\r
Lo podemos considerar un tipo especial de b\xFAsqueda en el que el objetivo es conseguir una colecci\xF3n con los elementos que cumplan un determinado criterio.\r
\r
As\xED, la forma de buscar es id\xE9ntica a la del apartado anterior, pero en este caso lo que obtendremos de esa b\xFAsqueda ser\xE1 una nueva lista con un subconjunto de elementos de la original\r
\r
### F.1. Subcolecciones usando bucles\r
\r
Para obtener los elementos podemos aplicar lo aprendido en el anterior punto. Buscaremos elemento a elemento y, cuando se cumpla una condici\xF3n especificada, a\xF1adiremos los elementos encontrados a una nueva colecci\xF3n.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas = new ArrayList<>();\r
  for (Persona p : grupoPersonas) {\r
    if (p.getNombre().startsWith("M")) {\r
      personas.add(p);\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
La idea es similar al punto anterior\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas2 = new ArrayList<>();\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().startsWith("M")) {\r
      personas2.add(p);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener directamente una subcolecci\xF3n mediante el filtrado, haciendo subconjuntos y guardando el resultado.\r
\r
Con API Stream podemos guardar el resultado usando diferentes formas de .collect, que dar\xE1n como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList de Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas3 = (ArrayList<Persona>) grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toList());\r
\r
  // Conjunto de Personas cuyo nombre empieza por "M"\r
  Set<Persona> personas4 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toSet());\r
  \r
  // Mapa de Personas cuyo nombre empieza por "M"\r
  // En la construcci\xF3n del mapa, hay que elegir un campo que sirva de clave\r
  Map<String, Persona> personas5 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toMap(Persona::getApellidos, Function.identity()));\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenaci\xF3n de elementos\r
\r
### G.1. Ordenar usando m\xE9todos de Collection\r
\r
Si lo que queremos es tener el conjunto ordenados, la forma m\xE1s f\xE1cil es ordenarla usando el m\xE9todo sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Ordena seg\xFAn el m\xE9todo compareTo sobrescrito al implementar el interfaz Comparable\r
  // Si no se ha implementado, ordena seg\xFAn el orden natural\r
  Collections.sort(grupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(grupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su m\xE9todo \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos m\xE1s adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.3. Ordenar con expresiones lambda\r
\r
De esta forma no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparaci\xF3n que queremos hacer como par\xE1metro del m\xE9todo sort.\r
\r
As\xED podemos tener distintas formas de ordenar, seg\xFAn nos convenga.\r
\r
\`\`\`java:no-line-numbers\r
  // Indicamos la comparaci\xF3n que queremos hacer. Podemos usar compareTo \r
  Collections.sort(grupoPersonas, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(grupoPersonas);      \r
\r
  // o bien podemos definir nuestro propio comparador\r
  Collections.sort(grupoPersonas, (p1, p2) -> {\r
    String nombreCompleto1 = p1.getApellidos() + ", " + p1.getNombre();\r
    String nombreCompleto2 = p2.getApellidos() + ", " + p2.getNombre();\r
    return nombreCompleto1.compareTo(nombreCompleto2);\r
});\r
\`\`\`\r
\r
### G.4. Ordenar con API Stream\r
\r
Con API Stream usamos tambi\xE9n el m\xE9todo sorted para indicar qu\xE9 comparaci\xF3n se debe realizar. Tenemos varias opciones en funci\xF3n del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el m\xE1s flexible es aquel en el que indicamos, mediante una expresi\xF3n lambda, qu\xE9 comparaci\xF3n realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en una nueva lista con los elementos ordenados\r
  ArrayList<Persona> grupoPersonasOrdenado = (ArrayList<Persona>) grupoPersonas.stream()\r
          // En este caso ordenamos por apellido, ascendente.\r
          .sorted((p1, p2) -> p1.getApellidos().compareTo(p2.getApellidos()))\r
          // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
          //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
          .collect(Collectors.toList());\r
\`\`\`\r
\r
::: info Encadenar m\xE9todos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcolecci\xF3n con los resultados.\r
\r
Es lo m\xE1s parecido que vamos a encontrar a una consulta SQL para los datos de una colecci\xF3n cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instant\xE1neas, sin lugar a bugs, con muy poco c\xF3digo.\r
:::\r
`]},{title:"3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans",headers:[],path:"/es/unit3/debugger_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans" />\r
\r
# 3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans\r
\r
Los entornos de desarrollo Java proporcionan las herramientas necesarias para la depuraci\xF3n (debugging) de aplicaciones multihilo.\r
\r
Al igual que en aplicaciones monohilo, podemos ubicar los breakpoints en el punto en el que nos interese detener la ejecuci\xF3n del programa, para de esta forma poder inspeccionar el estado de los objetos, los valores de las propiedades, etc.\r
\r
Para poder monitorizar los hilos de un programa, debemos activar la ventana de Debugging desde el menu *Window > Debugging > Debugging (Alt+Shift +9)*\r
\r
![Activar thread debug](../../media/unit3/NetbeansDebug1.jpg)\r
\r
A partir de ese momento podremos ver la parte derecha las opciones de depuraci\xF3n de hilos junto con toda la informaci\xF3n de los hilos que se est\xE1n ejecutando en nuestra aplicaci\xF3n.\r
\r
Veamos el significado de lo que Netbeans nos muestra en esta caja de di\xE1logo\r
\r
![Di\xE1logo depuraci\xF3n threads](../../media/unit3/NetbeansDebug2.jpg)\r
\r
- Con una franja de color verde a la izquierda y resaltado tambi\xE9n en color verde vemos lo que Netbeans denomina el *current thread*, es decir, el hilo que estamos depurando y sobre el que se aplicar\xE1n las acciones de depuraci\xF3n como Step Into, StepOver, Pause, Continue, etc. Adem\xE1s, podremos inspeccionar el valor de las variables para ese hilo en concreto.\r
- Con una franja de color amarillo en la parte izquierda, y relacionado con el aviso de la parte inferior, vemos los hilos que est\xE1n parados en alg\xFAn breakpoint marcado por nosotros. Este color y los avisos est\xE1n para que atendamos al hilo y podamos visualizar su estado o continuar con su ejecuci\xF3n.\r
- En la parte derecha de cada hilo tenemos un acceso r\xE1pido a la funci\xF3n de Reanudar o Pausar cada uno de los threads activos.\r
  \r
![Cambio de hilo](../../media/unit3/NetbeansDebug3.jpg)\r
\r
Pulsando con el bot\xF3n derecho sobre cualquiera de los hilos podemos convertirlo en el *current thread*. As\xED pasamos a controlar la ejecuci\xF3n e inspecci\xF3n de ese hilo mientras los dem\xE1s siguen pausados o bien continuan su ejecuci\xF3n.\r
\r
![Estado de los hilos](../../media/unit3/NetbeansDebug4.jpg)\r
\r
Adem\xE1s, la rueda dentada que est\xE1 al lado del identificador de cada hilo nos d\xE1 informaci\xF3n del estado del hilo.\r
\r
- Cuando la rueda est\xE1 de color naranja indica que el hilo est\xE1 suspendido en espera de nuestra atenci\xF3n.\r
- Cuando la rueda est\xE1 verde, indica que el hilo est\xE1 en ejecuci\xF3n. Si ponemos el rat\xF3n encima podemos obtener informaci\xF3n de su estado. Como se puede observar en la imagen, el hilo 2 est\xE1 en ejecuci\xF3n aunque se encuentra en estado de espera. Es un hilo que est\xE1 bloqueado en un join.\r
\r
![Estado de los hilos](../../media/unit3/NetbeansDebug5.jpg)\r
\r
Por \xFAltimo, la depuraci\xF3n de hilos tambi\xE9n nos ayuda a detectar c\xF3mo los hilos est\xE1n sincroniz\xE1ndose con el uso de monitores. Podemos ver si un hilo tiene un monitor (bloqueo) bajo su control, y qu\xE9 hilos est\xE1n esperando a que se libere un bloqueo para poder continuar.\r
\r
Como herramienta adicional, Netbeans nos proporciona una utilidad (*Debug > Check for deadlocks*) que comprueba si hay hilos que est\xE9n en un interbloqueo, inform\xE1ndonos de los monitores que tienen bajo su control y de los monitores para los que est\xE1n realizando alguna espera.\r
`]},{title:"3.6 Anexo II - HashMap hoja de referencia de los alumnos",headers:[{level:2,title:"A. Definici\xF3n y creaci\xF3n",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de HashMap",slug:"a-1-constructores-de-hashmap",link:"#a-1-constructores-de-hashmap",children:[]}]},{level:2,title:"B. M\xE9todos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creaci\xF3n de un HashMap",slug:"b-1-creacion-de-un-hashmap",link:"#b-1-creacion-de-un-hashmap",children:[]},{level:3,title:"B.2. A\xF1adir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si una clave o un valor existen",slug:"b-3-comprobar-si-una-clave-o-un-valor-existen",link:"#b-3-comprobar-si-una-clave-o-un-valor-existen",children:[]},{level:3,title:"B.4. Acceder a las partes del mapa",slug:"b-4-acceder-a-las-partes-del-mapa",link:"#b-4-acceder-a-las-partes-del-mapa",children:[]},{level:3,title:"B.5. Acceder a un elemento del mapa",slug:"b-5-acceder-a-un-elemento-del-mapa",link:"#b-5-acceder-a-un-elemento-del-mapa",children:[]},{level:3,title:"B.6. Otras funciones de utilidad",slug:"b-6-otras-funciones-de-utilidad",link:"#b-6-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. A\xF1adir datos a un HashMap",slug:"c-anadir-datos-a-un-hashmap",link:"#c-anadir-datos-a-un-hashmap",children:[{level:3,title:"C.1. A\xF1adir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. A\xF1adir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. A\xF1adir / eliminar elementos desde c\xF3digo",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la colecci\xF3n",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el m\xE9todo forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la colecci\xF3n",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. B\xFAsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. B\xFAsqueda por clave o usando los m\xE9todos de la clase",slug:"e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. B\xFAsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. B\xFAsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. B\xFAsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtenci\xF3n de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenaci\xF3n de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar por clave",slug:"g-1-ordenar-por-clave",link:"#g-1-ordenar-por-clave",children:[]},{level:3,title:"G.2. Ordenar usando m\xE9todos de Collection",slug:"g-2-ordenar-usando-metodos-de-collection",link:"#g-2-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.3. Ordenar con expresiones lambda",slug:"g-3-ordenar-con-expresiones-lambda",link:"#g-3-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.4. Ordenar con API Stream",slug:"g-4-ordenar-con-api-stream",link:"#g-4-ordenar-con-api-stream",children:[]}]}],path:"/es/unit3/hashmap_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.6 Anexo II - HashMap hoja de referencia de los alumnos\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.6 Anexo II - HashMap hoja de referencia de los alumnos" />\r
\r
# 3.6 Anexo II - HashMap hoja de referencia de los alumnos\r
\r
::: info Autor\xEDa\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del m\xF3dulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la informaci\xF3n a la que podr\xE9is acceder durante los ex\xE1menes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definici\xF3n y creaci\xF3n\r
\r
Una colecci\xF3n representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almac\xE9n donde poder guardarlos. En Java, se emplea la interfaz gen\xE9rica \`Collection\` para este prop\xF3sito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de m\xE9todos comunes, como pueden ser: a\xF1adir, eliminar, obtener el tama\xF1o de la colecci\xF3n.\r
\r
Partiendo de la interfaz gen\xE9rica Collection extienden otra serie de interfaces gen\xE9ricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
Un HashMap b\xE1sicamente designa claves \xFAnicas para los valores correspondientes que se pueden recuperar en cualquier punto dado, es decir, nos permite almacenar elementos asociando a cada clave un valor.\r
\r
Para cada clave tenemos un valor asociado. Podemos despu\xE9s buscar f\xE1cilmente un valor para una determinada clave. Las claves en el diccionario no pueden repetirse.\r
\r
### A.1. Constructores de HashMap\r
\r
HashMap proporciona 4 constructores que definen la capacidad inicial de la colecci\xF3n y en qu\xE9 momento debe redimensionarse. Son par\xE1metros para mejorar el rendimiento en el uso del HashMap.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de HashMap con una capacidad inicial de 16 y un factor de carga de 0,75.\r
HashMap<Integer, String> hm1 = new HashMap<>(); \r
\r
// HashMap(int initialCapacity). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga de 0,75. \r
HashMap<Integer, String> hm1 = new HashMap<>(10); \r
\r
// HashMap(int initialCapacity, float loadFactor). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga especificados. \r
HashMap<Integer, String> hm1 = new HashMap<>(5, 0.75f); \r
\r
//HashMap(Mapa de mapas) . Crea una instancia de HashMap con las mismas asignaciones que el mapa especificado. \r
HashMap<Integer, String> hm1 = new HashMap<>();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. M\xE9todos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendr\xEDamos con la ejecuci\xF3n de estos m\xE9todos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "Garc\xEDa", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Mart\xEDnez", 65, 1.84d, 82, "Hombre");\r
\`\`\`\r
\r
### B.1. Creaci\xF3n de un HashMap\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un HashMap con claves de tipo String y valores de tipo Persona\r
  HashMap<String,Persona> DNIs = new HashMap<>();\r
\`\`\`\r
\r
### B.2. A\xF1adir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // Element.put(k,v) - A\xF1ade un par clave-valor al mapa.\r
  DNIs.put("390543M",p);\r
  // Element.remove(Object key) - Removes the key and his value.\r
  DNIs.remove("298423Z");// Will remove (\u201C390543M\u201D, p1) from the map.\r
\`\`\`\r
\r
::: warning Clave ya existente\r
Si ya existe un elemento con la misma clave en el mapa, el m\xE9todo put reemplaza el valor existente por el nuevo.\r
Podemos evitarlo comprobando previamente si ya existe esa clave o con el m\xE9todo **DNIs.putIfAbsent(k,v)**.\r
:::\r
\r
### B.3. Comprobar si una clave o un valor existen\r
\r
\`\`\`java:no-line-numbers\r
  // Element.containsKey(Key) \u2013 Comprueba si existe la clave dada\r
  DNIs.containsKey("390543M");\r
  // Element.containsValue(Value) \u2013 Comprueba si existe el valor dado asociado a alguna clave\r
  DNIs.containsValue(p2);\r
\`\`\`\r
\r
### B.4. Acceder a las partes del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.keySet() - Obtiene el conjunto de claves del mapa\r
  Set<String> claves = DNIs.keySet();\r
  // Element.values() - Obtiene el conjunto de valores almacenados en el mapa\r
  Collection<Persona> valores = DNIs.values();\r
  // Element.entrySet() - Obtiene el conjunto de pares clave-valor del mapa\r
  Set<Entry<String,Persona>> tuplas = DNIs.entrySet();\r
\`\`\`\r
\r
### B.5. Acceder a un elemento del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.get(Key) - Obtiene el valor asociado a la clave\r
  Persona p = DNIs.get("390543")\r
\`\`\`\r
\r
### B.6. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Element.size() - Devuelve el n\xFAmero de elementos en el mapa\r
  int size = DNIs.size();\r
  //Element.clear() - Elimina todas las asignaciones y vac\xEDa el mapa\r
  DNIs.clear();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. A\xF1adir datos a un HashMap\r
\r
::: info Orden de los elementos en el HashMap\r
Cuando a\xF1adimos elementos a una HashMap, el orden de inserci\xF3n no se conserva. Internamente, para cada elemento, se genera un hash separado y los elementos se indexan en funci\xF3n de este hash para hacerlo m\xE1s eficiente. Antes de a\xF1adir un elemento, como se ha avisado antes, es recomendable comprobar si ya existe para no sustituirlo\r
:::\r
\r
### C.1. A\xF1adir elementos desde el constructor\r
\r
A la hora de crear el Hashmap, podemos a\xF1adirle datos, usando la sintaxis del doble corchete o bien con la construcci\xF3n Map.of\r
\r
\`\`\`java:no-line-numbers\r
  // Crea un nuevo mapa y a la vez lo inicializa con valores  \r
  HashMap<String, Persona> map1 = new HashMap<>() {{\r
    put("390543M", p1);\r
    put("298423Z", p2);\r
  }};\r
  // En este caso indicamos los pares clave valor como si de un array se tratase\r
  // De esta forma podemos a\xF1adir hasta un m\xE1ximo de 10 elementos\r
  HashMap<String, Persona> map2 = new HashMap<>(\r
    Map.of("390543M", p1, "298423Z", p2)\r
  );\r
\`\`\`\r
\r
### C.2. A\xF1adir elementos desde otras colecciones\r
\r
Al ser una colecci\xF3n compuesta por una clave y un valor, la inicializaci\xF3n se limita a los tipos de colecciones que tienen una estructura similar.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del c\xF3digo anterior, creamos un nuevo mapa a partir de map2\r
  HashMap<String, Persona> map3 = new HashMap<>(map2);\r
  // O bien copiando todos los pares clave-valor\r
  map3.putAll(map2);  \r
\`\`\`\r
\r
### C.3. A\xF1adir / eliminar elementos desde c\xF3digo\r
\r
\`\`\`java:no-line-numbers\r
  // A\xF1adir y si existe la clave reemplazarlo\r
  DNIs.put("390543M", p1);\r
  // A\xF1adir s\xF3lo si la clave no existe\r
  DNIs.putIfAbsent("390543M", p1);\r
  // Eliminar un elemento. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = map3.remove("390543M");  \r
  // Eliminar un par clave-valor. Si existe la tupla, la elimina y devuelve true, si no devuelve false\r
  boolean existe = map3.remove("390543M", p1);  \r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la colecci\xF3n\r
\r
Vamos a preparar un HashMap para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap creation\r
  HashMap<String, Persona> grupoPersonas = new HashMap<>() {{\r
          put("12345678A", new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
          put("23456789B", new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
          put("34567890C", new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
          put("45678901D", new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
          put("56789012E", new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
          put("67890123F", new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\`\`\`\r
\r
::: info Tipos de valores\r
Vamos a mostrar ejemplos de c\xF3mo recorrer cada uno de los elementos que componen el HashMap, claves, valores y pares clave-valor.\r
\r
.entrySet() - devuelve el conjunto de pares clave-valor\r
\r
.keySet() - devuelve el conjunto de claves\r
\r
.values() - devuelve la colecci\xF3n de valores\r
:::\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por \xEDndice, por lo que vamos a necesitar una forma de obtener el \xEDndice (i) de cada elemento para recorrer el HashMap.\r
\r
En este caso, vamos a usar el \xEDndice de la clave, a trav\xE9s del m\xE9todo toArray.\r
\r
::: warning Orden de los elementos en el HashMap\r
Es importante recordar y tener en cuenta que los elementos en un HashMap se ordenan autom\xE1ticamente en base a una funci\xF3n Hash (resumen) que permite realizar una b\xFAsqueda muy r\xE1pida sobre la clave. Por lo tanto, no podemos esperar que el recorrido por \xEDndice coincida con el orden en el que los elementos se a\xF1aden al mapa.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(map.keySet().toArray()[i]));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el HashMap es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : colecci\xF3n)\r
\r
\`\`\`java:no-line-numbers\r
  // Recorremos la estructura obteniendo la tupla (k,v) en cada iteraci\xF3n\r
  for (Map.Entry<String, Persona> entry : grupoPersonas.entrySet()) {\r
        System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());\r
  }\r
\`\`\`\r
\r
o bien para ir mostrando las claves\r
\r
\`\`\`java:no-line-numbers\r
  for (String key : grupoPersonas.keySet()) {\r
    System.out.println("DNI = " + key);\r
  }\r
\`\`\`\r
\r
o los valores\r
\r
\`\`\`java:no-line-numbers\r
  for (Person value : grupoPersonas.values()) {\r
    System.out.println("Value = " + value);\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una colecci\xF3n y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un m\xE9todo iterator() que devuelve una instancia de Iterator para recorrer la colecci\xF3n.\r
\r
Iterator tiene 4 m\xE9todos:\r
\r
- **hasNext()** - devuelve true si hay un elemento m\xE1s en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el \xFAltimo elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la acci\xF3n indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la colecci\xF3n\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.values().iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el m\xE9todo forEach con expresiones lambda\r
\r
En este caso aprovechamos el m\xE9todo foreach de las colecciones para poder realizar una acci\xF3n concreta sobre cada uno de los elementos de la misma\r
\r
\`\`\`java:no-line-numbers\r
  // Pares (clave,valor)\r
  grupoPersonas.forEach((k,v) -> System.out.println("Clave: " + k + ", Values: " + v));\r
  // Claves\r
  grupoPersonas.keySet().forEach(k -> System.out.println("Clave: " + k));\r
  // Valores\r
  grupoPersonas.values().forEach(v -> System.out.println("Values: " + v));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la colecci\xF3n\r
\r
Mientras se est\xE1 recorriendo una colecci\xF3n, no con todos los tipos de bucles se puede modificar (a\xF1adir/eliminar elementos) de la colecci\xF3n. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendr\xEDamos problemas. Al acceder por \xEDndice, podemos a\xF1adir o eliminar elementos mientras se recorre la colecci\xF3n.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.keySet().toArray()[i].equals("23456789B")) {\r
      grupoPersonas.remove(grupoPersonas.entrySet().toArray()[i]);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, s\xF3lo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colecci\xF3n.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Map.Entry<String, Persona> p : grupoPersonas.entrySet()) {\r
    if (p.getKey().equals("34567890C")) {\r
      personas.remove(p.getKey());\r
    }\r
    System.out.println("Clave: " + p.getKey() + " Valor: " + p.getValue().toString());\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Si usamos el m\xE9todo remove para eliminar elementos de la colecci\xF3n mientras la recorremos, podremos hacerlo sin que se genere ninguna excepci\xF3n.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Entry<String, Persona>> iterator = grupoPersonas.entrySet().iterator();\r
  while (iterator .hasNext()) {\r
    Map.Entry<String, Persona> p = (Map.Entry<String, Persona>) iterator.next();\r
    if (p.getKey().equals("12345678A")) {\r
      // Si borramos usando iterator.remove o el m\xE9todo remove(key) de HashMap, funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el m\xE9todo forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, s\xF3lo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colecci\xF3n.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.keySet().forEach((k) -> {if (k.equals("34567890C")) grupoPersonas.remove(k);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la colecci\xF3n, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.values().forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. B\xFAsqueda de elementos\r
\r
Para buscar elementos en un HashMap hay distintas formas de hacerlo. Desde los propios m\xE9todos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. B\xFAsqueda por clave o usando los m\xE9todos de la clase\r
\r
La clase HashMap nos ofrece diferentes alternativas para buscar y/o saber si un elemento est\xE1 presente en la colecci\xF3n. As\xED, podemos usar los m\xE9todos\r
\r
\`\`\`java:no-line-numbers\r
  // A partir de una clave, obtener el valor\r
  grupoPersonas.get("34567890C");\r
  // O simplemente comprobar si existe esa clave o ese valor antes de buscarlo\r
  grupoPersonas.containsKey("34567890C");\r
  grupoPersonas.containsValue(person);\r
\`\`\`\r
\r
### E.2. B\xFAsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la colecci\xF3n hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber m\xE1s de un elemento que cumpla el criterio de b\xFAsqueda\r
  Iterator<Map.Entry<String, Persona>> it = grupoPersonas.entrySet().iterator();\r
  while (it.hasNext()) {\r
    Map.Entry<String, Persona> entry = it.next();\r
    if (((Persona)entry.getValue()).getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + entry.getKey() + ", Value: " +\r
      entry.getValue());\r
    break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. B\xFAsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber m\xE1s de un elemento que cumpla el criterio de b\xFAsqueda\r
  grupoPersonas.forEach((k, v) -> {\r
    if (v.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + k + ", Value: " + v);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. B\xFAsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gesti\xF3n de las colecciones.\r
Podemos emplear varios m\xE9todos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcolecci\xF3n\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber m\xE1s de un elemento que cumpla el criterio de b\xFAsqueda\r
\r
  // Obtener un submapa con los elementos que cumplan el criterio\r
  grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("abc"))\r
    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Entry<String, Persona> p : grupoPersonas.entrySet().stream()\r
      .filter(k -> k.getKey().equals("abc"))\r
      .collect(Collectors.toList())) {\r
          System.out.println(p.getValue());   // Sacamos el valor de la tupla <clave,valor>\r
  }\r
\r
  for (Persona p : grupoPersonas.entrySet().stream()\r
      .filter((k) -> k.getKey().equals("98761234D"))\r
      .map(Map.Entry::getValue)         // Cogemos s\xF3lo los valores del entryMap\r
      .collect(Collectors.toList())) {\r
          System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cu\xE1ntos cumplen el criterio de b\xFAsqueda\r
  grupoPersonas.entrySet().stream().filter(k -> k.getKey().equals("abc")).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Entry<String,Persona>> s = grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("6780123F"))\r
    .findFirst();\r
  \`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtenci\xF3n de subcolecciones\r
\r
Lo podemos considerar un tipo especial de b\xFAsqueda en el que el objetivo es conseguir una colecci\xF3n con los elementos que cumplan un determinado criterio.\r
\r
As\xED, la forma de buscar es id\xE9ntica a la del apartado anterior, pero en este caso lo que obtendremos de esa b\xFAsqueda ser\xE1 un nuevo tipo de colecci\xF3n, no necesariamente otro HashMap.\r
\r
### F.1. Subcolecciones usando bucles\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String,Persona> personas2 = new HashMap<String,Persona>();\r
  for (Entry<String, Persona> e : grupoPersonas.entrySet()) {\r
    if(e.getKey().endsWith("F")) {\r
      personas2.put(e.getKey(), e.getValue());\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
En este ejemplo obtenemos un nuevo HashMap, pero tambi\xE9n podr\xEDamos guardar la informaci\xF3n en un ArrayList o en cualquier otro tipo de estructura.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas2 = new HashMap<String, Persona>();\r
  grupoPersonas.forEach((k, v) -> {\r
    if (k.endsWith("F")) {\r
      grupoPersonas2.put(k, v);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener diferentes tipos de subcolecciones. Con API Stream podemos filtrar, hacer subconjuntos y guardar el resultado usando diferentes formas de .collect, que dar\xE1n como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap de Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas3 = (HashMap<String, Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // Lista de Personas cuyo DNI acaba en "F"\r
  List<Persona> listaPersonas3 = (List<Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toList());\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenaci\xF3n de elementos\r
\r
::: danger HashMap no garantiza el orden de los elementos\r
Como ya hemos comentado anteriormente, un HashMap es una estructura de datos en la que el orden de los elementos no est\xE1 garantizado. Es por eso que si queremos mantener una copia ordenada de los elementos, deberemos recurrir a otros tipos de colecciones que s\xED garantizan el orden.\r
:::\r
\r
### G.1. Ordenar por clave\r
\r
Hay un tipo especial de map, TreeMap, en el que los elementos se ordenan siguiendo el orden natural de las claves. Por lo tanto es la opci\xF3n ideal si queremos tener los elementos ordenados por clave.\r
\r
\`\`\`java:no-line-numbers\r
  // As\xED podemos recorrer el TreeMap y mostrar los elementos ordenados por clave\r
  TreeMap<String, Persona> grupoPersonasOrdenado = new TreeMap<>(grupoPersonas);\r
 \r
  Iterator it=grupoPersonasOrdenado.keySet().iterator();\r
  while(it.hasNext())\r
  {\r
    int key=(int)itr.next();\r
    System.out.println("Key: "+key+" Element: "+hashMap.get(key));\r
  }\r
\`\`\`\r
\r
### G.2. Ordenar usando m\xE9todos de Collection\r
\r
Si lo que queremos es tener el conjunto de claves o valores ordenados por separado, la forma m\xE1s f\xE1cil es obtener una lista y ordenarla usando el m\xE9todo sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Para las claves\r
  List<String> clavesGrupoPersonas = new ArrayList<>(grupoPersonas.keySet());\r
  Collections.sort(clavesGrupoPersonas);\r
\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas = new ArrayList<>(grupoPersonas.values());\r
  // Ordena seg\xFAn el m\xE9todo compareTo sobrescrito al implementar el interfaz Comparable\r
  Collections.sort(valoresGrupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(valoresGrupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su m\xE9todo \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos m\xE1s adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.3. Ordenar con expresiones lambda\r
\r
Si usamos una lista, no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparaci\xF3n que queremos hacer como par\xE1metro del m\xE9todo sort\r
\r
\`\`\`java:no-line-numbers\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas2 = new ArrayList<>(grupoPersonas.values());\r
  // Indicamos la comparaci\xF3n que queremos hacer. Podemos usar compareTo o definir\r
  // nuestro propio comparador\r
  Collections.sort(valoresGrupoPersonas2, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(valoresGrupoPersonas2);      \r
\`\`\`\r
\r
### G.4. Ordenar con API Stream\r
\r
Con API Stream usamos tambi\xE9n el m\xE9todo sorted para indicar qu\xE9 comparaci\xF3n se debe realizar. Tenemos varias opciones en funci\xF3n del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el m\xE1s flexible es aquel en el que indicamos, mediante una expresi\xF3n lambda qu\xE9 comparaci\xF3n realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en un LinkedHashMap que s\xED garantiza el orden\r
  Map<String, Persona> sortedMap = grupoPersonas.entrySet().stream()\r
      // En este caso ordenamos por apellido, ascendente.\r
      .sorted((e1, e2) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
      //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      .collect(Collectors.toMap(Entry::getKey, Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));\r
\`\`\`\r
\r
::: info Encadenar m\xE9todos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcolecci\xF3n con los resultados.\r
\r
Es lo m\xE1s parecido que vamos a encontrar a una consulta SQL para los datos de una colecci\xF3n cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instant\xE1neas, sin lugar a bugs, con muy poco c\xF3digo.\r
:::\r
`]},{title:"3 Introducci\xF3n",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit3/",pathLocale:"/es/",extraFields:[`---\r
title: 3 Introducci\xF3n\r
---\r
\r
# Tema 3. Programaci\xF3n multihilo\r
\r
Tras aprender los conceptos b\xE1sicos de la programaci\xF3n concurrente y ver c\xF3mo los procesos pueden colaborar para conseguir multitarea, en este tema vamos a poner la mirada dentro de un proceso.\r
\r
La ejecuci\xF3n de un proceso comienza con un \xFAnico hilo, pero se pueden crear m\xE1s sobre la marcha. Los distintos hilos de un mismo proceso comparten:\r
\r
- El espacio de memoria asignado al proceso\r
- La informaci\xF3n de acceso a ficheros (incluyendo stdin, stdout y stderr).\r
\r
Las caracter\xEDsticas anteriores son las que los diferencias de los procesos. En cambio, cada hilo tiene sus propios valores para\r
\r
- Los registros del procesador\r
- El estado de su pila (stack), donde entre otras cosas se almacenan las variables locales.\r
  \r
Por lo tanto, vamos a utilizar los threads para realizar programaci\xF3n concurrente y/o paralela dentro de un proceso.\r
\r
Aunque los hilos se ejecutan en el contexto de un procesos, cada uno tiene su TCB (Tread Control Block) que es sensiblemente m\xE1s peque\xF1os que el PCB (Process Control Block) porque entre los hilos comparten gran parte de ese PCB. Por eso veremos que a los hilos tambi\xE9n se le llama \`lightweight processes\` (procesos ligeros) y por tanto los cambios de contexto en el procesador son mucho menos costosos para los hilos que para los procesos.\r
\r
::: warning Hilos: comunicaci\xF3n vs sincronizaci\xF3n \r
Por todo lo comentado, el intercambio de informaci\xF3n entre hilos es sencillo, dado que los distintos hilos de un mismo proceso comparten la memoria asignada al proceso.\r
\r
Sin embargo, los hilos deben coordinarse para el acceso a los contenidos de la memoria y a los ficheros, lo cual hace que esa coordinaci\xF3n y sincronizaci\xF3n sea la parte complicada de uso.\r
\r
De eso va este tema.\r
:::\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Conocer las t\xE9cnicas b\xE1sicas para desarrollar aplicaciones multihilo en Java\r
- Crear y lanzar varios hilos que compartan informaci\xF3n\r
- Depurar aplicaciones multihilo\r
- Usar los m\xE9todos de sincronizaci\xF3n para procesos y subprocesos\r
- Compartir informaci\xF3n entre los hilos de un proceso\r
- Aprender acerca de los problemas de acceso a memoria compartida\r
- Usar diferentes t\xE9cnicas de programaci\xF3n para sincronizar la ejecuci\xF3n de los threads.\r
`]},{title:"3.3 Modelo productor-consumidor",headers:[{level:2,title:"3.3.1. Esquema de sincronizaci\xF3n y comunicaci\xF3n de hilos",slug:"_3-3-1-esquema-de-sincronizacion-y-comunicacion-de-hilos",link:"#_3-3-1-esquema-de-sincronizacion-y-comunicacion-de-hilos",children:[]},{level:2,title:"3.3.2 Clase Principal",slug:"_3-3-2-clase-principal",link:"#_3-3-2-clase-principal",children:[]},{level:2,title:"3.3.3 Clase Productor y Consumidor",slug:"_3-3-3-clase-productor-y-consumidor",link:"#_3-3-3-clase-productor-y-consumidor",children:[]},{level:2,title:"3.3.4 Clase Compartida. Sincronizaci\xF3n de hilos",slug:"_3-3-4-clase-compartida-sincronizacion-de-hilos",link:"#_3-3-4-clase-compartida-sincronizacion-de-hilos",children:[]}],path:"/es/unit3/producer-consumer.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.3 Modelo productor-consumidor\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.3 Modelo productor-consumidor" />\r
\r
# 3.3 Modelo productor-consumidor\r
\r
[[toc]]\r
\r
## 3.3.1. Esquema de sincronizaci\xF3n y comunicaci\xF3n de hilos\r
\r
La sincronizaci\xF3n de threads implica disponer de mecanismos que permitan asegurar que no se producen situaciones de \`inanici\xF3n o starvation\` (bloqueo de hilos como consecuencia del acceso a recursos compartidos limitados), \`interbloqueos\` (espera por parte de los hilos cuando una condici\xF3n no puede ser satisfecha) y que, por lo tanto, se opera de forma correcta con los recursos compartidos por hilos concurrentes.\r
\r
En esta secci\xF3n vamos a ejemplificar la compartici\xF3n de recursos a trav\xE9s de un objeto contenedor (objeto compartido) mediante el famoso algoritmo del Productor-Consumidor que podemos ver resumido en [Wikipedia](https://es.wikipedia.org/wiki/Problema_productor-consumidor).\r
\r
Si no se implementasen medidas de control, ya hemos visto que podr\xEDan darse situaciones an\xF3malas como:\r
\r
- El consumidor puede obtener los elementos producidos m\xE1s de una vez, excediendo la producci\xF3n del mismo (poder dejar la cuenta en n\xFAmeros rojos en el ejemplo del banco, o que un lector pueda leer un libro antes de estar terminado).\r
- El productor sea m\xE1s r\xE1pido que el Consumidor y genere m\xE1s informaci\xF3n de la que el sistema pueda almacenar, o bien parte de la informaci\xF3n que genere se pierda sin que un Consumidor la haya recuperado.\r
- El Consumidor sea m\xE1s r\xE1pido que el Productor y puede terminar consumiendo dos o m\xE1s veces el mismo valor, generando informaci\xF3n inconsistente en el sistema.\r
\r
Todas estas circunstancias son las que conocemos como condiciones de carrera o \`race conditions\`.\r
\r
El esquema de clases representado por este modelo se repite fielmente entre los diferentes ejercicios que vamos a realizar, es lo que denominamos el modelo Productor-Consumidor.\r
\r
![Producer-Consumer](./../../media/unit3/ProducerConsumer.png)\r
\r
Este modelo se basa en tres clases, aunque dependiendo del problema, podemos encontrarnos que no tenemos **productor** o **consumidor**.\r
\r
::: info Modelo como patr\xF3n de dise\xF1o\r
Es importante que nos ajustemos al esquema presentado en el modelo.\r
\r
Como ya se ha dicho, a veces no habr\xE1 productor, otras no estar\xE1 el consumidor, en otras el c\xF3digo de bloqueo estar\xE1 s\xF3lo en una de las clases, pero no debemos inventar ni a\xF1adir nada al esquema, debemos encajar el problema a solucionar dentro del c\xF3digo proporcionado.\r
:::\r
\r
## 3.3.2 Clase Principal\r
\r
> La clase principal siempre va a tener la misma estructura. El siguiente c\xF3digo se puede usar como plantilla\r
\r
En esta clase se declara el objeto o propiedad que van a compartir el productor y el consumidor. Este objeto es a trav\xE9s del que se realiza la comunicaci\xF3n, sincronizaci\xF3n e intercambio de informaci\xF3n entre los hilos.\r
\r
Aqu\xED se representa como un objeto, aunque puede ser una Colecci\xF3n o cualquier estructura de datos que puedan compartir los hilos.\r
\r
\`\`\` java {4,5,6}\r
public class ClasePrincipal { \r
\r
    public static void main(String[] args) {    \r
        ClaseCompartida objetoCompartido = new ObjetoCompartido();\r
        Productor p  = new Productor(objetoCompartido);\r
        Consumidor c  = new Consumidor(objetoCompartido);\r
        productor.start();\r
        consumidor.start();\r
\r
        // No es obligatorio, pero en ocasiones puede interesar que la ClasePrincipal\r
        // espere a que acaben los hilos\r
        productor.join();\r
        consumidor.join();\r
\r
        // Acciones a realizar una vez hayan acabado el productor y el consumidor\r
    }\r
    \r
}\r
\`\`\`\r
\r
::: warning N\xFAmero de hilos por tipo\r
En el ejemplo se crea un hilo de cada tipo. Esto no tiene porqu\xE9 ser as\xED.\r
\r
Cada problema determinar\xE1 el n\xFAmero de hilos *Productores* y *Consumidores* necesarios, por lo que ser\xE1 en este m\xE9todo main, o en alg\xFAn otro m\xE9todo de la *ClasePrincipal* donde se realice la gesti\xF3n de los hilos.\r
\r
De igual forma, depender\xE1 de cada problema si el hilo principal debe esperar a que el resto finalice o no.\r
:::\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.3 Clase Productor y Consumidor\r
\r
> Por otro lado vamos a tener la clase del **productor** y del **consumidor** que se encargan de realizar las llamadas necesarias a los m\xE9todos del objeto compartido que reciben como par\xE1metro.\r
\r
Estas dos clases son las que van a tener, dentro del m\xE9todo **run**, la l\xF3gica de la aplicaci\xF3n, accediendo al objeto compartido, modificando las propiedades compartidas entre los diferentes hilos (productores y/o consumidores) y actualizando el estado del objeto compartido para que module su funcionalidad.\r
\r
\`\`\` java {2,5,15}\r
public class Consumidor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Consumidor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecuci\xF3n del m\xE9todo run estar\xE1 normalmente gestionada por un bucle\r
        // que controlar\xE1 el ciclo de vida del hilo y se adaptar\xE1 al problema.\r
        // En el caso de simulaciones se har\xE1n esperas proporcionales.\r
        try {\r
            // C\xF3digo que hace el hilo consumidor\r
            objetoCompartido.accionDeConsumir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
}    \r
\`\`\`\r
\r
\`\`\` java {2,5,15}\r
public class Productor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Productor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecuci\xF3n del m\xE9todo run estar\xE1 normalmente gestionada por un bucle\r
        // que controlar\xE1 el ciclo de vida del hilo y se adaptar\xE1 al problema.\r
        // En el caso de simulaciones se har\xE1n esperas proporcionales.\r
        try {\r
            // C\xF3digo que hace el hilo productor\r
            objetoCompartido.accionDeProducir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
} \r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.4 Clase Compartida. Sincronizaci\xF3n de hilos\r
\r
 El modelo se completa con la clase compartida. Aqu\xED vamos a crear los m\xE9todos a los que acceden productores y consumidores y, adem\xE1s, vamos a realizar la sincronizaci\xF3n entre hilos para que no se produzcan \`condiciones de carrera\`.\r
\r
\`\`\` java {2,9,11,14,21,25,28,30,33,40,44}\r
class ClaseCompartida {\r
    int valorAccedidoSimultaneamente;\r
    \r
    ClaseCompartida() {\r
        // Se inicializa el valor\r
        this.valorAccedidoSimultaneamente = 0;\r
    }\r
\r
    public synchronized void accionDeConsumir() {\r
        // Si no se cumple la condici\xF3n para poder consumir, el consumidor debe esperar\r
        while (valorAccedidoSimultaneamente() == 0) {\r
            try {\r
                System.out.println("Consumidor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizar\xE1 la gesti\xF3n de la Interrupci\xF3n\r
            }\r
        }\r
                \r
        // Cuando se ha cumplido la condici\xF3n para consumir, el consumidor consume\r
        valorAccedidoSimultaneamente--;\r
        System.out.printf("Se ha consumido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
    \r
    public synchronized void accionDeProducir () {\r
        // Si no se cumple la condici\xF3n para poder producir, el productor debe esperar\r
        while (valorAccedidoSimultaneamente() > 10) {\r
            try {\r
                System.out.println("Productor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizar\xE1 la gesti\xF3n de la Interrupci\xF3n                \r
            }\r
        }\r
        \r
        // Cuando se ha cumplido la condici\xF3n para producir, el productor produce\r
        valorAccedidoSimultaneamente++;\r
        System.out.printf("Se ha producido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
\`\`\`\r
\r
Lo interesante del c\xF3digo anterior, como ya hemos visto con anterioridad, es la pareja de m\xE9todos \`wait / notifyAll\`, junto con el modificador \`synchronized\`.\r
\r
- Cuando se llama a un m\xE9todo **synchronized** este m\xE9todo se ejecuta s\xED y solo s\xED no hay otro hilo ejecutando otro m\xE9todo **synchronized** \`del mismo objeto\`. Si se diese ese caso, el hilo se quedar\xE1 en espera hasta que otro hilo libere el monitor. En ese momento todos los hilos que est\xE9n esperando se despiertan y s\xF3lo uno de ellos, el que consigue el monitor, puede ejecutar el c\xF3digo **synchronized" en exclusi\xF3n mutua.\r
- Cuando se hace una llamada al m\xE9todo **wait**, un hilo se queda en espera y, adem\xE1s, libera el bloqueo del monitor. El hilo se quedar\xE1 en espera hasta que otro hilo ejecute una llamada de se\xF1alizaci\xF3n (**notify/notifyAll**).\r
- Cuando se hace una llamada al m\xE9todo **notify** o **notifyAll**, uno o todos los hilos que est\xE1n en espera por haber hecho **wait** se despiertan y pasan a esperar poder tomar el control del bloqueo del **synchronized**. A partir de ese momento, de forma aleatoria, uno de ellos o de los que ya estaban en la cola del bloqueo **synchronized** toma el control y o bien empieza o bien sigue ejecut\xE1ndose por donde se qued\xF3 (en caso de que hubiese llamado a **wait**).\r
  \r
> Con los m\xE9todos **wait**, **notify/notifyAll** y los bloques de c\xF3digo **synchronized** se consigue evitar que varios hilos puedan modificar a la vez una variable *(Ver l\xEDneas 21 y 40 del ejemplo anterior)*.\r
\r
::: info Resumen del modelo Productor-Consumidor\r
El modelo Productor-Consumidor original trabaja con un buffer en el que el Productor va depositando informaci\xF3n y el Consumidor la va sacando, de forma que el buffer nunca se llene ni se pueda leer si est\xE1 vac\xEDo.\r
\r
En nuestro ejemplo, lo hemos simplificado al uso de una variable que nunca puede exceder el valor de 10 ni ser inferior a 0.\r
\r
Como ya hemos dicho, esa variable puede ser cualquier tipo de dato, y el c\xF3digo de las clases variar\xE1 en funci\xF3n de ello, para adaptarlo al problema y al control del tipo de dato utilizado.\r
\r
Adem\xE1s, las condiciones o estados que se utilizan para las esperas y las actualizaciones ser\xE1 lo que nosotros, como programadores, tengamos que adaptar al modelo para hacerlo funcionar en situaciones diferentes.\r
:::\r
`]},{title:"3.1. Clases Java para la gesti\xF3n de hilos",headers:[{level:2,title:"3.1.1. El interfaz Runnable",slug:"_3-1-1-el-interfaz-runnable",link:"#_3-1-1-el-interfaz-runnable",children:[{level:3,title:"Clase Java que implementa la interfaz Runnable",slug:"clase-java-que-implementa-la-interfaz-runnable",link:"#clase-java-que-implementa-la-interfaz-runnable",children:[]},{level:3,title:"Implementaci\xF3n con clase an\xF3nima de la interfaz Runnable",slug:"implementacion-con-clase-anonima-de-la-interfaz-runnable",link:"#implementacion-con-clase-anonima-de-la-interfaz-runnable",children:[]},{level:3,title:"Implementaci\xF3n de Runnable a trav\xE9s de una expresi\xF3n Lambda",slug:"implementacion-de-runnable-a-traves-de-una-expresion-lambda",link:"#implementacion-de-runnable-a-traves-de-una-expresion-lambda",children:[]},{level:3,title:"Llamar al m\xE9todo run de una clase que implemente Runnable",slug:"llamar-al-metodo-run-de-una-clase-que-implemente-runnable",link:"#llamar-al-metodo-run-de-una-clase-que-implemente-runnable",children:[]}]},{level:2,title:"3.1.2 Thread subclass",slug:"_3-1-2-thread-subclass",link:"#_3-1-2-thread-subclass",children:[]},{level:2,title:"3.1.3 Starting a Thread With a Runnable",slug:"_3-1-3-starting-a-thread-with-a-runnable",link:"#_3-1-3-starting-a-thread-with-a-runnable",children:[{level:3,title:"Subclass or Runnable?",slug:"subclass-or-runnable",link:"#subclass-or-runnable",children:[]}]},{level:2,title:"3.1.4 M\xE9todos de la clase java.lang.Thread",slug:"_3-1-4-metodos-de-la-clase-java-lang-thread",link:"#_3-1-4-metodos-de-la-clase-java-lang-thread",children:[{level:3,title:"C\xF3mo pausar un hilo",slug:"como-pausar-un-hilo",link:"#como-pausar-un-hilo",children:[]},{level:3,title:"Gesti\xF3n de la prioridad de los hilos",slug:"gestion-de-la-prioridad-de-los-hilos",link:"#gestion-de-la-prioridad-de-los-hilos",children:[]}]}],path:"/es/unit3/runnable.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.1. Clases Java para la gesti\xF3n de hilos\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.1. Clases Java para la gesti\xF3n de hilos" />\r
\r
# 3.1. Clases Java para la gesti\xF3n de hilos\r
\r
[[toc]]\r
\r
## 3.1.1. El interfaz Runnable\r
\r
Un hilo (thread en adelante) puede ejecutar c\xF3digo Java dentro de tu aplicaci\xF3n Java.\r
\r
![alt_text](../../media/unit3/Single_vs_MultiThreaded_Approaches.jpg)\r
\r
Cuando un programa Java se lanza (se convierte en un proceso) empieza a ejecutarse por su m\xE9todo main() que lo ejecuta el thread principal (main), un hilo especial creado por la Java VM para ejecutar la aplicaci\xF3n. Desde un proceso se pueden crear e iniciar tantos threads como necesites. Estos hilos ejecutar\xE1n partes del c\xF3digo de la aplicaci\xF3n en paralelo con el thread principal\r
\r
Los thread en Java son objetos como cualquier otro. Un thread es una instancia de la clase java.lang.Thread, o instancias de clases que heredan de \xE9sta. Como ya hemos icho, adem\xE1s de ser objetos, los threads tienen la capacidad de ejecutar c\xF3digo.\r
\r
La forma m\xE1s usada para indicar a un thread qu\xE9 codigo queremos que ejecute es creando una clase que implemente la interfaz  \`java.lang.Runnable\`.\r
\r
Esta interfaz es una interfaz est\xE1ndar que viene con la plataforma Java. La interfaz Runnable s\xF3lo tiene un \xFAnico m\xE9todo, void run().\r
\r
> [java.lang.Runnable specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html)\r
\r
Sea lo que sea lo que el thread tenga que hacer, debe estar incluido en la implementaci\xF3n del m\xE9todo run. Tenemos tres posibilidades de implementar dicha interfaz:\r
\r
- Crear una clase Java que implemente la interfaz Runnable.\r
- Crear una clase an\xF3nima que implemente la interfaz Runnable.\r
- Crear una expresi\xF3n Lambda que implemente la interfaz Runnable.\r
\r
En las siguientes secciones podemos ver c\xF3mo usar cada una de ellas.\r
\r
### Clase Java que implementa la interfaz Runnable\r
\r
La primera forma que vamos a ver es creando una clase que implementa la interfaz. Podemos ver un ejemplo b\xE1sico en el siguiente c\xF3digo:\r
\r
\`\`\`java\r
public class MyRunnable implements Runnable {\r
\r
  public void run(){\r
      System.out.println("MyRunnable running");\r
  }\r
}\r
\`\`\`\r
\r
Todo lo que hace la implementaci\xF3n es imprimir el texto "MyRunnable running". Tras ejecutar esa l\xEDnea de c\xF3digo, el m\xE9todo run termina y el thread que estuviese ejecut\xE1ndolo se parar\xEDa.\r
\r
### Implementaci\xF3n con clase an\xF3nima de la interfaz Runnable\r
\r
Otra forma de obtener un objeto que implemente Runnable es crear una clase an\xF3nima. A continuaci\xF3n tenemos un ejemplo de c\xF3mo hacerlo\r
\r
\`\`\`java\r
Runnable myRunnable =\r
    new Runnable(){\r
        public void run(){\r
            System.out.println("Runnable running");\r
        }\r
    }\r
\`\`\`\r
\r
Salvo por el hecho de usar una clase an\xF3nima, el ejemplo hace exactamente lo mismo que el anterior en el que se creaba una clase que implementaba la interfaz.\r
\r
### Implementaci\xF3n de Runnable a trav\xE9s de una expresi\xF3n Lambda\r
\r
Para la tercera forma nos vamos a basar en la caracter\xEDstica de la interfaz Runnable, esto es, que s\xF3lo tiene un \xFAnico m\xE9todo a implementar, el m\xE9todo run. Aunque Runnable no es una interfaz funcional, podemos crear una expresi\xF3n Lambda que no dar\xE1 lugar a confusi\xF3n acerca del m\xE9todo que se quiere ejecutar. Por este motivo podemos usar la expresi\xF3n lambda como si Runnable fuese una interfaz funcional.\r
\r
Vamos a verlo con un ejemplo\r
\r
\`\`\`java\r
Runnable runnable =\r
        () -> { System.out.println("Lambda Runnable running"); };\r
\`\`\`\r
\r
### Llamar al m\xE9todo run de una clase que implemente Runnable\r
\r
Vamos a fijarnos en este ejemplo\r
\r
\`\`\`java{1,13,23}\r
public class LiftOff implements Runnable {\r
    private int countDown = 10;\r
    private static int taskCount = 0;\r
    private final int id = taskCount;\r
    \r
    public LiftOff() {}\r
    \r
    public LiftOff(int countDown) {\r
        this.countDown = countDown;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        while (countDown > 0) {\r
            System.out.println("#" + id + " (" + countDown + ")" );\r
            countDown--;\r
        }\r
        System.out.println("Lanzamiento (" + id + ")");\r
    }\r
    \r
    public static void main(String[] args) {\r
        LiftOff launch = new LiftOff();\r
        launch.run();\r
        System.out.println("Comienza la cuenta atr\xE1s!");\r
    }    \r
}\r
\`\`\`\r
\r
Copy the previous code and try tu run it in your IDE\r
\r
::: question \xBFQu\xE9 est\xE1 pasando con la ejecuci\xF3n del programa anterior?\r
Tras ejecutarlo, \xBFel mensaje "Comienza la cuenta atr\xE1s!" est\xE1 puesto en el sitio correcto?\r
\r
intenta crear m\xE1s instancias del la clase LiftOff y haz que se ejecuten todas (dentro del main)\r
\r
Si observas la salida de aplicaci\xF3n, \xBFest\xE1 haciendo algo diferente a una aplicaci\xF3n monohilo?\r
\xBFQu\xE9 puedes extraer de la salida del programa?\r
:::\r
\r
::: details Respuesta a las cuestiones planteadas\r
El mensaje deber\xEDa mostrarse antes que la cuenta atr\xE1s. De hecho la instrucci\xF3n con el System.out est\xE1 despu\xE9s de la llamada al m\xE9todo run.\r
\r
Como se puede observar, no estamos haciendo nada diferente. El c\xF3digo de run se est\xE1 ejecutando uno despu\xE9s de otro.\r
\r
En realidad, **no estamos creando nuevos threads**, lo \xFAnico que hemos hecho hasta ahora es implementar una interfaz, pero llamando al m\xE9todo run estamos haciendo que el hilo principal de la aplicaci\xF3n, el \xFAnico hilo de momento, est\xE9 ejecutando un m\xE9todo run, despu\xE9s otro, despu\xE9s otro, ... y cuando ha acabado con todos hace el System.out.\r
:::\r
\r
## 3.1.2 Thread subclass\r
\r
Adem\xE1s de implementando la interfaz Runnable, laa segunda forma que tenemos de indicar a un thread el c\xF3digo a ejecutar es creando una subclase de  \`java.lang.Thread\` y sobrescribiendo el m\xE9todo run(). La clase Thread implementa de forma impl\xEDcita la interfaz Runnable. Al igual que con Runnable, el m\xE9todo run() contiene el c\xF3digo que ejecutar\xE1 un thread cuando se llame al m\xE9todo \`start()\`.\r
\r
> [java.lang.Thread specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html)\r
\r
Vamos a ver un ejemplo de creaci\xF3n de una clase que herede de Thread:\r
\r
\`\`\`java\r
public class MyThread extends Thread {\r
  public void run(){\r
      System.out.println("MyThread running");\r
  }\r
}\r
\`\`\`\r
\r
Para crear y lanzar un nuevo thread tenemos que usar el siguiente c\xF3digo\r
\r
\`\`\`java\r
MyThread myThread = new MyThread();\r
myTread.start();\r
\`\`\`\r
\r
La llamada al m\xE9todo start() devuelve el control al thread principal en cuanto el hilo asociado se inicia. A diferencia del ejemplo de la cuenta atr\xE1s, cuando llamamos al m\xE9todo start no el hilo principal no espera a que el m\xE9todo run() se ejecute por completo antes de seguir. El m\xE9todo run() se ejecutar\xE1 en un hilo de ejecuci\xF3n diferente, posiblemente por un procesador diferente, entrando en la cola de procesos para competir por las unidades de procesamiento del sistema. Al igual que en los casos anteriores, cuando se ejecute el m\xE9todo run() mostrar\xE1 por pantalla el mensaje "MyThread running" y el hilo terminar\xE1 su ejecuci\xF3n (y su vida) porque finaliza el c\xF3digo del m\xE9todo run().\r
\r
El ejemplo se puede repetir con una clase an\xF3nima, aunque ya no con una expresi\xF3n lambda, ya que la clase Thread tiene muchos m\xE1s m\xE9todos y no es una interfaz funcional.:\r
\r
\`\`\`java\r
Thread thread = new Thread(){\r
  public void run(){\r
    System.out.println("Thread Running");\r
  }\r
}\r
\r
thread.start();\r
\`\`\`\r
\r
El ejemplo mostrar\xE1 el mensaje "Thread running" cuando el m\xE9todo run() se ejecutado por el nuevo thread.\r
\r
::: question Ejemplo Cuenta atr\xE1s\r
Copia el ejemplo original de la "Cuenta Atr\xE1s" y haz que la clase LiftOff ahora herede de Thread.\r
Ahora, en vez de llamar directamente al m\xE9todo run, haz que los threads llamen al m\xE9todo start().\r
\r
El mensaje "Comienza la cuenta atr\xE1s!" \xBFaparece ahora en el sitio correcto? \xBFPorqu\xE9 sale antes si en el c\xF3digo est\xE1 despu\xE9s?\r
\r
Crea nuevas instancias de LiftOff y has que se lancen en el main\r
\xBFEn qu\xE9 ha cambiado ahora la ejecuci\xF3n de las aplicaci\xF3n respecto a una aplicaci\xF3n monohilo?\r
\xBFQu\xE9 puedes extraer de la salida del programa?\r
:::\r
\r
::: details Respuesta a las cuestiones planteadas\r
Ahora el mensaje "Comienza la cuenta atr\xE1s!" s\xED aparece, en la salida, en la posici\xF3n correcta, es decir, antes de la cuenta atr\xE1s. Si observamos el c\xF3digo, siguiendo una l\xF3gica secuencial, el mensaje deber\xEDa aparecer despu\xE9s, como pas\xF3 en la primera prueba que hicimos.\r
\r
La diferencia ahora es que el c\xF3digo del run() lo est\xE1 ejecutando un hilo diferente, y desde el momento en que se hace el start() el control vuelve al hilo principal (main) que contin\xFAa ejecutando las l\xEDneas de c\xF3digo que hay en el m\xE9todo main. La creaci\xF3n de un hilo, aunque menos que la de un proceso, tambi\xE9n tiene un coste de recursos y temporal, por lo que el hilo tarda unos instantes en empezar a ejecutarse. Por eso el hilo principal tiene tiempo de ejecutar la siguiente instrucci\xF3n y mostrar el mensaje.\r
\r
La gran diferencia ahora, que podemos observar en la salida, es que los hilos se est\xE1n ejecutando concurrentemente, ya que vemos como sus salidas se intercalan.\r
\r
Esa es la diferencia m\xE1s obvia. Sin embargo, si ejecutamos el programa varias veces, podremos observar que no hay dos ejecuciones iguales. No depende de nosotros el orden en el que se ejecutan las instrucciones, sino que depende de la planificaci\xF3n que realice el SO. En este contexto nos encontramos con una ejecuci\xF3n aleatoria o **indeterminista** como la denominamos en el primer tema.\r
\r
El c\xF3mo controlar ese orden es lo que trabajaremos en la segunda parte del tema.\r
:::\r
\r
::: info \xBFCu\xE1ndo termina un proceso?\r
En el ejemplo anterior, la \xFAltima l\xEDnea del hilo principal se ejecuta antes que el c\xF3digo de los hilos. \xBFQu\xE9 pasa entonces con el proceso?\r
\r
En un proceso monohilo, estamos acostumbrados a que el proceso sigue en ejecuci\xF3n (vivo) mientras el c\xF3digo que hayamos puesto en el main est\xE9 ejecut\xE1ndose. En concreto mientras el main-thread est\xE9 en ejecuci\xF3n.\r
\r
![Ciclo de vida de un proceso](../../media/unit3/threads_process_end.png)\r
\r
Cuando un proceso tiene mas hilos, la norma es que el proceso no finaliza su ejecuci\xF3n hasta que el \xFAltimo de los hilos haya terminado. As\xED que podemos encontrarnos, como en ejemplo de la cuenta atr\xE1s, que el main-thread acaba y el proceso sigue en ejecuci\xF3n.\r
:::\r
\r
## 3.1.3 Starting a Thread With a Runnable\r
\r
Para hacer que un thread ejecute el c\xF3digo del m\xE9todo run de una clase (instancia de clase, clase an\xF3nima, expresi\xF3n lambda) que implemente la interfaz Runnable, tenemos que pasar esa instancia como par\xE1metro en el constructor de la clase Thread. Veamos c\xF3mo se hace:\r
\r
\`\`\`java\r
Runnable runnable = new MyRunnable(); // or an anonymous class, or lambda...\r
\r
Thread thread = new Thread(runnable);\r
thread.start();\r
\`\`\`\r
\r
Cuando se inicia el thread, llamando a su m\xE9todo start(), se crea un nuevo thread que ejecuta el c\xF3digo del m\xE9todo run de la instancia MyRunnable. El ejemplo anterior imprimir\xE1 el texto "MyRunnable running (ver el c\xF3digo de MyRunnable en los ejemplos anteriores).\r
\r
::: info\r
En resumen, tenemos dos formas de indicarle a un thread qu\xE9 c\xF3digo debe ejecutar.\r
\r
- Crear una subclase de Thread y sobrescribir el m\xE9todo run().\r
- Pasar una instancia de un objeto que implemente la interfaz Runnable al constructor de Thread.\r
\r
**En ambos casos, para que se cree el thread y ejecute el c\xF3digo del m\xE9todo run, debemos llamar al m\xE9todo start() del objeto Thread.**\r
:::\r
\r
<CodeGroup>\r
<CodeGroupItem title="Extends Thread" active>\r
\r
\`\`\`java{1,7}\r
public class EjemploThread extends Thread {\r
  public void run() {\r
    // C\xF3digo del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    EjemploThread hilo = new EjemploThread();\r
    hilo.start();\r
  }\r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Runnable">\r
\r
\`\`\`java{1,7}\r
public class EjemploRunnable implements Runnable {\r
  public void run() {\r
    // C\xF3digo del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    Thread hilo = new Thread(new EjemploRunnable());\r
    hilo.start();\r
  }    \r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
</CodeGroup>\r
\r
### Subclass or Runnable?\r
\r
No hay nada que indique que una forma es mejor que otra. Ambos m\xE9todos son similares y el resultado es el mismo. . **El m\xE9todo preferido deber\xEDa ser implementar Runnable**, y pasarle la instancia al constructor de Thread.\r
\r
unas cuantas razones en contra de usar Thread\r
\r
- Cuando heredamos de la clase Thread, no estamos sobrescribiendo ninguno de sus m\xE9todos. Por contra, estamos sobrescribiendo un m\xE9todo de la interfaz Runnable (que Thread implementa internamente . Esto supone una clara violaci\xF3n del principio IS-A del Thread.\r
- Cuando pasamos la instancia de Runnable y la utilizamos como argumento en el constructor de Thread estamos usando composici\xF3n y no herencia, lo cual permite mucha m\xE1s flexibilidad.\r
- Si heredamos de Thread, ya no podemos heredar de otras clases. Esto supone un gran problema cuando usamos librer\xEDas o componentes gr\xE1ficos, ya que Java noi permite la herencia m\xFAltiple.\r
- Desde Java 8 en adelante, la interfaz Runnable se puede representar con expresiones lambda\r
\r
::: danger Error com\xFAn: Llamar a run () en vez de a start()\r
Cuando empezamos a trabajar con hilos, un error muy com\xFAn es llamar directamente al m\xE9todo run en vez de llamar al m\xE9todo start():\r
\r
> Thread newThread = new Thread(MyRunnable());\r
> newThread.run();  //should be start();\r
\r
or\r
\r
> MyRunnable runnable = new MyRunnable();\r
> runnable.run();  \r
\r
En principio no notamos ning\xFAn error ya que el c\xF3digo de run() se ejecuta y podemos ver los resultados. Sin embargo, ese c\xF3digo **no es ejecutado por el nuevo thread** que acabamos de crear. El m\xE9todo run() es ejecutado por el thread que ha creado el objeto, es decir, el mismo thread que ha ejecutado las l\xEDneas anteriores a la llamada a run().\r
\r
Para hacer que el m\xE9todo run, de una instancia que implemente Runnable o de una que herede de Thread, sea ejecutado por un el nuevo thread que acabamos de crear, newThread, debemos llamar al m\xE9todo newThread.start().\r
:::\r
\r
## 3.1.4 M\xE9todos de la clase java.lang.Thread\r
\r
Si miramos a la definici\xF3n de la clase Thread veremos que tiene muchos m\xE9todos. Debemos tener cuidado ya que algunos de estos m\xE9todos como stop(), suspend(), resume() and destroy()  han sido marcados como \`obsoletos(deprecated)\`.\r
\r
Vemos algunos de los m\xE9todos de la clase Thread m\xE1s utilizados:\r
\r
| Method                      | Description                                                                                                                                                                                                            |\r
| :-------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| start()                     | HAce que un nuevo thread ejecute el c\xF3digo del m\xE9todo run()                                                                                                                                                            |\r
| boolean isAlive()           | Comprueba si un thread est\xE1 vivo o no                                                                                                                                                                                  |\r
| sleep(long ms)              | Cambia el estado del thread a bloqueado durante los ms indicados                                                                                                                                                       |\r
| run()                       | Es el c\xF3digo que el thread ejecuta. Es llamado por el m\xE9todo start(). Representa el ciclo de vida de un thread.                                                                                                        |\r
| String toString()           | Devuelve una representaci\xF3n legible de un thread [nombre, priority, nombre_del_grupo                                                                                                                                   |\r
| long getId()                | Devuelve el identificador del thread (es un id asignado por el proceso)                                                                                                                                                |\r
| void yield()                | Makes the thread stop running at the moment going back to the queue and allowing other threads to be executed.                                                                                                         |\r
| void join()                 | Se llama desde otro thread y hace que el thread que lo invoca se bloquee hasta que el thread termine. Es parecido a p.waitFor() para los procesos                                                                      |\r
| String getName()            | Obtiene el nombre del thread                                                                                                                                                                                           |\r
| String setName(String name) | Cambia el nombre del thread                                                                                                                                                                                            |\r
| int getPriority()           | Obtiene la prioridad del thread                                                                                                                                                                                        |\r
| setPriority(int p)          | Modifica la prioridad del thread                                                                                                                                                                                       |\r
| void interrupt()            | Interrumpe la ejecuci\xF3n del thread provocando que salte una excepci\xF3n de tipo InterruptedException                                                                                                                     |\r
| boolean interrupted()       | Comprueba si un thread ha sido interrumpido                                                                                                                                                                            |\r
| Thread.currentThread()      | M\xE9todo est\xE1tico de la clase Thread que devuelve una referencia al hilo que est\xE1 ejecutando el c\xF3digo                                                                                                                   |\r
| boolean isDaemon()          | Comprueba si un hilo es un servicio/demonio. Un proceso/hilo de baja prioridad que se ejecuta de forma independiente de su proceso padre. Un proceso puede finalizar aunque un hilo *daemon* est\xE9 todav\xEDa ejecut\xE1ndose. |\r
| setDaemon(boolean on)       | Convierte un hilo en un demonio/servicio. Por defecto todos los hilos se crean como hilos de usuario.                                                                                                                  |\r
| int activeCount()           | Devuelve el n\xFAmero de hilos pertenecientes a un grupo que siguen activos.                                                                                                                                              |\r
| Thread.State getState()     | Devuelve el estado actual del hilo. Los posibles valores son NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING or TERMINATED.                                                                                             |\r
\r
La clase Thread tambi\xE9n tiene unos 9 constructores, la mayor\xEDa de ellos est\xE1n duplicados permitiendo recibir un objeto dRunnable como par\xE1metro\r
\r
| Constructores de la clase Thread                                                                      |\r
| :---------------------------------------------------------------------------------------------------- |\r
| Thread()                                                                                              |\r
| Thread\u200B(Runnable target)                                                                              |\r
| Thread\u200B(String name)                                                                                  |\r
| Thread\u200B(ThreadGroup group, String name)                                                               |\r
| Thread\u200B(Runnable target, String name)                                                                 |\r
| Thread\u200B(ThreadGroup group, Runnable target)                                                           |\r
| Thread\u200B(ThreadGroup group, Runnable target, String name)                                              |\r
| Thread\u200B(ThreadGroup group, Runnable target, String name, long stackSize)                              |\r
| Thread\u200B(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals) |\r
\r
Veamos un ejemplo pr\xE1ctico de uso de todos estos m\xE9todos\r
\r
\`\`\`java\r
public class U3S2_ThreadMethodsExample extends Thread {\r
    \r
    U3S2_ThreadMethodsExample (ThreadGroup group, String name) {\r
        // Call to parent class constructor with group and thread name\r
        super(group, name);\r
    }\r
    \r
    @Override\r
    public void run() {\r
        String threadName = Thread.currentThread().getName();\r
        System.out.println("["+threadName+"] " + "Inside the thread");\r
        System.out.println("["+threadName+"] " + "Priority: " \r
          + Thread.currentThread().getPriority());\r
        Thread.yield();\r
        System.out.println("["+threadName+"] " + "Id: " \r
          + Thread.currentThread().getId());\r
        System.out.println("["+threadName+"] " + "ThreadGroup: " \r
          + Thread.currentThread().getThreadGroup().getName());\r
        System.out.println("["+threadName+"] " + "ThreadGroup count: " \r
          + Thread.currentThread().getThreadGroup().activeCount());\r
    } \r
    \r
    public static void main(String[] args) {\r
        // main thread \r
        Thread.currentThread().setName("Main");\r
        System.out.println(Thread.currentThread().getName());\r
        System.out.println(Thread.currentThread().toString());\r
        \r
        ThreadGroup even = new ThreadGroup("Even threads");\r
        ThreadGroup odd = new ThreadGroup("Odd threads");\r
        \r
        Thread localThread = null;\r
        for (int i=0; i<10; i++) {\r
            localThread = new U3S2_ThreadMethodsExample((i%2==0)?even:odd, "Thread"+i);\r
            localThread.setPriority(i+1);\r
            localThread.start();\r
        }\r
              \r
        try {\r
            localThread.join(); // --> Will wait until last thread ends \r
                                // like a waitFor() for processes\r
        } catch (InterruptedException ex) {\r
            ex.printStackTrace();\r
            System.err.println("The main thread was interrupted while waiting for " \r
              + localThread.toString() + "to finish");\r
        }\r
        System.out.println("Main thread ending");\r
    }    \r
}\r
\`\`\`\r
\r
En el ejemplo anterior podemos ver c\xF3mo tenemos que ayudarnos el m\xE9todo est\xE1tico Thread.currentThread() par saber qu\xE9 hilo est\xE1 ejecut\xE1ndose en cada momento, ya que hay muchos hilos ejecutando el mismo c\xF3digo al mismo tiempo.\r
\r
Hemos creado una \xFAnica clase para los hilos y para el hilo principal. No deber\xEDa ser una pr\xE1ctica com\xFAn m\xE1s all\xE1 de los ejemplos. Es mejor separar el c\xF3digo del objeto que hereda de Thread o que implementa Runnable en una clase aparte.\r
\r
Tambi\xE9n es importante hacer ver que la clase Thread (o Runnable) puede tener sus propios constructores, propiedades y m\xE9todos, m\xE1s all\xE1 del m\xE9todo run que est\xE1n obligadas a sobrescribir. Tambi\xE9n puede invocar a los constructores de la superclase haciendo uso de super().\r
\r
:::question Dividir el c\xF3digo en dos clases\r
Copia el c\xF3digo de ThreadMethodsExample y div\xEDdelo en dos clases. Por un lado, una que contenga a la clase que extiende de Thread y otra que s\xEDmplemente tenga el m\xE9todo main y el c\xF3digo para crear y lanzar los hilos..\r
\r
Una vez dividido el c\xF3digo cambia U3S2_ThreadMethodsExample para que implemente la interfaz Runnable. Haz los cambios oportunos en la otra clase para que todo vuelva a funcionar como antes.\r
:::\r
\r
Si ejecutas el programa podr\xE1s ver que aunque los threads son lanzados en orden (1, 2, 3 etc.) su ejecuci\xF3n ya no se realiza de forma secuencial. they may not execute sequentially, meaning thread 1 may not be the first thread to write its name to System.out. This is because the threads are in principle executing in parallel and not sequentially. The JVM and/or operating system determines the order in which the threads are executed. This order does not have to be the same order in which they were started nor each time the are run.\r
\r
### C\xF3mo pausar un hilo\r
\r
Un thread puede pausar su propia ejecuci\xF3n llamando al m\xE9todo est\xE1tico **Thread.sleep()**. El m\xE9todo sleep() recibe como par\xE1metro el n\xFAmero de milisegundos que quiere estar pausado antes de volver a ponerse como listo para ejecuci\xF3n. No es un m\xE9todo 100% precise (menos \xE1un si utilizamos la versi\xF3n que recibe ms y ns), pero a\xFAn as\xED es bastante preciso. A continuaci\xF3n tenemos un ejemplo de un thread que se pausa durante 3 segundos (3000ms) llamando al m\xE9todo sleep():\r
\r
\`\`\`java:no-line-numbers\r
try {\r
    Thread.sleep(3000L);\r
} catch (InterruptedException e) {\r
    e.printStackTrace();\r
}\r
\`\`\`\r
\r
::: info Simulaci\xF3n de sistema reales\r
Este es un m\xE9todo que vamos a utilizar exhaustivamente en las actividades para simular per\xEDodos de tiempo y acelerar las simulaciones.\r
\r
Por ejemplo, podemos hacer un ajuste para que cada hora *real* se reduzca a un segundo. De esta forma podremos simular un d\xEDa completo en tan solo 24 segundos.\r
\r
Tambi\xE9n es interesante su uso para utilizar per\xEDodos de tiempo aleatorios en la ejecuci\xF3n de cada hilo, permitiendo as\xED una simulaci\xF3n realista de los eventos en un sistema real.\r
:::\r
\r
En Java podemos generar n\xFAmeros aleatorios en el rango de los enteros, long, float y double.\r
\r
Tenemos tres m\xE9todos b\xE1sicos para hacerlo\r
\r
#### Method 1: Usando la clase Random\r
\r
Podemos usar la clase  \`java.util.Random\` para generar datos aleatorios, siguiendo los siguientes pasos:\r
\r
- Importar la clase java.util.Random\r
- Crear una instancia de la clase Random, por ejemplo \`Random rand = new Random()\`\r
- Llamar a alguno de los m\xE9todos del objeto:\r
  - nextInt(limitesuperior) genera n\xFAmeros aleatorios en el rango 0 a l\xEDmitesuperior-1.\r
  - nextFloat() genera un float entre 0.0 and 1.0.\r
  - nextDouble() genera un double entre 0.0 and 1.0.\r
  \r
Si llamamos al m\xE9todo nextInt con par\xE1metros (el l\xEDmite superior), obtendremos n\xFAmeros enteros en el rango\r
\r
> int randomWithNextIntWithinARange = random.nextInt(max)\r
\r
Esto nos dar\xE1 un n\xFAmero entre  *0 (inclusive)* y *max* (no incluido) [min, max[. El valor del l\xEDmite debe ser mayor que 0 sino obtendremos una java.lang.IllegalArgumentException.\r
\r
#### Method 2: Usando Math.random\r
\r
Para generar n\xFAmeros aleatorios en un rango podemos usar Math.random() siguiendo los pasos detallados a continuaci\xF3n:\r
\r
- Declarar el valor m\xEDnimo del rango\r
- Declarar el valor m\xE1ximos del rango\r
- Usar la f\xF3rmula \`Math.random()*(max-min)+min\` para generar valores entre  *min* y *max*, ambos inclusive [min, max].\r
\r
El valor devuelto por Math.random() est\xE1 en el rango [0, 1]\r
\r
Para generar n\xFAmeros entre 0 y un l\xEDmite superior (50)\r
\r
> Math.random()*50\r
\r
Para generar n\xFAmeros entre 1 y un l\xEDmite superior (50)\r
\r
> Math.random()*49+1\r
\r
Para generar n\xFAmeros en un rango predeterminado [200, 500]\r
\r
> Math.random()*300+200\r
\r
#### Method 3: Usar ThreadLocalRandom\r
\r
La clase \`java.util.Random\` no tiene buen rendimiento en entornos multihilo. De forma simplificada, el motivo es la contenci\xF3n, ya que muchos hilos comparten la misma instancia de Random y se tiene que secuenciar y sincronizar el acceso a sus m\xE9todos.\r
\r
Para evitar esa limitaci\xF3n, Java introdujo la clase \`java.util.concurrent.ThreadLocalRandom\` para generar n\xFAmeros aleatorios en entornos multihilo.\r
\r
Si llamamos al m\xE9todo \`ThreadLocalRandom.current()\` nos devolver\xE1 la instancia de ThreadLocalRandom para el hilo actual. A partir de aqu\xED podemos generar valores aleatorios llamando a los m\xE9todos de la clase con la instancia obtenida.\r
\r
Para generar valores enteros sin l\xEDmite:\r
\r
> int unboundedRandomValue = ThreadLocalRandom.current().nextInt());\r
\r
Para generar valores enteros en un rango dato, es decir, con un l\xEDmite superior e inferior [0, 100[:\r
\r
> int boundedRandomValue = ThreadLocalRandom.current().nextInt(0, 100);\r
\r
Al igual que con Random, 0 est\xE1 incluido en el rango mientra que 100 no.\r
\r
Tambi\xE9n podemos generar otros tipos de datos como long y Double llamando a los m\xE9todos \`nextLong()\` y \`nextDouble()\` de forma similar a los ejemplos anteriores.\r
\r
La clase ThreadLocalRandom hereda de Random, por lo que comparten muchos m\xE9todos y funcionalidad.\r
\r
### Gesti\xF3n de la prioridad de los hilos\r
\r
Los hilos heredan la prioridad del padre en Java, pero este valor puede ser cambiado con el m\xE9todo \`setPriority()\` y con \`getPriority()\` podemos saber la prioridad de un hilo.\r
\r
El valor de la prioridad var\xEDa entre 1 y 10. *Cuanto m\xE1s alto es el valor, mayor es la prioridad*. La clase Thread define las siguientes constantes \`MIN_PRIORITY\` (valor 1) \`MAX_PRIORITY\` (valor 10) y \`NORM_PRIORITY\` (valor 5). El planificador elige el hilo en funci\xF3n de su prioridad. Si dos hilos tienen la misma prioridad realiza un round-robin, es decir de forma c\xEDclica va alternando los hilos.\r
\r
El hilo de mayor prioridad seguir\xE1 funcionando hasta que ceda el control:\r
\r
- Cede el control llamando al m\xE9todo yield().\r
- Deja de ser ejecutable (por muerte o por bloqueo)\r
- Aparece un hilo de mayor prioridad, por ejemplo si se encontraba en estado dormido por una operaci\xF3n de E/S o bien es desbloqueado por otro con los m\xE9todos notifyAll() / notify().\r
\r
\`\`\`java\r
class U3S3_HiloPrioridad1 extends Thread {\r
  private int c = 0;\r
  private boolean stopHilo = false;\r
  public int getContador () {\r
    return c;\r
  }\r
  public void pararHilo() {\r
    stopHilo = true;\r
  }\r
  public void run() {\r
    while (!stopHilo) c++;\r
  }\r
}\r
\r
public class U3S3_EjemploHiloPrioridad1 {\r
  public static void main(String args[]) {\r
    U3S3_HiloPrioridad1 h1 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h2 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h3 = new U3S3_HiloPrioridad1();\r
\r
    h1.setPriority(Thread.NOR_PRIORITY);\r
    h2.setPriority(Thread.MAX_PRIORITY);\r
    h3.setPriority(Thread.MIN_PRIORITY);\r
\r
    h1.start();\r
    h2.start();\r
    h3.start();\r
\r
    try {\r
      Thread.sleep(10000);\r
    } catch (exception e) {}\r
\r
    h1.pararHilo();\r
    h2.pararHilo();\r
    h3.pararHilo();\r
\r
    System.out.println("h2 (Prio. M\xE1x: "+h2.getContador());\r
    System.out.println("h1 (Prio. Normal: "+h1.getContador());\r
    System.out.println("h3 (Prio. M\xEDnima: "+h3.getContador());\r
  }\r
}\r
\`\`\`\r
`]},{title:"3.2 Sincronizaci\xF3n y comunicaci\xF3n de hilos",headers:[{level:2,title:"3.2.1. Memoria compartida",slug:"_3-2-1-memoria-compartida",link:"#_3-2-1-memoria-compartida",children:[]},{level:2,title:"3.2.2. Sincronizaci\xF3n",slug:"_3-2-2-sincronizacion",link:"#_3-2-2-sincronizacion",children:[{level:3,title:"Monitores y bloqueos",slug:"monitores-y-bloqueos",link:"#monitores-y-bloqueos",children:[]},{level:3,title:"Secciones cr\xEDticas",slug:"secciones-criticas",link:"#secciones-criticas",children:[]},{level:3,title:"Sincronizaci\xF3n y actualizaci\xF3n de la informaci\xF3n",slug:"sincronizacion-y-actualizacion-de-la-informacion",link:"#sincronizacion-y-actualizacion-de-la-informacion",children:[]}]},{level:2,title:"3.2.3 Sincronizaci\xF3n entre hilos",slug:"_3-2-3-sincronizacion-entre-hilos",link:"#_3-2-3-sincronizacion-entre-hilos",children:[]}],path:"/es/unit3/synchronization.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.2 Sincronizaci\xF3n y comunicaci\xF3n de hilos\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.2 Sincronizaci\xF3n y comunicaci\xF3n de hilos" />\r
\r
# 3.2 Sincronizaci\xF3n y comunicaci\xF3n de hilos\r
\r
[[toc]]\r
\r
::: info Vocabulario\r
\r
- **Condici\xF3n de carrera**: Situaci\xF3n en que el correcto funcionamiento de un programa depende del orden en que se intercale la ejecuci\xF3n de las instrucciones de sus diferente hilos. Esto ocurre cuando uno o m\xE1s hilos acceden a informaci\xF3n compartida de forma concurrente e intentan modificarla a la vez.\r
- **Deadlock**: Situaci\xF3n en que dos o m\xE1s hilos est\xE1n bloqueados mutuamente, todos ellos esperando para conseguir el bloqueo sobre objetos bloqueados por otros hilos, de manera que ninguno de ellos podr\xE1 continuar nunca.\r
- **Secci\xF3n cr\xEDtica**: Fragmento de un programa que no puede ejecutar de manera simult\xE1nea (concurrentemente) m\xE1s de un hilo del programa, es decir, que distintos hilos deben ejecutar en exclusi\xF3n mutua\r
- **Thread-safe**: Se dice de una clase cuyos m\xE9todos implementan los mecanismos de sincronizaci\xF3n necesarios para el uso concurrente de sus objetos por parte de distintos hilos, de manera que **no es necesario ning\xFAn mecanismo de sincronizaci\xF3n externo** a la propia clase.\r
\r
:::\r
\r
## 3.2.1. Memoria compartida\r
\r
A menudo los hilos necesitan comunicarse unos con otros. La forma que tienen de hacerlo consiste en compartir un objeto.\r
\r
Vamos a desarrollar un ejemplo en el que dos hilos comparten un objeto de la clase Contador.\r
\r
![alt_text](../../media/unit3/SumadorRestador_uml.jpg)\r
\r
<!--\r
\`\`\`puml\r
class Contador {\r
  - int c = 0\r
  + Contador(int c)\r
  +void incrementa()\r
  +void decrementa()\r
  + int valor()\r
}\r
class Sumador extends Thread {\r
  - Contador c\r
  + Sumador(String name, Contador c)\r
  + void run()\r
\r
}\r
class Restador implements Runnable{\r
  - Contador c\r
  + Restador(String name, Contador c)\r
  + void run()\r
\r
}\r
Restador o-- Contador\r
Sumador o-- Contador\r
\`\`\`\r
-->\r
\r
Para probar el objeto compartido, en una cuarta clase que contiene el main se crea un objeto Contador que se inicializa a 100 y se crean y lanzan dos threads, uno de tipo Sumador y otro de tipo Restador. En la clase Sumador se usa el m\xE9todo del objeto Contador que incrementa en uno su valor mientras que en la clase Restador se usa el m\xE9todo que decrementa en uno su valor. Cada una va a realizar la acci\xF3n 300 veces, esperando entre cada acci\xF3n un tiempo aleatorio entre 50ms y 150ms.\r
Es muy importante asegurarse que pasamos el mismo objeto Contador como par\xE1metro al constructor de Sumador y de Restador, para que ambos trabajen con la misma instancia.\r
\r
::: question Comportamiento esperado\r
Crea las cuatro clases en funci\xF3n del diagrama de clases proporcionado. Aseg\xFArate que Sumador hereda de Thread y Restador implementa la interfaz Runnable para comprobar las diferencias de uso y creaci\xF3n de threads a partir de cada tipo de clase.\r
\r
\xBFQu\xE9 deber\xEDa ocurrir tras ejecutar el c\xF3digo?\r
\r
Comprueba lo que pasa realmente. Intenta ejecutar el programa varias veces para ver si puedes obtener resultados diferentes.\r
:::\r
\r
:::details C\xF3digo del ejemplo\r
\r
\`\`\`java{4,7,9}\r
public class U3S3_SharedMemory {\r
  public static void main(String[] args) throws InterruptedException {\r
    // Inicializar el objeto Contador\r
    Contador c = new Contador(100);\r
    \r
    // Crear y lanzar 2 hilos (Sumador + Restador)\r
    Sumador s1 = new Sumador("Sumador1", c);\r
    Restador r1 = new Restador("Restador1", c);\r
    Thread h1 = new Thread(r1);\r
    \r
    s1.start();\r
    h1.start();\r
    \r
    // El hilo principal espera a que los hilos s1 y r1 terminen\r
    s1.join();\r
    h1.join();\r
    \r
    System.out.println("El valor final de c es " + c.valor());\r
    \r
  }\r
\`\`\`\r
\r
\`\`\`java\r
public class Contador {\r
  private int c = 0;\r
  \r
  public Contador(int c) {\r
    this.c = c;\r
  }\r
  \r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
  \r
  public int valor() {\r
    return c;\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,5,14}\r
public class Sumador extends Thread {\r
  private Contador c;\r
  public Sumador(String name, Contador c) {\r
    // To set the thread name we can access the Thread class constructor\r
    super(name);\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.incrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());\r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }\r
    }\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,3,13,17}\r
public class Restador implements Runnable {\r
  private Contador c;\r
  private String name;\r
  public Restador(String name, Contador c) {\r
    // Restador doesn't extend Thread, so it cannot call the Thread constructor\r
    // super(name);\r
    this.name = name;\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    Thread.currentThread().setName(this.name);\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.decrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());              \r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }      \r
    }    \r
  }\r
}\r
\`\`\`\r
\r
Si ejecutamos el programa, la mayor\xEDa de veces obtendremos el resultado esperado, 100. Sin embargo, hay ocasiones en que podemos encontrar otros valores tales como 99, 101 o cualquier otro.\r
\r
Para evitar problemas de sincronizaci\xF3n (son problemas como hemos visto aleatorios y muy dif\xEDciles de detectar), necesitamos que los hilos est\xE9n sincronizados entre s\xED.\r
:::\r
\r
Si analizamos el problema anterior, veremos que se est\xE1 intentando ejecutar el siguiente c\xF3digo en paralelo desde diferentes hilos, en **la misma instancia (memoria compartida)**:\r
\r
\`\`\`java\r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
\`\`\`\r
\r
Si aplic\xE1semos las condiciones de Bernstein a esos dos m\xE9todos, ver\xEDamos que no se cumple ninguna de las tres, por lo que ese c\xF3digo no puede ser ejecutado concurrentemente, al menos no sin tener problemas de concurrencia.\r
\r
As\xED, para evitar que varios hilos ejecuten esos m\xE9todos de forma concurrente, necesitamos estructuras de programaci\xF3n que nos ayuden a conseguirlo.\r
\r
## 3.2.2. Sincronizaci\xF3n\r
\r
El c\xF3digo anterior no funciona porque las operaciones que se realizan en los m\xE9todos incrementa y decrementa no son at\xF3micas, sino que se descomponen en operaciones m\xE1s simples que se ejecutan una tras otra.\r
\r
Cuando estas operaciones se ejecutan en un hilo, la ejecuci\xF3n del hilo se puede interrumpir y se pueden intercalar entre ellas operaciones de otros hilos. Seg\xFAn c\xF3mo se intercalen las operaciones y los datos a los que accedan, se pueden obtener resultados no esperados. Esto es lo que se conoce como una \`condici\xF3n de carrera\`.\r
\r
Como vimos en la primera parte del tema, la comunicaci\xF3n entre threads se produce principalmente mediante el acceso compartido a objetos y sus propiedades. Este mecanismo de comunicaci\xF3n es muy eficiente pero presenta dos tipos de errores:\r
\r
- Interferencia entre threads\r
- Errores de consistencia de la informaci\xF3n en memoria.\r
\r
La herramienta de programaci\xF3n que utilizamos para prevenir este tipo de errores es la *sincronizaci\xF3n*.\r
\r
La mayor parte del tiempo, los threads no tienen en cuenta la resto de hilos que se ejecutan en el programa ni les importa lo que \xE9stos hagan. Pero si necesitan algo de otro thead, entonces necesitan la sincronizaci\xF3n.\r
\r
### Monitores y bloqueos\r
\r
La sincronizaci\xF3n en Java se realiza usando \`monitores\`. Es una propiedad que proporciona la clase Object, por lo tanto todas nuestras clases Java, directa o indirectamente, heredan esta propiedad de Object. Este mecanismo permite a un \xFAnico thread a la vez ejecutar la secci\xF3n de c\xF3digo protegida por el monitor.\r
\r
Un monitor no es m\xE1s que un bloqueo sobre un objeto. **Cada objeto tiene un y s\xF3lo un bloqueo (candado) interno asociado**. El bloqueo de un objeto solamente puede ser adquirido por un thread en cada momento.\r
\r
La sincronizaci\xF3n implica muchos conceptos. El m\xE1s utilizado es la \`exclusi\xF3n mutua\` (**s\xF3lo un hilo puede disponer de un monitor a la vez)**. Por lo tanto, la sincronizaci\xF3n utilizando monitores significa que cuando un hilo accede a una secci\xF3n protegida por un monitor, ning\xFAn otro hilo puede acceder a esa o a cualquier otra secci\xF3n protegida por ese mismo monitor, hasta que el hilo salga de la secci\xF3n protegida\r
\r
Pero la sincronizaci\xF3n tambi\xE9n asegura que las escrituras en memoria realizadas por un thread dentro de un bloque protegido por un monitor son accesibles al resto de threads que accedan a los bloques protegidos por ese mismo monitor.\r
\r
::: danger Un objeto, un monitor\r
He recalcado en varias ocasiones que los bloques de c\xF3digo a los que se accede en exclusi\xF3n mutua son aquellos que est\xE1n protegidos por el mismo monitor. Esto es lo mismo que decir a aquellos que se realizan sobre el mismo objeto.\r
Cada objeto tiene asociado un monitor y la exclusi\xF3n mutua y la sincronizaci\xF3n de memoria tiene sentido si varios threads usan el mismo monitor para su sincronizaci\xF3n.\r
:::\r
\r
Cada objeto gestiona una cola de hilos que quieren conseguir el bloqueo del mismo. Como suele ser habitual, la elecci\xF3n del proceso de la cola que conseguir\xE1 el bloqueo es totalmente indeterminista, depende de m\xFAltiples factores y no sigue ning\xFAn orden preestablecido.\r
\r
### Secciones cr\xEDticas\r
\r
En Java la palabra reservada \`synchronized\` sirve para hacer que un bloque de c\xF3digo o un m\xE9todo sea protegido por el cerrojo del objeto. Para ejecutar un bloque o un m\xE9todo sincronizado, los hilos deben conseguir previamente el bloqueo (candado) del objeto, debiendo esperar a que quede libre (el hilo que lo tiene lo libere) si el monitor ya ha sido adquirido por otra hilo.\r
\r
Esto ocurre s\xF3lo si se est\xE1 intentando acceder al monitor del mismo objeto que otro hilo ya tenga en propiedad.\r
\r
La palabra reservada synchronized puede aplicarse en distintos tipos de bloques de c\xF3digo y, en cada caso, se utilizar\xE1 un objeto de bloqueo distinto.\r
\r
- M\xE9todos no est\xE1ticos\r
- Static methods\r
- Code blocks inside methods\r
\r
Para m\xE9todos no est\xE1ticos se a\xF1ade la palabra reservada synchronized a la definici\xF3n del m\xE9todo.\r
\r
\`\`\`java{3}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
}\r
\`\`\`\r
\r
El bloqueo se aplica sobre el objeto sobre le que se ejecuta el m\xE9todo (this). En este caso dos hilos no podr\xEDan ejecutar a la vez dos m\xE9todos del mismo objeto marcados como synchronized.\r
\r
Cada objeto que instanciemos de la clase tendr\xE1 su propio monitor asociado que no interferir\xE1 con los bloqueos que se hayan hecho sobre otros objetos de la misma clase.\r
\r
Como ya hemos dicho, este comportamiento s\xF3lo es v\xE1lido si todos los m\xE9todos sincronizados a los que se quiere acceder pertenecen a la misma instancia. De este modo el monitor es el mismo y se aplica la exclusi\xF3n mutua en la ejecuci\xF3n de los bloques de c\xF3digo protegidos por el monitor.\r
\r
\`\`\`java{3,6}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
 public synchronized void sub(int value){\r
   this.count -= value;\r
 }\r
}\r
\`\`\`\r
\r
::: info Sincronizaci\xF3n con m\xE9todos est\xE1ticos\r
En este caso el bloqueo se realiza sobre la clase a la que pertenece el m\xE9todo. Como **s\xF3lo hay una instancia de cada objeto clase en la JVM**, s\xF3lo un hilo a la vez podr\xE1 adquirir el monitor y ejecutar el c\xF3digo protegido de una clase est\xE1tica..\r
:::\r
\r
LA sincronizaci\xF3n no tiene porqu\xE9 realizarse sobre todo un m\xE9todo. A veces es preferible sincronizar s\xF3lo una parte de un m\xE9todo. Otras no es posible sincronizar el m\xE9todo completo. Para sincronizar un bloque de c\xF3digo usamos la palabra reservada synchronized seguida, entre par\xE9ntesis, del objeto del que usaremos el monitor. El c\xF3digo protegido se ubicar\xE1 entre un par de llaves.\r
\r
\`\`\`java{2}\r
public void add(int value){\r
  synchronized(this){\r
    this.count += value;  \r
  }\r
 }\r
\`\`\`\r
\r
En el ejemplo se ha utilizado \u201Cthis\u201D como objeto para el monitor. Decimos que el codigo est\xE1 sincronizado con el monitor del objeto que pongamos entre par\xE9ntesis.**Un m\xE9todo sincronizado usa el objeto al que pertenece como monitor, es decir, tambi\xE9n usa this**.\r
\r
S\xF3lo puede haber un thread ejecutando un bloque sincronizado para el mismo monitor. Los dem\xE1s se quedan esperando.\r
\r
El siguiente c\xF3digo define dos bloques protegidos por la instancia a la que pertenecen. **En t\xE9rminos de sincronizaci\xF3n, ambos bloque son totalmente equivalentes.**:\r
\r
\`\`\`java{2,8}\r
public class MyClass { \r
  public synchronized void log1(String msg1, String msg2){\r
    log.writeln(msg1);\r
    log.writeln(msg2);\r
  }\r
 \r
  public void log2(String msg1, String msg2){\r
    synchronized(this){\r
     log.writeln(msg1);\r
     log.writeln(msg2);\r
    }\r
  }\r
 }\r
\`\`\`\r
\r
Por lo tanto, s\xF3lo un thread podr\xEDa ejecutar uno de los dos bloques anteriores al mismo tiempo. Si otro hilo intentase ejecutar el mismo bloque, o el otro, se quedar\xEDa en la bloqueado en la cola de espera del monitor hasta que el monitor quede libre.\r
\r
::: warning \xBFQu\xE9 objetos se pueden usar como monitores\r
Oracle dice que se puede usar cualquier objeto como monitor de sincronizaci\xF3n, sin embargo **recomiendan que no se sincronice sobre String, o cualquier objeto envoltorio (wrapper) de los tipos de datos primitivos** (Integer, Double, Boolean, ...).\r
\r
Para estar seguros, lo mejor es sincronizar sobre **this"", sobre una instancia de un objet o, en su defecto sobre un nuevo objeto de tipo object, aunque sea un objeto vac\xEDo sin propiedades ni funcionalidad.\r
:::\r
\r
### Sincronizaci\xF3n y actualizaci\xF3n de la informaci\xF3n\r
\r
Sin el uso de la palabra reservada synchronized (o el modificador \`volatile\` ) no tenemos ninguna garant\xEDa de que cuando un hilo cambie el valor de una variable compartida con otros threads (por ejemplo a trav\xE9s de un objeto compartido entre todos los threads), los otros hilos puedan ver el valor modificado. No hay ninguna garant\xEDa de que cuando una variable se guarda en un registro de la CPU, el valor de \xE9sta se vuelque a la memoria principal.\r
\r
Esto, en programaci\xF3n secuencial no supone ning\xFAn problema ya que el \xFAnico hilo existente no necesita de estas actualizaciones "instant\xE1neas". Si fuese necesario se usar\xEDa la palabra \`volatile\` para las variables a las que se quiera forzar ese comportamiento.\r
\r
En la programaci\xF3n multihilo, y dentro de la sincronizaci\xF3n, un bloque protegido por un monitor nos garantiza que:\r
\r
- Cuando un hilo entra en un bloque synchronized se actualizar\xE1 el valor de todas las variables visibles para el hilo.\r
- Cuando un hilo salga de un bloque synchronized todos los cambios realizados por el hilo se actualizar\xE1n en la memoria principal.\r
\r
El comportamiento descrito es similar al que provoca el uso de la palabra reservado volatile, evitando el uso de caches y la desincronizaci\xF3n de la informaci\xF3n entre la CPU y la memoria principal.\r
\r
El siguiente ejemplo muestra un monitor que implementa un contador:\r
\r
\`\`\`java \r
class Contador { \r
  // monitor contador\r
  private int actual; \r
  public Contador(int inicial) \r
  { \r
    actual = inicial;    \r
  } \r
  public synchronized void inc() { actual++; } \r
  public synchronized void dec() { actual--; } \r
  public synchronized int valor() { return actual;} \r
} \r
 \r
class Usuario extends Thread { \r
  // clase hilo usuario\r
  private Contador cnt; \r
  public Usuario(String nombre, Contador cnt) { \r
    super(nombre); this.cnt = cnt;    \r
  } \r
  public void run() { \r
    for (int i = 0; i < 1000; i++) { \r
      cnt.inc();          \r
      System.out.println("Hola, soy " + this.getName() + ", mi contador vale " + cnt.valor()); \r
    }    \r
  }  \r
}\r
\r
class EjemploContador { \r
  // principal\r
  final static int nHebras = 20; \r
  public static void main(String[] args) {\r
    // metodo principal      \r
    final Contador cont1 = new Contador(10);       \r
    Usuario hebra[] = new Usuario[nHebras]; \r
    for (int i = 0; i < nHebras; i++) {          \r
      //crea hebras\r
      hebra[i] = new Usuario("la hebra-" + i, cont1); \r
      // lanza hebras      \r
      hebra[i].start(); }    \r
    } \r
  }\r
}\r
\`\`\`\r
\r
Es importante hacer notar, aunque suene a pesado, que todos los hilos acceden al c\xF3digo protegido del objeto cont1 que se crea en el m\xE9todo main. As\xED, no puede haber dos hilos ejecutando a la vez ninguna de los tres m\xE9todos de la instancia cont1 de la clase Contador.\r
\r
::: danger Usar final con objetos de tipo monitor\r
Un objeto usado como monitor, o como memoria compartida entre hilos, deber\xEDa ser de tipo **final**, porque si se le asigna un nuevo valor quedan si efecto todos los bloqueos que existan sobre dicho objeto. Un objeto de tipo final una vez que se ha creado y se le ha asignado un valor no se le puede asignar un nuevo valor.\r
:::\r
\r
## 3.2.3 Sincronizaci\xF3n entre hilos\r
\r
Ya hemos visto un tipo de problema en el que varios hilos comparten recursos y se sincroniza el acceso a estos recursos mediante el uso de monitores. Hasta ahora, una vez que un hilo obtiene el bloqueo de un monitor, puede hacer uso del mismo de forma indiscriminada, sin tener en cuenta ninguna otra condici\xF3n.\r
\r
Ahora vamos a ver c\xF3mo, en funci\xF3n del estado de los recursos, cada uno de los hilos podr\xE1 realizar determinadas acciones o no, permitiendo que los hilos se queden a la espera de un cambio de estado que podr\xE1 ser notificado por otros hilos.\r
\r
Para ello, adem\xE1s de un mecanismo de bloque sobre los recursos compartidos, ser\xE1 necesario un mecanismo de espera para que, en el caso de que el estado de los recursos compartidos no permita a un hilo realizar una acci\xF3n, la ejecuci\xF3n del hilo quede en suspenso a la espera de que esa condici\xF3n se cumpla.\r
\r
El mecanismo es de **espera no activa**, es decir, no se debe consumir tiempo del procesador ni recursos del sistema para comprobar si es posible continuar con la ejecuci\xF3n, mientras no se reciba una notificaci\xF3n de que el estado ha cambiado y podr\xEDa permitir que el hilo contin\xFAe su ejecuci\xF3n.\r
\r
Esto tambi\xE9n nos permitir\xE1, colateralmente, controlar el orden de ejecuci\xF3n de los hilos en funci\xF3n de la relaci\xF3n que se establezca entre ellos.\r
\r
Para resolver este tipo de situaciones volvemos a utilizar m\xE9todos de la clase Object, accesibles para cualquier objeto.\r
\r
- **wait()**: interrumpe la ejecuci\xF3n del hilo actual. La ejecuci\xF3n del hilo queda bloqueada mientras otro hilo no ejecute el m\xE9todo notify(9 o notifyAll() sobre el objeto. Este m\xE9todo, por tanto, proporciona un mecanismo de espera no activa.\r
- **notify()**: desbloquea uno de los hilos que est\xE1n esperando sobre un objeto tras haber ejecutado el m\xE9todo wait()., de manera que pueda continuar su ejecuci\xF3n. Este m\xE9todo proporciona un mecanismo de notificaci\xF3n para terminar con la espera no activa de los hilos que est\xE1n a la espera de un objeto de bloqueo. **El orden en que se desbloquean los hilos en un objeto de bloqueo vuelve a ser indeterminista** y no tiene porqu\xE9 coincidir con el orden en que se bloquearon.\r
- **notifyAll()**: desbloquea todos los hilos que est\xE1n esperando sobre un objeto de bloqueo tras haber ejecutado el m\xE9todo wait(), de manera que puedan continuar su ejecuci\xF3n.\r
\r
wait , notify and notifyAll se utilizan para permitir a los hilos comunicarse entre ellos mediante un mecanismo de *signal&continue*.\r
\r
::: danger Contexto de ejecuci\xF3n de los m\xE9todos de sincronizaci\xF3n\r
**These methods need to be called from synchronized context**, otherwise it will throw java.lang.IllegalMonitorStateException.\r
:::\r
\r
Cuando se llama al m\xE9todo **wait()**, el hilo estar\xE1 dentro de un bloque sincronizado, por lo tanto tendr\xE1 el bloqueo del monitor. En ese momento el hilo libera el bloqueo de *ese monitor* y se queda en una **cola (perteneciente al objeto) de hilos en espera de ser notificados**, diferente a la de los hilos que est\xE1n esperando por el bloqueo.\r
\r
Cuando se desbloquea un hilo porque otro ha llamado a **notify()/notifyAll()**, el hilo vuelve al punto donde hizo el wait(), por lo tanto sigue dentro de un bloque sincronizado. Para poder continuar con la ejecuci\xF3n tendr\xE1 que pasar a la **cola de hilos esperando por el bloqueo** y esperar a ser seleccionado para seguir ejecut\xE1ndose.\r
\r
![Colas de un monitor](../../media/unit3/Monitor_queues.png)\r
\r
\`\`\`java\r
synchronized(objBloqueo)\r
{\r
  while(!condici\xF3nParaPoderSeguir) {\r
    try {\r
      // Espera que la condici\xF3n cambie y otro hilo avise\r
      objBloqueo.wait()\r
    } catch (InterruptedException e) {}\r
  }\r
\r
  // Si el hilo ha llegado hasta aqu\xED, significa que o bien al principio\r
  // o bien tras haber realizado una o m\xE1s esperas y haber sido notificado\r
  // de cambios por parte de otros hilos, la condici\xF3n se ha cumplido\r
\r
  // Adem\xE1s ha conseguido el bloqueo del monitor para poder continuar \r
  // dentro del bloque synchronized\r
  realizar_operaci\xF3n;\r
\r
  // Esta parte es opcional. La puede realizar este mismo hilo, en este \r
  // mismo m\xE9todo, o bien la puede realizar otro hilo en otro m\xE9todo\r
  if(condici\xF3nParaQueOtrosSigan) {\r
    objetoBloqueo.notify(); // o notifyAll()\r
  }  \r
}\r
\`\`\`\r
\r
En el ejemplo anterior, las condiciones suelen estar basadas en propiedades del propio objBloqueo, ya que de esta forma se mantiene un estado compartido por todos los hilos.\r
\r
Veamos ahora otro ejemplo\r
\r
\`\`\`java\r
// It is the common java class on which thread will act and call wait and notify method.\r
public class Book {\r
  String title;\r
  boolean isCompleted;\r
\r
  public Book(String title) {\r
    super();\r
    this.title = title;\r
  }\r
  public String getTitle() {\r
    return title;\r
  }\r
  public void setTitle(String title) {\r
    this.title = title;\r
  }\r
  public boolean isCompleted() {\r
    return isCompleted;\r
  }\r
  public void setCompleted(boolean isCompleted) {\r
    this.isCompleted = isCompleted;\r
  } \r
}\r
\`\`\`\r
\r
\`\`\`java{14,17}\r
// It will first take a lock on book object \r
// Then, the thread will wait until other thread call notify method, then after it will complete its processing. \r
// So in this example, it will wait for BookWriter to complete the book.\r
public class BookReader implements Runnable{\r
  Book book;\r
\r
  public BookReader(Book book) {\r
    super();\r
    this.book = book;\r
  }\r
\r
  @Override\r
  public void run() {\r
    synchronized (book) {\r
      System.out.println(Thread.currentThread().getName()+" is waiting for the book to be completed: "+book.getTitle());\r
      try {\r
        book.wait();\r
      } catch (InterruptedException e) {  \r
        e.printStackTrace();\r
      }\r
      System.out.println(Thread.currentThread().getName()+": Book has been completed now!! you can read it");\r
    }\r
  } \r
}\r
\`\`\`\r
\r
\`\`\`java{15,22,25}\r
// This class will notify thread(in case of notify) which is waiting on book object. \r
// It will not give away lock as soon as notify is called, it first complete its synchronized block. \r
// So in this example, BookWriter will complete the book and notify it to BookReaders. \r
public class BookWriter implements Runnable{\r
  Book book;\r
 \r
  public BookWriter(Book book) {\r
    super();\r
    this.book = book;\r
  }\r
 \r
  @Override\r
  public void run() {\r
    synchronized (book) {\r
      System.out.println("Author is Starting book : " +book.getTitle() );\r
      try {\r
        Thread.sleep(1000);\r
      } catch (InterruptedException e) {\r
        e.printStackTrace();\r
      }\r
      book.setCompleted(true);\r
      System.out.println("Book has been completed now");\r
 \r
      book.notify();\r
      System.out.println("notify one reader");\r
    } \r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{8,9,26}\r
// This is our main class which will create object of above classes and run it.\r
public class ThreadInterCommunicationMain {\r
\r
  public static void main(String args[])\r
  {\r
    // Book object on which wait and notify method will be called\r
    Book book=new Book("The Alchemist");\r
    BookReader johnReader=new BookReader(book);\r
    BookReader arpitReader=new BookReader(book);\r
\r
    // BookReader threads which will wait for completion of book\r
    Thread johnThread=new Thread(johnReader,"John");\r
    Thread arpitThread=new Thread(arpitReader,"Arpit");\r
\r
    arpitThread.start();\r
    johnThread.start();\r
\r
    // To ensure both readers started waiting for the book\r
    try {\r
      Thread.sleep(3000);\r
    } catch (InterruptedException e) {\r
      e.printStackTrace();\r
    }\r
\r
    // BookWriter thread which will notify once book get completed\r
    BookWriter bookWriter=new BookWriter(book);\r
    Thread bookWriterThread=new Thread(bookWriter);\r
    bookWriterThread.start();\r
  }\r
}\r
\`\`\`\r
\r
::: details Comentarios y preguntas sobre el c\xF3digo anterior\r
Si ejecutamos el c\xF3digo anterior, tenemos que hacernos varias preguntas:\r
\r
- \xBFCu\xE1ntos wait() se hacen? \xBFY cu\xE1ntos notify()?\r
 \r
Se est\xE1n haciendo 2 wait(), 1 por cada hilo BookReader y s\xF3lo un notify(), as\xED que algo no cuadra.\r
\r
Uno de los lectores se queda sin notificar, por lo tanto un hilo se queda esperando en un wait(). Como ese hilo no termina, el proceso tampoco. Hay que recordar que un proceso no termina hasta que lo hace el \xFAltimo de sus hilos. Esto en Netbeans implica que el programa no acaba y lo tenemos que parar.\r
\r
**Soluci\xF3n**: En este caso tenemos dos alternativas. La primera pasa por usar notifyAll() en vez de notify(). De esta forma los dos BookReader se activan y se quedan a la espera de poder tomar el bloqueo del monitor. Uno lo har\xE1 primero y el otro despu\xE9s, pero los dos acabar\xE1n leyendo el libro.\r
La otra opci\xF3n es, siguiendo con notify(), que cada lector cuando acabe de leer el libro notifique a otros posibles lectores que haya en espera para que uno se despierte y lea el libro.\r
\r
- En el main hemos hecho que primero empiecen los BookReaders y una vez que est\xE1n esperando el BookWriter escriba el libro y avise. \xBFQu\xE9 pasa si lo hacemos al rev\xE9s o si los lanzamos todos juntos y no sabemos en qu\xE9 orden se van a ejecutar?\r
\r
Si lanzamos primero el BookWriter, este acaba el libro y notifica a... nadie, porque los BookReaders todav\xEDa no estar\xE1n esperando. Despu\xE9s llegar\xE1n los BookReaders y se quedar\xE1n los dos colgados, ya que ning\xFAn otro hilo les notificar\xE1.\r
\r
**Soluci\xF3n**: Los hilos ahora mismo se est\xE1n bloqueando de manera indiscriminada, pero realmente deben bloquearse s\xF3lo si el libro que quieren leer no est\xE1 acabado. Por lo tanto tenemos que controlar con una condici\xF3n el bloqueo de los BookReader. Tal y como hemos comentado las condiciones las debe tener el objeto compartido, en este caso book, que lo comparten el BookWriter y los dos BookReader. La condici\xF3n que nos sirve para discriminar si un BookReader puede continuar o no es la propiedad isCompleted que consultamos a trav\xE9s del m\xE9todo book.isCompleted(),\r
\r
\`\`\`java\r
try {\r
  if (!book.isCompleted())\r
    book.wait();\r
} catch (InterruptedException e) { \r
\`\`\`\r
\r
Con esos dos cambios la aplicaci\xF3n deber\xEDa funcionar con cualquier n\xFAmero de BookReaders y de BookWriters, sin importar el orden ni la cantidad.\r
:::\r
\r
::: info \xBFnotify() o notifyAll()?\r
Todo depender\xE1 del sistema que estemos programando, pero por norma general, si queremos que tras modificar el estado del sistema s\xF3lo contin\xFAe un hilo, llamaremos a notify().\r
\r
Sino, deber\xEDa utilizarse notifyAll(). Si todo est\xE1 bien programado el hilo comprobar\xE1 si puede seguir y, en caso contrario, volver\xE1 a hacer un wait() y seguir esperando, por eso no supone un problema que que m\xE1s de un hilo se active.\r
\r
El uso de notify() supone un mayor riesgo de que se produzcan bloqueos indefinidos de hilos a la espera de notificaciones que nunca van a llegar, siendo este bloqueo diferente de un interbloqueo o deadlock. Debemos ser muy cuidadosos con la programaci\xF3n de los mecanismos de sincronizaci\xF3n.\r
\r
Hay que tener en cuenta tambi\xE9n que deber\xEDa haber al menos una llamada notify() por cada wait() que se haya realizado, aunque eso tampoco asegura que alg\xFAn hilo no se quede bloqueado.\r
:::\r
\r
::: question Modifica el ejemplo Sumador-Restador\r
has las modificaciones necesarias en las clases del proyecto U3S3_SharedMemory (gu\xE1rdalo como U3S3_SharedMemory_v2) para que:\r
\r
- El primer hilo que haga una operaci\xF3n sobre el contador sea un Sumador\r
- Despu\xE9s de un Sumador siempre se ejecute un Restador y despu\xE9s de un Restador siempre se ejecute un Sumador, haciendo una secuencia Sumador-Restador-Sumador-Restador-...\r
:::\r
\r
::: details U3S3_SharedMemory_v2\r
\r
\`\`\`java\r
public class Contador {\r
\r
    private int c = 0;\r
    boolean ahoraSumador = true;\r
\r
    public Contador(int c) {\r
        this.c = c;\r
        ahoraSumador = true;\r
    }\r
\r
    public synchronized void incrementa() {\r
        while (!ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) {\r
            }\r
        }\r
\r
        // El hilo hace su tarea\r
        c++;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = false;\r
        notifyAll();\r
\r
    }\r
\r
    public synchronized void decrementa() {\r
        while (ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) { }\r
        }\r
\r
        // El hilo hace su tarea\r
        c--;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = true;\r
        notifyAll();\r
    }\r
\r
    public int valor() {\r
        return c;\r
    }\r
}\r
\`\`\`\r
\r
En la clase Contador hemos incorporado un estado, que controla qu\xE9 hilo es el que puede ejecutar y cu\xE1l el que tiene que esperar.\r
\r
Adem\xE1s, como se comenta m\xE1s adelante, se ha movido la salida de los hilos a los m\xE9todos de esta clase.\r
\r
\`\`\`java\r
public class Restador  implements Runnable {\r
    private Contador c;\r
    private String name;\r
    public Restador(String name, Contador c) {\r
        // super(name);\r
        this.name = name;\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        Thread.currentThread().setName(this.name);\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.decrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }        \r
    }\r
}\r
\`\`\`\r
\r
Tanto Restador como Sumador siguen siendo pr\xE1cticamente id\xE9nticos.\r
\r
\`\`\`java\r
public class Sumador  extends Thread {\r
    private Contador c;\r
    public Sumador(String name, Contador c) {\r
        super(name);\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.incrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }\r
    }\r
}\r
\`\`\`\r
\r
La clase principal se mantiene igual.\r
\r
::: danger Salida sincronizada\r
Como se puede observar, la salida que en el ejemplo original se realizaba en el m\xE9todo run de Sumador y Restador, ahora se ha movido a la clase Contador, en concreto a los m\xE9todos \`synchronized\`.\r
\r
Hay que tener cuidado con la salida por pantalla. Todos los threads est\xE1n usando System.out a la vez y los resultados que se muestran por pantalla, concretamente el orden en el que se muestran, no siempre es el mismo orden en el que se han producido. Por eso es importante que las salidas de los hilos se muevan dentro de los bloques sincronizados.\r
\r
Si no controlamos la forma de mostrar la salida podemos encontrarnos con problemas que est\xE1n bien resueltos pero que la salida nos dice lo contrario.\r
:::\r
\r
`]},{title:"4 Introducci\xF3n",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit4/",pathLocale:"/es/",extraFields:[`---\r
title: 4 Introducci\xF3n\r
---\r
\r
# Tema 4. Programaci\xF3n en red\r
\r
Hasta ahora hemos visto como varias aplicaciones pueden colaborar entre s\xED para realizar una tarea de forma conjunta (\`multiproceso\`) o bien c\xF3mo un mismo programa puede dividir una tarea en partes que se ejecuten de forma concurrente y simult\xE1nea (\`multihilo\`). Todo esto ocurre dentro de una m\xE1quina, bien sea en **monoprocesador** o **multiprocesador**, controlados por un mismo SO y compartiendo habitualmente parte de la memoria y de la E/S.\r
\r
En este tema vamos a ir un paso m\xE1s all\xE1, vamos a crear aplicaciones que funcionen en entornos distribuidos. Volvemos a tener m\xFAltiples procesos en ejecuci\xF3n, pero a diferencia de lo que vimos en el tema 2, en el que los procesos ten\xEDan una relaci\xF3n padre-hijo (lanzador-lanzado), ahora los procesos se van a ejecutar en sistemas independientes y se comunicar\xE1n a trav\xE9s de la red usando \`protocolos de comunicaci\xF3n\`.\r
\r
Podemos encontrar b\xE1sicamente dos modelos de sistemas distribuidos:\r
\r
- **Cliente / Servidor**: un proceso, denominado \`servidor\`, ofrece servicios a uno o m\xE1s procesos, denominados \`clientes\`.\r
- **Entre iguales (P2P)**: todos los procesos colaboran de forma similar y con un mismo fin, no existiendo una especializaci\xF3n ni diferenciaci\xF3n entre ellos..\r
\r
::: warning Procesos e Hilos\r
Para realizar un programa distribuido en el que se pueda realizar una conexi\xF3n y una comunicaci\xF3n a trav\xE9s de una red de ordenadores no partimos de cero. \r
\r
La programaci\xF3n en red est\xE1 fuertemente ligada a la programaci\xF3n multiproceso. Principalmente en la forma de comunicaci\xF3n que ya vimos entre procesos.\r
\r
Por otro lado, la especializaci\xF3n y el servicio que ofrece un servidor, de forma simult\xE1nea a varios clientes, est\xE1 basada en la divisi\xF3n del trabajo en hilos.\r
\r
Por todo lo comentado, todos los conceptos y conocimientos adquiridos hasta ahora nos sirven de base para avanzar en los contenidos de este tema.\r
:::\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Conocer el protocolo TCP/IP, las direcciones usadas en cada capa y y los protocolos asociados.\r
- Conocer las clases que permiten trabajar con direcciones y nombres de servidores.\r
- Aprender las caracter\xEDsticas b\xE1sicas de los protocolos TCP y UDP.\r
- Desarrollar aplicaciones b\xE1sicas que se comuniquen usando el protocolo TCP.\r
- Desarrollar aplicaciones b\xE1sicas que se comuniquen usando el protocolo UDP.\r
- Dise\xF1ar y programar protocolos para la comunicaci\xF3n entre aplicaciones distribuidas.\r
- Coordinar la ejecuci\xF3n de m\xFAltiples clientes en servidores multihilo.\r
`]},{title:"4.3 Sockets TCP",headers:[{level:2,title:"4.3.1. Comunicaci\xF3n cliente/servidor con sockets TCP",slug:"_4-3-1-comunicacion-cliente-servidor-con-sockets-tcp",link:"#_4-3-1-comunicacion-cliente-servidor-con-sockets-tcp",children:[{level:3,title:"Programaci\xF3n de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.3.2. Cliente TCP",slug:"_4-3-2-cliente-tcp",link:"#_4-3-2-cliente-tcp",children:[{level:3,title:"Streams para E/S en los sockets",slug:"streams-para-e-s-en-los-sockets",link:"#streams-para-e-s-en-los-sockets",children:[]}]},{level:2,title:"4.3.3 Servidor TCP",slug:"_4-3-3-servidor-tcp",link:"#_4-3-3-servidor-tcp",children:[]},{level:2,title:"4.3.4 Servidor multihilo",slug:"_4-3-4-servidor-multihilo",link:"#_4-3-4-servidor-multihilo",children:[]}],path:"/es/unit4/sockets-tcp.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.3 Sockets TCP\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.3 Sockets TCP" />\r
\r
# 4.3 Sockets TCP\r
\r
[[toc]]\r
\r
## 4.3.1. Comunicaci\xF3n cliente/servidor con sockets TCP\r
\r
Oracle ha resumido el uso de los sockets en un breve tutorial. Todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about sockets](https://docs.oracle.com/javase/tutorial/networking/sockets/index.html)\r
\r
La interfaz Java que da soporte a sockets TCP est\xE1 constituida por las clases **ServerSocket** y **Socket**.\r
\r
- ServerSocket: es utilizada por un servidor para crear un socket en el puerto en el que escucha las peticiones de conexi\xF3n de los clientes. Su m\xE9todo \`accept\` toma una petici\xF3n de conexi\xF3n de la cola, o si la cola est\xE1 vac\xEDa, se bloquea hasta que llega una petici\xF3n.\r
  \r
  El resultado de ejecutar accept es una instancia de Socket, a trav\xE9s del cual el servidor tiene acceso a los datos enviados por el cliente.\r
\r
- Socket: es utilizada tanto por el cliente como por el servidor. El cliente crea un socket especificando el nombre DNS del host y el puerto del servidor, as\xED se crea el socket local y adem\xE1s se conecta con el servicio.\r
  \r
  Esta clase proporciona los m\xE9todos \`getInputStream\` y \`getOutputStream\` para acceder a los dos streams asociados a un socket (recordemos que son bidireccionales), y devuelve tipos de datos InputStream y OutputStream, respectivamente, a partir de los cuales podemos construir \`BufferedReader\` y \`PrintWriter\`, respectivamente, para poder procesar los datos de forma m\xE1s sencilla.\r
\r
### Programaci\xF3n de aplicaciones Cliente y/o Servidor\r
\r
Al crear aplicaciones cliente y servidor puede que nos encontremos con varios escenarios, a saber:\r
\r
- Si tenemos que programar solo el servidor **deberemos definir un protocolo** de comunicaci\xF3n para usar ese servidor.\r
- Si tenemos que programar solo el cliente **necesitaremos conocer el protocolo** de comunicaci\xF3n para conectar con ese servidor.\r
- Si tenemos que programar el cliente y el servidor, tendremos que empezar por **definir el protocolo** de comunicaci\xF3n entre ambos.\r
\r
::: info Herramientas para definir los protocolos\r
Dentro de todos los diagramas que ofrece UML, el diagrama de secuencia es el que mejor se adapta para definir los protocolos de comunicaci\xF3n entre clases y las interacciones que se producen.\r
\r
Para crear estos diagramas existen multitud de herramientas, tanto de escritorio como online. De todas ellas cabe destacar:\r
\r
- [Mermaid Live editor](https://mermaid.live/) que usa una [sintaxis en modo texto](https://mermaid-js.github.io/mermaid/#/sequenceDiagram) para definir los diagramas.\r
- [WebSequenceDiagrams](https://www.websequencediagrams.com/): M\xE1s visual y tambi\xE9n con una definici\xF3n textual de los diagramas.\r
- [Visual Paradigm Online](https://online.visual-paradigm.com/drive/#diagramlist:proj=0&dashboard): Herramienta totalmente visual y con unos resultados m\xE1s espectaculares.\r
\r
Estas herramientas son las que ten\xE9is que usar en las actividades en las que se os pida definir un protocolo de comunicaci\xF3n cliente / servidor.\r
:::\r
\r
## 4.3.2. Cliente TCP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente ser\xE1:\r
\r
1. Crear un objeto de la clase Socket, indicando host y puerto donde corre el servicio.\r
2. Obtener las referencias al stream de entrada y al de salida al socket.\r
3. Leer desde y escribir en el stream de acuerdo al protocolo del servicio. Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar el socket.\r
\r
\`\`\`java{12,14,17,36,38,51,52,54}\r
public class BasicClient {\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que est\xE1 en la misma m\xE1quina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket("localhost", 4444);\r
            // Obtenemos el canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexi\xF3n");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenv\xEDa al servidor hasta que este\r
        // se despide con "Adios"\r
        try {\r
            while (true) {\r
                // Leo la entrada del usuario\r
                linea = stdIn.nextLine();\r
                // La envia al servidor por el OutputStream\r
                salida.println(linea);\r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Env\xEDa a la salida est\xE1ndar la respuesta del servidor\r
                System.out.println("Respuesta servidor: " + linea);\r
                // Si es "Adios" es que finaliza la comunicaci\xF3n\r
                if (linea.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
\r
        // Libera recursos\r
        salida.close();\r
        entrada.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\r
\`\`\`\r
::: info Herramientas para simular clientes gen\xE9ricos\r
Si s\xF3lo tenemos que desarrollar un servidor y no tenemos o no queremos hacer un cliente para las pruebas, tenemos varias herramientas que nos ayudan a hacer de clientes gen\xE9ricos, \xFAtiles para una gran variedad de servidores, incluso para servidores est\xE1ndar como FTP, HTTP, etc.\r
\r
La primera herramienta es una aplicaci\xF3n y un protocolo de nivel de aplicaci\xF3n de TCP/IP, es la herramienta \`Telnet\`.\r
\r
Esta herramienta suele venir instalada en los sistemas GNU/Linux y OS X. Sin embargo en los sistemas Windows viene deshabilitada por defecto.\r
\r
Os dejo un enlace al art\xEDculo de Xataka [Telnet: qu\xE9 es y c\xF3mo activarlo en Windows 10](https://www.xataka.com/basics/telnet-que-como-activarlo-windows-10).\r
\r
Es importante que lo activ\xE9is tanto en clase como en el aula.\r
\r
La segunda herramienta es NetCat. Es una herramienta muy vers\xE1til y potente, ya que no s\xF3lo puede hacernos de cliente, sino que tambi\xE9n puede servir como servidor.\r
\r
Como muchas otras herramientas, esta tambi\xE9n viene instalada de serie en GNU/Linux y OS X, pero no en Windows. Su uso en los sistemas de Microsoft es algo m\xE1s controvertido ya que el sistema la detecta como un virus y tenemos que habilitar su uso en el *Guardian* del SO.\r
\r
Os dejo tambi\xE9n un enlace a este art\xEDculo de IONOS [\xBFQu\xE9 es Netcat y c\xF3mo funciona?](https://www.ionos.es/digitalguide/servidores/herramientas/netcat/)\r
:::\r
\r
### Streams para E/S en los sockets\r
\r
Si vemos ejemplos en Internet o en tutoriales, podemos observar que hay dos formas mayoritarias de enviar y recibir la informaci\xF3n a trav\xE9s de los streams que proporciona un socket.\r
\r
![Basic Stream IO](../../media/unit4/basicIOStreams.png)\r
\r
En cualquier caso, a trav\xE9s de los streams enviamos bytes, que es la forma m\xE1s b\xE1sica de generar informaci\xF3n, bien sea a trav\xE9s de la red o entre procesos.\r
\r
Como es complicado gestionar a nivel de bytes toda la informaci\xF3n que queremos enviar o recibir, usamos \`Decorators\` o \`Wrappers\` para enviar tipos de datos de un nivel de abstracci\xF3n mayor.\r
\r
En los temas anteriores, cuando hemos tenido que intercambiar informaci\xF3n entre procesos, hemos estado usando BufferedReader y PrintWriter. Estas clases trabajan a nivel de Strings, y son muy \xFAtiles cuando lo que queremos intercambiar a trav\xE9s de los streams son cadenas de texto.\r
\r
> En los protocolos de comunicaciones, m\xE1s del 90% de la informaci\xF3n que se intercambia, a nivel de protocolo, es en formato texto.\r
\r
Sin embargo, puede haber ocasiones en las que nos interese trabajar con tipos de datos. \r
\r
\`DataInputStream\` y \`DataOutputStream\` proporcionan m\xE9todos para leer y escribir Strings y todos los tipos de datos primitivos de Java, incluyendo n\xFAmeros y valores booleanos. \r
\r
![Basic Stream IO](../../media/unit4/streamWrappers.png)\r
\r
DataOutputStream codifica esos valores de forma independiente de la m\xE1quina y los env\xEDa al stream de m\xE1s bajo nivel para que los gestione como bytes. DataInputStream hace lo contrario.\r
\r
As\xED, podemos trabajar con DataInputStream y DataOutputStream a partir de los streams que nos proporcionan los sockets\r
\r
\`\`\`java\r
// C\xF3digo en el cliente\r
DataInputStream dis = new DataInputStream(socket.getInputStream());\r
dis.readDouble();\r
\r
// C\xF3digo en el servidor\r
DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\r
dis.writeDouble(number);\r
\`\`\`\r
\r
Los m\xE9todos \`readUTF()\` and \`writeUTF()\` de DataInputStream y DataOutputStream leen y escriben un String de caracteres Unicode usando la codificaci\xF3n UTF-8.\r
\r
::: warning Elige un m\xE9todo y usa siempre el mismo\r
Es muy importante no mezclar diferentes wrappers en el mismo sistema. Aunque todos acaban utilizando el InputStream y el OutputStream, las codificaciones y la forma de enviar la informaci\xF3n no es la misma.\r
\r
Por lo que, si usas DataInputStream en el cliente para leer, debes usar DataOutputStream en el servidor para enviar. Adem\xE1s de usar los m\xE9todos complementarios para la lectura y escritura, por ejemplo readInt / writeInt.\r
:::\r
\r
Informaci\xF3n extra\xEDda de [Learning Java, 4th Edition - O'Reilly](https://www.oreilly.com/library/view/learning-java-4th/9781449372477/ch12s01.html)\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.3 Servidor TCP\r
\r
La forma de implementar un servidor ser\xE1:\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_states.png)\r
\r
1. Crear un objeto de la clase ServerSocket para escuchar peticiones en el puerto asignado al servicio.\r
2. Esperar solicitudes de clientes\r
3. Cuando se produce una solicitud:\r
    - Aceptar la conexi\xF3n obteniendo un objeto de la clase Socket\r
    - Obtener las referencias al stream de entrada y al de salida al socket anterior.\r
    - Leer datos del socket, procesarlos y enviar respuestas al cliente, escribiendo en el stream del socket.Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar los sockets.\r
\r
\`\`\`java{9,23,26,29,36,40,50,51,52,53}\r
public class BasicServer {\r
\r
    public static final int PORT = 4444;\r
\r
    public static void main(String[] args) throws IOException {\r
        // Establece el puerto en el que escucha peticiones\r
        ServerSocket socketServidor = null;\r
        try {\r
            socketServidor = new ServerSocket(PORT);\r
        } catch (IOException e) {\r
            System.out.println("No puede escuchar en el puerto: " + PORT);\r
            System.exit(-1);\r
        }\r
\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        System.out.println("Escuchando: " + socketServidor);\r
        try {\r
            // Se bloquea hasta que recibe alguna petici\xF3n de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexi\xF3n aceptada: " + socketCliente);\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Hace eco de lo que le proporciona el cliente, hasta que recibe "Adios"\r
            while (true) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
                // Env\xEDa a la salida est\xE1ndar el mensaje del cliente\r
                System.out.println("Cliente: " + str);\r
                // Le env\xEDa la respuesta al cliente por el OutputStream                \r
                salida.println(str);\r
                // Si es "Adios" es que finaliza la comunicaci\xF3n\r
                if (str.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
        salida.close();\r
        entrada.close();\r
        socketCliente.close();\r
        socketServidor.close();\r
    }\r
\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_sequence.png)\r
\r
El servidor monohilo se encarga de realizar las operaciones de E/S con el cliente. Hasta que no acaba no puede hacer otro \`accept\` y atender a otro cliente.\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.4 Servidor multihilo\r
\r
Si queremos que un servidor pueda atender varias peticiones de forma simultanea, debemos usar hilos para dotarle de esa capacidad.\r
\r
El flujo b\xE1sico ahora cambiar\xEDa para adaptarse a este formato\r
\r
\`\`\`\r
while (true) {\r
\r
    Aceptar la conexi\xF3n obteniendo un objeto de la clase Socket;\r
\r
    Crear un thread para que se encargue de la comunicaci\xF3n con ese cliente, es decir, \r
    para que gestione el socket obtenido en el accept.;\r
}\r
\`\`\`\r
![Estados de un servidor multihilo](../../media/unit4/multithread_server_states.png)\r
\r
El servidor multihilo crea un nuevo hilo que se encarga de las operaciones de E/S con el cliente. Mientras tanto puede esperar la conexi\xF3n de nuevos clientes con los que volver\xE1 a hacer lo mismo.\r
\r
El servidor multihilo se ayuda de una clase \`Worker\` que hereda de Thread, pudiendo as\xED ejecutarse concurrentemente con el hilo principal.\r
\r
Esta clase \`Worker\` es la encargada de realizar toda la comunicaci\xF3n con el cliente y el servidor. Para poder hacerlo, en su constructor recibe el Socket que se crea cuando se recibe  la conexi\xF3n de un cliente \`ServerSocket.accept()\`.\r
\r
\`\`\`java {6,20,24}\r
public static final int PORT = 4444;\r
public static void main(String[] args)  {\r
    // Establece el puerto en el que escucha peticiones\r
    ServerSocket socketServidor = null;\r
    try {\r
        socketServidor = new ServerSocket(PORT);\r
    } catch (IOException e) {\r
        System.out.println("No puede escuchar en el puerto: " + PORT);\r
        System.exit(-1);\r
    }\r
\r
    Socket socketCliente = null;\r
\r
    System.out.println("Escuchando: " + socketServidor);\r
    try {\r
        \r
        while (true) {\r
            // Se bloquea hasta que recibe alguna petici\xF3n de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexi\xF3n aceptada: " + socketCliente);\r
            // Para seguir aceptando peticiones de otros clientes\r
            // se crea un nuevo hilo que se encargar\xE1 de la comunicaci\xF3n con el cliente\r
            new Worker(socketCliente).start();\r
        }\r
                        \r
    ...\r
}    \r
\`\`\`\r
\r
Y esta ser\xEDa una implementaci\xF3n est\xE1ndar de un worker\r
\r
\`\`\`java{13,15,22,26}\r
public class Worker extends Thread {\r
\r
    private Socket socketCliente;\r
    private BufferedReader entrada = null;\r
    private PrintWriter salida = null;\r
\r
    ....\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Realizamos la comunicaci\xF3n entre servidor y cliente\r
            // **** ES LO QUE CAMBIA EN CADA EJERCICIO ****\r
\r
            // Hacemos una recepci\xF3n de informaci\xF3n desde el cliente\r
            String mensajeRecibido = entrada.readLine();\r
            System.out.println("<-- Cliente: " + mensajeRecibido);\r
            \r
            // Hacemos un env\xEDo al cliente\r
            String mensajeEnviado = "Mensaje enviado desde el servidor al cliente";\r
            salida.println(mensajeEnviado);\r
            System.out.println("--> Cliente: " + mensajeEnviado);\r
        }\r
        ....\r
}        \r
\`\`\`\r
\r
Quedando ahora la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/multithread_server_sequence.png)\r
\r
<div class="pagebreak"> </div>\r
\r
::: info Ejecuci\xF3n de m\xFAltiples clientes desde l\xEDnea de comandos\r
Para poder lanzar varias aplicaciones java a la vez, la forma m\xE1s correcta de hacerlo es desde una terminal de comandos. Esto nos permite poder pasarle argumentos a todas las clases, no s\xF3lo a la que est\xE1 marcada como *principal* en el proyecto.\r
\r
Aqu\xED tenemos dos posibilidades, **ejecutar las clases individualmente**, tal y como hacemos desde el IDE o bien **lanzar las clases desde un archivo JAR**.\r
\r
En ambos casos, necesitamos haber compilado y construido el proyecto (*F11 \xF3 Shift+F11 en Netbeans*).\r
\r
Ejecuci\xF3n de clases individuales\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener las clases compiladas.\r
- A continuaci\xF3n, al igual que hac\xEDamos con los procesos, debemos ubicarnos en la carpeta \`build/classes\` del proyecto.\r
- Desde ah\xED, ejecutaremos\r
    > build/classes$ java psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuaci\xF3n del nombre de la clase son los par\xE1metros que la clase recibir\xE1 en el args[] de su m\xE9todo main.\r
\r
    y para la clase o clases que no sean las principales\r
    > build/classes$ java psp.actividades.U4AX_ClaseSCliente localhost 5566\r
\r
    Si queremos lanzar m\xE1s de un cliente, repetiremos el comando desde otra ventana de comandos.\r
\r
Lanzar las clases desde un archivo JAR\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener el proyecto construido\r
- A continuaci\xF3n, y a diferencia del caso anterior, debemos ubicarnos en el directorio donde est\xE9 el archivo JAR. Si no lo hemos movido, estar\xE1 en la carpeta \`dist\` del proyecto.\r
- Desde ah\xED, ejecutaremos, **para la clase principal del proyecto**\r
    > dist$ java -jar U4AX_ProyectoClienteServidor.jar 5566\r
\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuaci\xF3n del nombre de la clase son los par\xE1metros que la clase recibir\xE1 en el args[] de su m\xE9todo main.\r
\r
    y para la clase o clases que no sean las principales\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseCliente localhost 5566\r
\r
    Si queremos lanzar m\xE1s de un cliente, repetiremos el comando desde otra ventana de comandos.\r
:::`]},{title:"4.4 Sockets UDP",headers:[{level:2,title:"4.4.1. Comunicaci\xF3n cliente/servidor con sockets UDP",slug:"_4-4-1-comunicacion-cliente-servidor-con-sockets-udp",link:"#_4-4-1-comunicacion-cliente-servidor-con-sockets-udp",children:[{level:3,title:"DatagramSocket",slug:"datagramsocket",link:"#datagramsocket",children:[]},{level:3,title:"DatagramPacket",slug:"datagrampacket",link:"#datagrampacket",children:[]},{level:3,title:"Programaci\xF3n de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.4.2. Cliente UDP",slug:"_4-4-2-cliente-udp",link:"#_4-4-2-cliente-udp",children:[]},{level:2,title:"4.4.3 Servidor UDP",slug:"_4-4-3-servidor-udp",link:"#_4-4-3-servidor-udp",children:[]},{level:2,title:"4.4.4 Multicast socket",slug:"_4-4-4-multicast-socket",link:"#_4-4-4-multicast-socket",children:[]}],path:"/es/unit4/sockets-udp.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.4 Sockets UDP\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.4 Sockets UDP" />\r
\r
# 4.4 Sockets UDP\r
\r
[[toc]]\r
\r
## 4.4.1. Comunicaci\xF3n cliente/servidor con sockets UDP\r
\r
Igual que en el apartado anterior, Oracle proporciona una gu\xEDa son informaci\xF3n b\xE1sica sobre el uso de los Sockets UDP. De nuevo, todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about datagrams](https://docs.oracle.com/javase/tutorial/networking/datagrams/index.html)\r
\r
::: info UDP - Protocolo sin conexi\xF3n\r
El protocolo de comunicaciones con \`datagramas\` UDP, es un protocolo sin conexi\xF3n, es decir, cada vez que se env\xEDen datagramas es necesario enviar el descriptor del socket local y la direcci\xF3n del socket que debe recibir el datagrama. Como se puede ver, hay que enviar datos adicionales cada vez que se realice una comunicaci\xF3n.\r
\r
Se trata de un servicio de transporte sin conexi\xF3n. Son m\xE1s eficientes que TCP, pero no est\xE1 garantizada la fiabilidad: los datos se env\xEDan y reciben en paquetes, cuya entrega no est\xE1 garantizada; los paquetes pueden ser duplicados, perdidos o llegar en un orden diferente al que se envi\xF3.\r
:::\r
\r
La interfaz Java que da soporte a sockets TCP est\xE1 constituida por las clases **DatagramPacket** y **DatagramSocket**.\r
\r
- DatagramSocket: es la clase utilizada para realizar el env\xEDo y la recepci\xF3n de los datos. A diferencia de los sockets TCP, esta clase no es la encargada de gestionar las direcciones ni de realizar la conexi\xF3n, s\xF3lo se encarga de transportar los datos del origen al destino.\r
\r
    Lo \xFAnico que se hace es enviar los datos, mediante la creaci\xF3n de un socket y utilizando los m\xE9todos de env\xEDo y recepci\xF3n apropiados.\r
\r
    Esta clase proporciona los m\xE9todos \`send\` y \`receive\`.\r
\r
- DatagramPackets: esta clase es la encargada de incluir la informaci\xF3n que se quiere enviar/recibir y la informaci\xF3n de direccionamiento, es decir, la direcci\xF3n a la que se quiere enviar l informaci\xF3n que contiene.\r
  \r
   DatagramPacket contiene la informaci\xF3n relevante. Cuando se desea recibir un datagrama, \xE9ste deber\xE1 almacenarse bien en un buffer o un array de bytes. Y cuando preparamos un datagrama para ser enviado, el DatagramPacket no s\xF3lo debe tener la informaci\xF3n, sino que adem\xE1s debe tener la direcci\xF3n IP y el puerto de destino.\r
\r
::: warning Puertos duplicados UDP / TCP\r
Dado que la gesti\xF3n de los puertos y el protocolo que se utiliza es diferente, podemos usar el mismo n\xFAmero de puerto para un servicio que use el protocolo TCP y otro servicio, en el mismo puerto, que use UDP.\r
\r
En realidad, un socket adem\xE1s de IP_origen, Puerto_origen, IP_destino, Puerto_destino, tambi\xE9n incluye el protocolo usado, por eso un socket con el mismo origen y destino, es diferente y puede ser usado a al vez por UDP y TCP\r
\r
**Socket = [Protocolo (TCP/UDP) + IP_origen + Puerto_origen + IP_destino + Puerto_destino]**\r
:::\r
\r
### DatagramSocket\r
\r
Esta clase proporciona los siguiente m\xE9todos\r
\r
| M\xE9todo | Descripci\xF3n |\r
| --- | ----------- |\r
| public DatagramSocket () throws SocketException | Se encarga de construir un socket para datagramas y de conectarlo al primer puerto disponible. |\r
| public DatagramSocket (int port) throws SocketException | \xCDdem, pero con la salvedad de que permite especificar el n\xFAmero de puerto asociado. |\r
| public DatagramSocket (int port, InetAddress ip) throws SocketException | Permite especificar, adem\xE1s del puerto, la direcci\xF3n local a la que se va a asociar el socket. |\r
| public int getLocalPort() | Retorna el n\xFAmero de puerto en el host local al que est\xE1 conectado el socket. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Env\xEDa un DatagramPacket a trav\xE9s del socket. |\r
| **public setSoTimeout(int timeout)** | Permite establecer un tiempo de espera l\xEDmite para que el m\xE9todo receive se quede bloqueado esperando a recibir una respuesta por parte del otro extremo. Si no reciben datos en el tiempo fijado se lanza la excepci\xF3n \`InterruptedIOException\` |\r
\r
El DatagramSocket, cuando se utiliza en la parte receptora (la que vamos a llamar servidora) que ofrece el servicio para que los clientes se conecten, s\xF3lo va a indicar el puerto al que esos clientes deben enviar sus solicitudes. En el caso de los procesos que act\xFAen como clientes, se usar\xE1 el constructor sin par\xE1metros para que sea el SO el que asigne un puerto libre.\r
\r
Por lo tanto, un mismo DatagramSocket al no incluir ninguna informaci\xF3n de direccionamiento puede ser reutilizado para enviar y/o recibir datagramas a/desde diferentes destinos.\r
\r
### DatagramPacket\r
\r
La clase \`DatagramPacket\` como se ha indicado anteriormente, es un contenedor del mensaje y del destino de ese mensaje.\r
\r
![Datagram Packet](../../media/unit4/datagrampacket.svg)\r
\r
Esta clase proporciona los siguiente m\xE9todos\r
\r
| M\xE9todo | Descripci\xF3n |\r
| --- | ----------- |\r
| public DatagramPacket(byte ibuf[], int  ilength)  | Implementa un DatagramPacket para la **recepci\xF3n** de paquetes de longitud ilength, siendo el valor de este par\xE1metro menor o igual que ibuf.length. |\r
| public DatagramPacket(byte ibuf[], int ilength, InetAddress iaddr, int iport)  | Implementa un DatagramPacket para el **env\xEDo** de paquetes de longitud ilength al n\xFAmero de puerto especificado en el par\xE1metro iport, del host especificado en la direcci\xF3n de destino que se le pasa por medio del par\xE1metro iaddr. |\r
| public InetAddress getAddress () | Retorna la direcci\xF3n IP del host al cual se le env\xEDa el datagrama o del que el datagrama se recibi\xF3. |\r
| public byte[] getData() | Retorna los **datos a recibir** o a enviar. |\r
| public int getLength() | Retorna la longitud de los datos a enviar o a recibir. |\r
| public int getPort() | Retorna el n\xFAmero de puerto de la m\xE1quina remota a la que se le va a enviar el datagrama o del que se recibi\xF3. |\r
\r
Como se intuye de la descripci\xF3n de los m\xE9todos, la forma de crear el datagrama va a depender de si queremos enviar o recibir la informaci\xF3n, ya que en cada uno de estas acciones tendremos que indicar d\xF3nde van dirigidos esos datos (env\xEDo) o bien esa informaci\xF3n ya vendr\xE1 incluida en el datagrama (recepci\xF3n) y podremos acceder a ella a trav\xE9s de los m\xE9todos getter de la clase.\r
\r
Es importante hacer ver que la informaci\xF3n debe enviarse como un array de bytes y que se recibe de la misma forma, por lo que tendremos que usar los m\xE9todos de String o de cualquiera de los otros tipos primitivos de Java para convertirlos a bytes.\r
\r
### Programaci\xF3n de aplicaciones Cliente y/o Servidor\r
\r
En el caso de aplicaciones UDP, el protocolo de comunicaci\xF3n no tiene sentido a nivel de capa de transporte, ya que s\xF3lo se env\xEDan y reciben mensajes y hablamos de un \`protocolo no orientado a conexi\xF3n\`, por lo tanto no sirve para realizar confirmaciones o di\xE1logos entre la parte servidora y cliente.\r
\r
La parte del protocolo se delega en una capa superior, que ser\xE1 la encargada de gestionar la comunicaci\xF3n a un nivel de abstracci\xF3n mayor.\r
\r
De todas formas, la comunicaci\xF3n entre ambas partes debe seguir estando sincronizada en los que a env\xEDos / respuestas se refiere para no dejar a la otra parte bloqueada en las lecturas.\r
\r
::: info Bloqueo de lecturas con timeout\r
Esta caracter\xEDstica, tambi\xE9n disponible para los sockets TCP, permite evitar un bloqueo infinito de un hilo a la espera de recibir datos del otro extremo del socket.\r
\r
Es de especial importancia en la gesti\xF3n de las comunicaciones UDP ya que, como hemos dicho, no tienen porqu\xE9 seguir un protocolo preestablecido a nivel de transporte.\r
\r
Con el m\xE9todo \`setSoTimeout\` de DatagramSocket podemos fijar un tiempo de espera m\xE1ximo para la recepci\xF3n de datos a trav\xE9s del socket.\r
:::\r
\r
## 4.4.2. Cliente UDP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente ser\xE1:\r
\r
1. El cliente crear\xE1 un socket para comunicarse con el servidor. Para enviar datagramas necesita conocer su IP y el puerto por el que escucha.\r
2. Utilizar\xE1 el m\xE9todo send() del socket para enviar la petici\xF3n en forma de datagrama.\r
    - La informaci\xF3n se envia en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
3. Permanece a la espera de recibir respuesta\r
4. El cliente recibe la respuesta del servidor mediante el m\xE9todo receive() del socket.\r
    - La informaci\xF3n se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
5. Cerrar y liberar los recursos.\r
\r
\`\`\`java{10,14,17,20,28,31}\r
public class BasicUDP_Client {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // IP y puerto al que se env\xEDa el Datagrama\r
        InetAddress destino = InetAddress.getLocalHost();\r
        int port = 12345; \r
        \r
        // Buffer para recibir el datagrama\r
        byte[] buffer = new byte[1024];\r
        \r
        // El mensaje a enviar en el Datagrama se convierte a bytes\r
        String mensajeEnviado = "Enviando Saludos !!";\r
        buffer = mensajeEnviado.getBytes(); //codifico String a bytes\r
\r
        // Se preparara el DatagramPacket que se va a enviar\r
        DatagramPacket datagramaEnviado = new DatagramPacket(buffer, buffer.length, destino, port);\r
        // En este caso, especificamos un puerto, aunque podr\xEDamos dejarlo para\r
        // que el SO asigne uno libre\r
        DatagramSocket socket = new DatagramSocket(34567);\r
        \r
        System.out.println("Host destino : " + destino.getHostName());\r
        System.out.println("IP Destino : " + destino.getHostAddress());\r
        System.out.println("Puerto local del socket: " + socket.getLocalPort());\r
        System.out.println("Puerto al que envio: " + datagramaEnviado.getPort());\r
\r
        // Env\xEDo del Datagrama\r
        socket.send(datagramaEnviado);\r
        \r
        // Cierre y liberaci\xF3n de recursos       \r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.4.3 Servidor UDP\r
\r
En los sockets UDP no se establece conexi\xF3n. A pesar de que cuando los programamos s\xED existen diferencias entre el servidor y el cliente, estas no son tan claras como con los sockets TCP. La funcionalidad y el c\xF3digo que diferencia a un servidor de un cliente est\xE1 m\xE1s diluido.\r
\r
> Podemos considerar servidor al que espera un mensaje y responde; y cliente al que inicia la comunicaci\xF3n.\r
\r
Tanto uno como otro si desean ponerse en contacto necesitan saber en qu\xE9 ordenador y en qu\xE9 puerto est\xE1 escuchando el otro.\r
\r
1. El servidor crea un socket asociado a un puerto local para escuchar peticiones de clientes.\r
2. Permanece a la espera de recibir peticiones.\r
3. El servidor recibe las peticiones mediante el m\xE9todo receive() del socket.\r
    - La informaci\xF3n se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
4. En el datagrama recibido va incluido adem\xE1s del mensaje, el puerto y la IP del cliente emisor de la petici\xF3n; lo que le permite al servidor conocer la direcci\xF3n del emisor del datagrama. Utilizando el m\xE9todo send() del socket puede enviar la respuesta al cliente emisor.\r
5. El servidor permanece a la espera de recibir m\xE1s peticiones.\r
6. Cerrar y liberar los recursos.\r
\r
\`\`\`java{6,10,18,20,21,33}\r
public class BasicUDP_Server {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // Buffer para recibir el datagrama\r
        byte[] bufer = new byte[1024];\r
\r
        // El Socket del servidor se asocia a un puerto para que los clientes\r
        // puedan enviar peticiones.\r
        DatagramSocket socket = new DatagramSocket(12345);\r
\r
        // Se espera la llegada de un DATAGRAMA\r
        // Al igual que con TCP, esta llamada a receive es bloqueante\r
        // y es la que tiene que marcar la sincronizaci\xF3n entre lecturas y \r
        // escrituras de las app cliente / servidor\r
        System.out.println("Esperando Datagrama ................");\r
        // Se crea el objeto que almacenar\xE1 el mensaje enviado por el cliente\r
        DatagramPacket datagramaRecibido = new DatagramPacket(bufer, bufer.length);\r
        // Se espera el mensaje y se le pasa el datagrama para que lo almacene ah\xED\r
        socket.receive(datagramaRecibido);\r
        String mensajeRecibido = new String(datagramaRecibido.getData());\r
\r
        //Informaci\xF3n recibida\r
        System.out.println("N\xFAmero de Bytes recibidos: " + datagramaRecibido.getLength());\r
        System.out.println("Contenido del Paquete    : " + mensajeRecibido.trim());\r
\r
        System.out.println("Puerto origen del mensaje: " + datagramaRecibido.getPort());\r
\r
        System.out.println("IP de origen             : " + datagramaRecibido.getAddress().getHostAddress());\r
        System.out.println("Puerto destino del mensaje:" + socket.getLocalPort());\r
\r
        // Liberamos los recursos\r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor UDP](../../media/unit4/udp_process.png)\r
\r
Veamos ahora un ejemplo completo de C/S UDP\r
\r
\`\`\`java\r
public class BasicUDP_Client2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // FLUJO PARA ENTRADA ESTANDAR\r
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\r
\r
        DatagramSocket clientSocket = new DatagramSocket();\r
        byte[] enviados = new byte[1024];\r
        byte[] recibidos = new byte[1024];\r
\r
        // DATOS DEL SERVIDOR al que enviar mensaje\r
        InetAddress IPServidor = InetAddress.getLocalHost();// localhost\r
        int puerto = 9876; // puerto por el que escucha\r
\r
        // INTRODUCIR DATOS POR TECLADO\r
        System.out.print("Introduce mensaje: ");\r
        String cadena = in.readLine();\r
        enviados = cadena.getBytes();\r
\r
        // ENVIANDO DATAGRAMA AL SERVIDOR\r
        System.out.println("Enviando " + enviados.length + " bytes al servidor.");\r
        DatagramPacket envio = new DatagramPacket(enviados, enviados.length, IPServidor, puerto);\r
        clientSocket.send(envio);\r
\r
        // RECIBIENDO DATAGRAMA DEL SERVIDOR\r
        DatagramPacket recibo = new DatagramPacket(recibidos, recibidos.length);\r
        System.out.println("Esperando datagrama....");\r
        clientSocket.receive(recibo);\r
        String mayuscula = new String(recibo.getData());\r
\r
        // OBTENIENDO INFORMACI\xD3N DEL DATAGRAMA\r
        InetAddress IPOrigen = recibo.getAddress();\r
        int puertoOrigen = recibo.getPort();\r
        System.out.println("\\tProcedente de: " + IPOrigen + ":" + puertoOrigen);\r
        System.out.println("\\tDatos: " + mayuscula.trim());\r
\r
        //cerrar socket\r
        clientSocket.close();\r
\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class BasicUDP_Server2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Puerto por el que escucha el servidor: 9876\r
        DatagramSocket serverSocket = new DatagramSocket(9876);\r
        byte[] recibidos = new byte[1024];\r
        byte[] enviados = new byte[1024];\r
        String cadena;\r
\r
        while (true) {\r
            System.out.println("Esperando datagrama.....");\r
\r
            //RECIBO DATAGRAMA\r
            recibidos = new byte[1024];\r
            DatagramPacket paqRecibido = new DatagramPacket(recibidos, recibidos.length);\r
            serverSocket.receive(paqRecibido);\r
            cadena = new String(paqRecibido.getData());\r
\r
            //DIRECCION ORIGEN\r
            InetAddress IPOrigen = paqRecibido.getAddress();\r
            int puerto = paqRecibido.getPort();\r
            System.out.println("\\tOrigen: " + IPOrigen + ":" + puerto);\r
            System.out.println("\\tMensaje recibido: " + cadena.trim());\r
\r
            //CONVERTIR CADENA A MAY\xDASCULA\r
            String mayuscula = cadena.trim().toUpperCase();\r
            enviados = mayuscula.getBytes();\r
\r
            //ENVIO DATAGRAMA AL CLIENTE\r
            DatagramPacket paqEnviado = new DatagramPacket(enviados, enviados.length, IPOrigen, puerto);\r
            serverSocket.send(paqEnviado);\r
\r
            // Condici\xF3n de finalizaci\xF3n\r
            if (cadena.trim().equals("*")) {\r
                break;\r
            }\r
\r
        }//Fin de while\r
\r
        serverSocket.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.4.4 Multicast socket\r
\r
La clase MulticastSocket es \xFAtil para enviar paquetes a m\xFAltiples destinos simult\xE1neamente.\r
\r
Para poder recibir estos paquetes es necesario establecer un grupo multicast, que es un grupo de direcciones IP que comparten el mismo n\xFAmero de puerto.\r
\r
Cuando se env\xEDa un mensaje a un grupo de multicast, todos los que pertenezcan a ese grupo recibir\xE1n el mensaje.\r
\r
La pertenencia al grupo es transparente al emisor, es decir, el emisor no conoce el n\xFAmero de miembros del grupo ni sus direcciones IP.\r
\r
::: info Grupo multicast\r
\r
Un grupo multicast se especifica mediante una direcci\xF3n IP de clase D y un n\xFAmero de puerto UDP est\xE1ndar.\r
\r
Las direcciones desde la 224.0.0.0 a la 239.255.255.255 est\xE1n destinadas para ser direcciones de multicast.\r
\r
La direcci\xF3n 224.0.0.0 est\xE1 reservada y no debe ser utilizada.\r
:::\r
\r
Los m\xE9todos que proporciona la clase MulticastSocket son\r
\r
| M\xE9todo | Descripci\xF3n |\r
| --- | ----------- |\r
|  MulticastSocket() throws IOException  | Construye un socket multicast dejando al SO que asigne un puerto libre. |\r
|  MulticastSocket(int port) throws IOException  | Construye un socket multicast y lo conecta al puerto local especificado. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Env\xEDa un DatagramPacket a trav\xE9s del socket. |\r
| joinGroup( InetAddress multicastAddress) | Permite al socket unirse al grupo de multicast. A partir de ese momento podr\xE1 recibir los mensajes que se env\xEDan a esa direcci\xF3n. Un MulticastSocket puede estar unido a m\xE1s de un grupo multicast. |\r
| leaveGroup( InetAddress multicastAddress) | Permite al socket abandonar el grupo de multicast |\r
\r
Y a continuaci\xF3n presentamos el esquema de llamadas seguido por un **servidor multicast**\r
\r
1. Se crea el socket multicast. No hace falta especificar puerto\r
    > MulticastSocket ms = new MulticastSocket();\r
\r
2. Se define el puerto multicast\r
    > int Puerto = 12345;\r
\r
3. Se crea el grupo multicast\r
    > InetAddress grupo = InetAddress.getByName(\u201C225.0.0.1\u201D);\r
\r
4. Se crea el datagrama\r
    > DatagramPacket paquete = new DatagramPacket(msg.getBytes(), msg.length(), grupo, Puerto);\r
\r
5. Se env\xEDa el paquete al grupo\r
    > ms.send(paquete);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
y el esquema de llamadas seguido por un **cliente multicast**\r
\r
1. Se crea un socket multicast en el puerto establecido\r
    > MulticastSocket ms = new MulticastSocket(12345);\r
\r
2. Se configura la IP del grupo al que nos conectaremos\r
    > InetAddress grupo = InetAddress.getByName(\u201C225.0.0.1\u201D);\r
\r
3. Se une al grupo\r
    > ms.joinGroup(grupo);\r
\r
4. Recibe el paquete del servidor multicast\r
\r
    > byte[] buf = new byte[1000];\r
DatagramPacket recibido = new DatagramPacket(buf, buf.length);\r
ms.receive(recibido);\r
\r
5. Salimos del grupo multicast:\r
    > ms.leaveGroup(grupo);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
Y ahora lo vemos todo junto con un ejemplo\r
\r
\`\`\`java\r
public class U4_BasicMulticastServer {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // Enviamos la informaci\xF3n introducida por teclado hasta que se env\xEDe un *        \r
        Scanner in = new Scanner(System.in);\r
\r
        //Se crea el socket multicast.\r
        MulticastSocket ms = new MulticastSocket();\r
        // Se escoge un puerto para el server\r
        int puerto = 12345;\r
        // Se escoge una direcci\xF3n para el grupo\r
        InetAddress grupoMulticast = InetAddress.getByName("225.0.0.1");\r
\r
        String cadena = "";\r
        while (!cadena.trim().equals("*")) {\r
\r
            System.out.print("Datos a enviar al grupo: ");\r
            cadena = in.nextLine();\r
\r
            // Enviamos el mensaje a todos los clientes que se hayan unido al grupo\r
            DatagramPacket paquete = new DatagramPacket(cadena.getBytes(), cadena.length(), grupoMulticast, puerto);\r
            ms.send(paquete);\r
        }\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class U4_BasicMulticastClient {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Se crea el socket multicast\r
        // El puerto debe ser el mismo en todos los clientes, ya que el \r
        // servidor multicast env\xEDa la informaci\xF3n a la IP multicast y a un puerto\r
        int puerto = 12345;//Puerto multicast\r
        MulticastSocket ms = new MulticastSocket(puerto);\r
\r
        //Nos unimos al grupo multicast\r
        InetAddress grupo = InetAddress.getByName("225.0.0.1");\r
        ms.joinGroup(grupo);\r
        String msg = "";\r
\r
        while (!msg.trim().equals("*")) {\r
            // El buffer se crea dentro del bucle para que se sobrescriba \r
            // con cada nuevo mensaje\r
            byte[] buf = new byte[1000];\r
            DatagramPacket paquete = new DatagramPacket(buf, buf.length);\r
            //Recibe el paquete del servidor multicast\r
            ms.receive(paquete);\r
            msg = new String(paquete.getData());\r
            System.out.println("Recibo: " + msg.trim());\r
        }\r
\r
        // Abandonamos grupo\r
        ms.leaveGroup(grupo);\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
::: info mezcla de sockets en una app\r
Ya hemos visto todo el abanico de posibilidades que tenemos para comunicar dos procesos en red.\r
\r
A partir de este momento, en nuestras aplicaciones no s\xF3lo tenemos que elegir uno de ellos, sino que podemos tener varios sockets, de diferente tipo, para comunicar los clientes y los servidores.\r
\r
Se trata ahora de analizar en qu\xE9 situaci\xF3n es m\xE1s conveniente un tipo que otro y usarlo. Podemos ayudarnos de la creaci\xF3n de hilos que est\xE9n "especializados" en el env\xEDo y/o recepci\xF3n de informaci\xF3n de un socket, permitiendo que se intercambien varios mensajes a la vez.\r
:::\r
`]},{title:"4.5 Protocolos con estado",headers:[{level:2,title:"4.5.1. Protocolos con y sin estado",slug:"_4-5-1-protocolos-con-y-sin-estado",link:"#_4-5-1-protocolos-con-y-sin-estado",children:[{level:3,title:"Protocolos sin estado",slug:"protocolos-sin-estado",link:"#protocolos-sin-estado",children:[]},{level:3,title:"Protocolos con estado",slug:"protocolos-con-estado",link:"#protocolos-con-estado",children:[]}]},{level:2,title:"4.5.2 Programaci\xF3n de servidores basados en estados",slug:"_4-5-2-programacion-de-servidores-basados-en-estados",link:"#_4-5-2-programacion-de-servidores-basados-en-estados",children:[{level:3,title:"Programaci\xF3n de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.5.3. Ejemplo de servidor con estados",slug:"_4-5-3-ejemplo-de-servidor-con-estados",link:"#_4-5-3-ejemplo-de-servidor-con-estados",children:[{level:3,title:"Ejemplo del Worker que implementa el protocolo",slug:"ejemplo-del-worker-que-implementa-el-protocolo",link:"#ejemplo-del-worker-que-implementa-el-protocolo",children:[]}]},{level:2,title:"4.5.4. Ejemplo de cliente con estados",slug:"_4-5-4-ejemplo-de-cliente-con-estados",link:"#_4-5-4-ejemplo-de-cliente-con-estados",children:[{level:3,title:'Ejemplo de cliente "gen\xE9rico" que implementa el protocolo',slug:"ejemplo-de-cliente-generico-que-implementa-el-protocolo",link:"#ejemplo-de-cliente-generico-que-implementa-el-protocolo",children:[]}]}],path:"/es/unit4/stateful-protocols.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.5 Protocolos con estado\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.5 Protocolos con estado" />\r
\r
# 4.5 Protocolos con estado\r
\r
[[toc]]\r
\r
## 4.5.1. Protocolos con y sin estado\r
\r
Como ya hemos comentado anteriormente, un protocolo, aplicado al mundo de las comunicaciones inform\xE1ticas, es un conjunto de reglas que especifican la manera en la que se realiza la comunicaci\xF3n entre dos interlocutores.\r
\r
Este conjunto de reglas establece el formato de los mensajes que se intercambian \`(texto, binario, JSON, XML, CSV, ...)\`, las acciones que cada uno de los extremos de la comunicaci\xF3n deben realizar en cada momento \`(env\xEDo o recepci\xF3n)\` y, lo que nos ocupa en este apartado del tema, si las acciones dependen de acciones anteriores o no.\r
\r
### Protocolos sin estado\r
\r
En inform\xE1tica, un protocolo sin estado es un protocolo de comunicaciones que trata cada petici\xF3n como una transacci\xF3n independiente que no tiene relaci\xF3n con cualquier solicitud anterior, de modo que la comunicaci\xF3n se compone de pares independientes de solicitud y respuesta.\r
[Wikipedia: Protocolo sin estado](https://es.wikipedia.org/wiki/Protocolo_sin_estado)\r
\r
El ejemplo m\xE1s conocido de protocolo sin estado es HTTP.1\u200B El protocolo no proporciona medio alguno de almacenamiento de datos de un usuario entre las peticiones, dejando esta tarea a niveles superiores y haciendo necesario el reenv\xEDo de informaci\xF3n de manera continua para simular un funcionamiento con estado (cookies, cabeceras, etc.).\r
\r
### Protocolos con estado\r
\r
Un protocolo sin estado no requiere que el servidor retenga informaci\xF3n de la sesi\xF3n o de estado acerca de los intercambios de informaci\xF3n durante la realizaci\xF3n de m\xFAltiples peticiones. En contraste, un protocolo que requiere el mantenimiento del **estado interno en el servidor** se conoce como un **protocolo con estado**.\r
\r
Por lo tanto, un estado es una configuraci\xF3n en un programa o m\xE1quina que depende de los estados anteriores y que determina el funcionamiento del sistema, en funci\xF3n de la entrada recibida y del estado actual en el que se encuentre el sistema.\r
\r
Poniendo una analog\xEDa, podemos tomar una solicitud a la administraci\xF3n, donde debemos realizar varios pasos hasta resolver la solicitud.\r
\r
1. En primer lugar se rellena una instancia con los datos y se env\xEDa al departamento correspondiente.\r
2. Ese departamento comprobar\xE1 la instancia recibida y contestar\xE1 solicitando informaci\xF3n adicional o confirmando que la solicitud se ha recibido correctamente.\r
3. En un proceso posterior, se solicita un pago de tasas al usuario.\r
4. El usuario tiene que realizar el pago de tasas y enviar el justificante.\r
5. Tras cotejar toda la informaci\xF3n, se le solicita al usuario que aporte los documentos originales.\r
6. El usuario se persona para mostrar la documentaci\xF3n original\r
7. Finalmente se resuelve la solicitud informando al usuario el resultado de la misma.\r
\r
Esto, que puede ser un procedimiento normal, refleja claramente un proceso en el que se siguen una serie de pasos y cuyo orden no se puede cambiar.\r
\r
Por ejemplo, no tendr\xEDa sentido hacer el pago de las tasas (paso 4) sin antes haber presentado la solicitud (paso 1) o sin haber recibido la confirmaci\xF3n de que la solicitud est\xE1 completa.\r
\r
Esto mismo pasa con algunos protocolos de comunicaci\xF3n.\r
\r
## 4.5.2 Programaci\xF3n de servidores basados en estados\r
\r
Hay toda una teor\xEDa matem\xE1tica, \`la teor\xEDa de grafos\`, desarrollada en torno a esto, junto con un modelo computacional, \`los aut\xF3matas finitos\`, que estudian y optimizan el desarrollo de aplicaciones basadas en estados.\r
\r
La teor\xEDa de grafos es una rama de las matem\xE1ticas y las ciencias de la computaci\xF3n que estudia las propiedades de los grafos\r
\r
La teor\xEDa de grafos tiene sus fundamentos en las \`matem\xE1ticas discretas\` y de las \`matem\xE1ticas aplicadas\`. Esta teor\xEDa requiere de diferentes conceptos de diversas \xE1reas como **combinatoria, \xE1lgebra, probabilidad, geometr\xEDa de pol\xEDgonos, aritm\xE9tica y topolog\xEDa**. Actualmente ha tenido mayor influencia en el campo de la inform\xE1tica, las ciencias de la computaci\xF3n y telecomunicaciones. Debido a la gran cantidad de aplicaciones en la optimizaci\xF3n de recorridos, procesos, flujos y algoritmos de b\xFAsquedas, entre otros\r
\r
Un aut\xF3mata finito o m\xE1quina de estado finito es un modelo computacional que toma decisiones de computaci\xF3n de forma autom\xE1tica sobre una entrada para producir una salida.\r
\r
Este modelo est\xE1 conformado por un alfabeto, un conjunto de estados finito, una funci\xF3n de transici\xF3n, un estado inicial y un conjunto de estados finales.\r
\r
La finalidad de los aut\xF3matas finitos, entre otras, es la de reconocer lenguajes regulares, que corresponden a los lenguajes formales m\xE1s simples seg\xFAn la Jerarqu\xEDa de Chomsky.\r
\r
### Programaci\xF3n de aplicaciones Cliente y/o Servidor\r
\r
Como en todos los casos que hemos estudiado con anterioridad, el protocolo es la pieza com\xFAn entre los clientes y los servidores.\r
\r
Nuestros clientes podr\xE1n estar bien o mal programados, de hecho muchos de nuestros clientes son interactivos, por lo que podemos alterar el orden de los comandos a nuestro antojo, no siendo esto ning\xFAn problema.\r
\r
Debe ser el servidor el que tenga el control del proceso, el que asegure la integridad del sistema y de los datos, por lo tanto va a ser en la parte del servidor donde tengamos que realizar las modificaciones para adaptarlo al control y gesti\xF3n de los estados.\r
\r
Esto no quita que los clientes deban seguir \`sincronizados\` con el servidor para evitar situaciones de interbloqueo, ya que de una forma u otra el cliente siempre debe seguir el protocolo, aunque no los estados tal y como hemos dicho.\r
\r
## 4.5.3. Ejemplo de servidor con estados\r
\r
Vamos a ver qu\xE9 pasos debemos seguir para controlar los estados en el servidor y c\xF3mo adaptar un cliente.\r
\r
El ejemplo que vamos a utilizar es el de la actividad  \`U4A03_ProtocoloSaludo\`. Primero vamos a aclarar c\xF3mo debe funcionar este protocolo.\r
\r
Si el cliente est\xE1 bien programado, el intercambio de informaci\xF3n entre Cliente y Servidor se realiza en tres pasos\r
\r
1. Cliente env\xEDa "Hi Server!"\r
2. Servidor responde "Hi Client!"\r
3. Cliente responde "By Server!"\r
\r
Ante un funcionamiento normal, este protocolo es bastante f\xE1cil de implementar. Sin embargo,\r
\r
- \xBFQu\xE9 pasa si el cliente env\xEDa "By Server!" como primer mensaje?\r
- \xBFQu\xE9 debe responder el servidor si no recibe el mensaje que est\xE1 esperando?\r
- \xBFQu\xE9 debe hacer el cliente si no recibe el mensaje que est\xE1 esperando?\r
\r
Estas son las circunstancias a las que debemos responder con los estados del protocolo, indicando en cada caso qu\xE9 debe hacer cada una de las partes. Todo depender\xE1 de la funcionalidad que est\xE9 implementando el protocolo.\r
\r
Cada caso es diferente, por ejemplo, si es importante hacer los tres pasos en orden, ante cualquier fallo se debe volver a empezar (un borrado en una BD, una autenticaci\xF3n de tres v\xEDas). Si por el contrario, los dos primeros pasos se tienen que realizar de forma conjunta, pero el tercero es independiente, si el incumplimiento del protocolo se produce en ese momento, no es necesario que se repitan los dos primeros pasos, sino que s\xF3lo ser\xE1 necesario repetir el \xFAltimo.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Estado Hi\\nEsperando al saludo\r
    Bye: Estado Bye\\nEsperando la despedida\r
    [*] -> Hi\r
    Hi -> Hi : Mensaje incorrecto\\nSe env\xEDa error al cliente\r
    Hi -> Bye : Se ha recibido el mensaje correcto\\nSe env\xEDa respuesta al cliente\r
    note left of Hi : Permanecemos en este estado\\nhasta que se reciba el mensaje correcto\r
    Bye -> Hi : Mensaje incorrecto\\nSe env\xEDa error al cliente\r
    Bye -> [*] : Se ha recibido el mensaje correcto\\nSe cierra la conexi\xF3n con el cliente\r
-->\r
\r
### Ejemplo del Worker que implementa el protocolo\r
\r
\`\`\`java{12,17,34,50,61,71}\r
public class U4A03_SaludoWorker extends Thread {\r
\r
    Socket socketCliente;\r
    BufferedReader entrada;\r
    PrintWriter salida;\r
\r
    private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\r
    U4A03_SaludoWorker(Socket socketCliente) {\r
        this.socketCliente = socketCliente;\r
        // Inicializamos el valor del estado al estado inicial\r
        estado = Estados.HI;\r
    }\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Recibe lo que env\xEDa el cliente hasta que el mensaje sea\r
            // END OF TRANSMISSION\r
            while (estado != Estados.END) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
\r
                // Comprobamos si se ha cerrado el extremo cliente del socket\r
                // Y damos por concluida la comunicaci\xF3n.\r
                if (str == null) {\r
                    estado = Estados.END;\r
                } else {\r
                    // Mostramos la informaci\xF3n recibida por consola\r
                    System.out.println("CLIENTE > " + str);\r
                }\r
\r
                // Controlamos la respuesta en funci\xF3n del mensaje recibido y \r
                // el estado actual\r
                switch (estado) {\r
                    case HI:\r
                        if (messages[0].equals(str)) {\r
                            // Enviamos respuesta al cliente\r
                            salida.println(messages[1]);\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.BYE;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                        }\r
                        break;\r
                    case BYE:\r
                        if (messages[2].equals(str)) {\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.END;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                            estado = Estados.HI;\r
                        }\r
                        break;\r
                    case END:\r
                        // No ser\xEDa necesario contemplarlo en este caso\r
                        // Pero s\xED en otros en los que se tenga que enviar \r
                        // alg\xFAn mensaje antes de salir.\r
                        break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("Error de comunicaci\xF3n con el cliente");\r
        } catch (Exception e) {\r
            System.out.println(e.getLocalizedMessage());\r
            e.printStackTrace();\r
        } finally {\r
            try {\r
                entrada.close();\r
                System.out.println("Conexi\xF3n cerrada: " + socketCliente);\r
                socketCliente.close();\r
            } catch (IOException e) {\r
                System.out.println("Error inesperado cerrando los recursos");\r
            }\r
        }\r
    }\r
}\r
\`\`\`\r
\r
El c\xF3digo corresponde al worker de un servidor multihilo. Analicemos ahora el c\xF3digo por partes\r
\r
Es recomendable usar propiedades para guardar los mensajes que queramos comparar y tener un ENuM para definir los estados. Los \`enum\` en Java permiten ser usados en los bloques switch-case.\r
\r
La propiedad **estado** va a ser el punto central que controle el flujo de ejecuci\xF3n del servidor.\r
\r
\`\`\`java:no-line-numbers {6}\r
private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\`\`\`\r
\r
En el constructor, adem\xE1s de todas las propiedades, inicializamos el estado, asign\xE1ndole el valor del estado inicial.\r
\r
\`\`\`java:no-line-numbers{4}\r
U4A03_SaludoWorker(Socket socketCliente) {\r
    this.socketCliente = socketCliente;\r
    // Inicializamos el valor del estado al estado inicial\r
    estado = Estados.HI;\r
}\r
\`\`\`\r
\r
El servidor estar\xE1 ejecut\xE1ndose hasta que se alcance el estado final\r
\r
\`\`\`java:no-line-numbers\r
// Recibe lo que env\xEDa el cliente hasta que el mensaje sea\r
// END OF TRANSMISSION\r
while (estado != Estados.END) {\r
\`\`\`\r
\r
En este ejemplo, el intercambio de informaci\xF3n con el cliente se hace uno a uno, es decir se recibe un mensaje y se env\xEDa una respuesta, pero no tiene porqu\xE9 ser as\xED, se pueden recibir varios mensajes y no enviar respuesta, o cualquier combinaci\xF3n de env\xEDo respuesta que nos imaginemos.\r
\r
El c\xF3digo que sigue e un control para saber si el cliente ha cerrado el socket, as\xED evitamos tener excepciones de tipo NullPointerException o dejar al servidor en un bucle infinito. Forzamos la salida cambiando el estado del protocolo.\r
\r
\`\`\`java:no-line-numbers{4}\r
// Comprobamos si se ha cerrado el extremo cliente del socket\r
// Y damos por concluida la comunicaci\xF3n.\r
if (str == null) {\r
    estado = Estados.END;\r
} else {\r
    // Mostramos la informaci\xF3n recibida por consola\r
    System.out.println("CLIENTE > " + str);\r
}\r
\`\`\`\r
\r
Este es el c\xF3digo que implementa el diagrama de estados que he dise\xF1ado para esta actividad.\r
Fijaos que el servidor tiene que realizar una comprobaci\xF3n para cada l\xEDnea que sale de un estado. En este caso al ser s\xF3lo dos l\xEDneas, sirve con un if-else, pero puede ser un n\xFAmero mayor de opciones.\r
\r
Adem\xE1s, una de las opciones tiene un comportamiento totalmente diferente al resto, ya que **cuando se recibe el mensaje final, el protocolo no dice que enviemos una respuesta al cliente**.\r
\r
Esto \`debemos controlarlo en el cliente\`, porque si lo programamos de forma que env\xEDe un mensaje y espere una respuesta, puede quedarse bloqueado en la lectura. Aprovechando que este es el \xFAltimo mensaje, m\xE1s adelante veremos c\xF3mo se ha solventado en el cliente.y las opciones que tenemos para evitar posibles bloqueos como este.\r
\r
\`\`\`java:no-line-numbers{16}\r
// Controlamos la respuesta en funci\xF3n del mensaje recibido y \r
// el estado actual\r
switch (estado) {\r
    case HI:\r
        if (messages[0].equals(str)) {\r
            // Enviamos respuesta al cliente\r
            salida.println(messages[1]);\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.BYE;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
        }\r
        break;\r
    case BYE:\r
        if (messages[2].equals(str)) {\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.END;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
            estado = Estados.HI;\r
        }\r
        break;\r
    case END:\r
        // No ser\xEDa necesario contemplarlo en este caso\r
        // Pero s\xED en otros en los que se tenga que enviar \r
        // alg\xFAn mensaje antes de salir.\r
        break;\r
}\r
\`\`\`\r
\r
## 4.5.4. Ejemplo de cliente con estados\r
\r
Aunque un cliente interactivo como los que usamos para las pruebas no deber\xEDan cambiar su funcionalidad, s\xED hay que hacer peque\xF1os ajustes para adaptar su funcionamiento a las posibles respuestas y errores que env\xEDa el servidor.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/client_sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Env\xEDo mensaje\r
    Bye: Recibo mensaje\r
    [*] -> Hi\r
    Hi -> Bye : Se env\xEDa un mensaje\\nSe espera la respuesta del servidor\r
    Bye -> Hi : Se muestra la respuesta del servidor\r
    note left of Hi : Se env\xEDan mensajes\\nmientras el servidor mantenga\\nla conexi\xF3n abierta   \r
    Hi -> [*] : Se ha detectado el cierre\\nde la conexi\xF3n con el servidor\r
-->\r
\r
Como ya hemos dicho en el c\xF3digo del servidor, si implementamos el protocolo como un cliente de env\xEDo-respuesta, hay un caso en el que no debemos esperar una respuesta. Este es el caso de la salida, en la que se env\xEDa un mensaje pero no esperamos respuesta por parte del servidor.\r
\r
Se puede pensar en poner una condici\xF3n de salida para cuando el cliente env\xEDa el \xFAltimo mensaje, pero no podemos asegurar que ese mensaje cerrar\xE1 la comunicaci\xF3n, porque depender\xE1 del estado en el que se encuentre el servidor.\r
\r
### Ejemplo de cliente "gen\xE9rico" que implementa el protocolo\r
\r
\`\`\`java{39,41}\r
public class U4A03_SaludoClient {\r
\r
    private static final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que est\xE1 en la misma m\xE1quina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket(args[0], Integer.parseInt(args[1]));\r
\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexi\xF3n");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenv\xEDa al servidor hasta que se env\xEDa \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
            // Recibe la respuesta del servidor por el InputStream\r
            linea = entrada.readLine();\r
            if (linea == null) {\r
                // Comprobamos si se ha cerrado el extremo servidor del socket\r
                // Y damos por concluida la comunicaci\xF3n.\r
                break;\r
            } else {\r
                // Env\xEDa a la salida est\xE1ndar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            }\r
        } while (true);\r
\r
        // Libera recursos\r
        salida.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\`\`\`\r
\r
El c\xF3digo corresponde a un cliente interactivo gen\xE9rico, que va enviando mensajes y esperando la respuesta de los mismos sin hacer ning\xFAn tipo de control sobre lo que se env\xEDa o lo que recibe.\r
\r
Analicemos algunos aspectos del c\xF3digo del cliente\r
\r
La parte que sigue es equivalente a la que hemos usado en el servidor. No modificamos el flujo env\xEDo-recepci\xF3n, pero s\xED que comprobamos si el lado del servidor ha cerrado el socket (ha realizado todo el protocolo correctamente) para decidir que el cliente finalice su ejecuci\xF3n.\r
\r
\`\`\`java:no-line-numbers{3}\r
// Recibe la respuesta del servidor por el InputStream\r
linea = entrada.readLine();\r
if (linea == null) {\r
    // Comprobamos si se ha cerrado el extremo servidor del socket\r
    // Y damos por concluida la comunicaci\xF3n.\r
    break;\r
} else {\r
    // Env\xEDa a la salida est\xE1ndar la respuesta del servidor\r
    System.out.println("SERVIDOR > " + linea);\r
}\r
} while (true);\r
\`\`\`\r
\r
::: warning Lectura con timeout\r
Otra manera distinta de hacer lo mismo es usando lecturas con timeout.\r
\r
En este ejemplo podr\xEDamos haber comprobado si el mensaje enviado es el mensaje de finalizaci\xF3n. Es ese caso, si todo ha ido bien, no deber\xEDamos esperar una respuesta por parte del server, pero si ha habido alg\xFAn error, s\xED debemos realizar una lectura del socket.\r
\r
Usando este c\xF3digo\r
\r
\`\`\`java\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenv\xEDa al servidor hasta que se env\xEDa \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
\r
            // Si enviamos el mensaje de salida, no hacemos una lectura indefinida\r
            if (linea.equals(messages[2])) {\r
                socketCliente.setSoTimeout(100);\r
            } else {\r
                socketCliente.setSoTimeout(0);\r
            }\r
\r
            try { \r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Env\xEDa a la salida est\xE1ndar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            } catch (SocketTimeoutException ste) {\r
                // Pasado el timeout no se ha recibido una respuesta\r
                // Podemos suponer que el server no env\xEDa respuesta\r
                // Eso indica que el protocolo se ha completado\r
                // Damos por concluida la comunicaci\xF3n.\r
                break;\r
            }            \r
        } while (true);\r
\`\`\`\r
\r
fijamos un tiempo de espera pasado el cual se producir\xE1 una \`SocketTimeoutException\` indicando que no se ha le\xEDdo nada del socket. Si por el contrario se lee informaci\xF3n del socket, esta se muestra por la consola.\r
\r
En este caso en concreto, esta soluci\xF3n no funciona porque el servidor ya ha cerrado el socket. Esto ser\xEDa \xFAtil cuando tengamos que hacer una \`lectura opcional\` en mitad de un protocolo, y servir\xEDa tanto para un cliente como para un servidor.\r
:::\r
`]},{title:"4.1 Pila de protocolos TCP IP",headers:[{level:2,title:"4.1.1. Las capas del modelo TCP/IP",slug:"_4-1-1-las-capas-del-modelo-tcp-ip",link:"#_4-1-1-las-capas-del-modelo-tcp-ip",children:[]},{level:2,title:"4.1.2. Direcciones y puertos - Sockets",slug:"_4-1-2-direcciones-y-puertos-sockets",link:"#_4-1-2-direcciones-y-puertos-sockets",children:[{level:3,title:"Direcciones IP",slug:"direcciones-ip",link:"#direcciones-ip",children:[]},{level:3,title:"Puertos",slug:"puertos",link:"#puertos",children:[]},{level:3,title:"Sockets",slug:"sockets",link:"#sockets",children:[]}]},{level:2,title:"4.1.3 TCP vs UDP",slug:"_4-1-3-tcp-vs-udp",link:"#_4-1-3-tcp-vs-udp",children:[]}],path:"/es/unit4/tcp-ip.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.1 Pila de protocolos TCP IP\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.1 Pila de protocolos TCP IP" />\r
\r
# 4.1 Pila de protocolos TCP IP\r
\r
[[toc]]\r
\r
## 4.1.1. Las capas del modelo TCP/IP\r
\r
La pila de protocolos TCP/IP, o los protocolos de internet, son un conjunto de \`protocolos de comunicaci\xF3n\` usados en la red Internet o en redes similares.\r
\r
TCP/IP son los protocolos m\xE1s usados a nivel mundial. Son protocolos abiertos y por ese motivo permiten la comunicaci\xF3n entre m\xE1quinas usando diferentes plataformas de hardware y software. Estos protocolos funcionan tanto en redes de \xE1rea extensa (WAN) como en redes de \xE1rea local (LAN).\r
\r
La pila de protocolos TCP/IP es, como hemos dicho, un conjunto de protocolos que reciben su nombre de los dos protocolos m\xE1s importantes \`Protocolo de Control de la Transmission(TCP)\` and the \`Protocolo de Internet(IP)\`. Adem\xE1s de estos protocolos, la pila TCP/IP incluye muchos otros protocolos de m\xE1s alto nivel que facilitan la comunicaci\xF3n con aplicaciones como el email, transferencia de archivos, servidores web, etc.\r
\r
::: info Documentos RFC\r
Cada protocolo de Internet, junto con sus correcciones y modificaciones posteriores, est\xE1 descrito en un documento conocido como \`Request For Comments (RFC)\`.\r
\r
Aqu\xED se puede consultar la lista de los RFCs disponibles: [http://www.ietf.org/rfc.html](http://www.ietf.org/rfc.html).\r
:::\r
\r
Recibe el nombre de **pila** o **stack** porque est\xE1 dise\xF1ado como una jerarqu\xEDa de capas en las que cada capa da soporte a la capa que tiene por encima y utiliza los servicios de la capa que tiene por debajo. Cada capa est\xE1 encargada de resolver un subconjunto de los problemas espec\xEDficos que encontramos cuando queremos realizar una comunicaci\xF3n de datos entre equipos en una red. \r
\r
El modelo TCP/IP est\xE1 dividido en cuatro capas. De m\xE1s bajo nivel a m\xE1s alto tenemos la capa de enlace de datos (Link), la capa de red (internet), la capa de transporte y la capa de aplicaci\xF3n, tal y como podemos ver en la siguiente imagen.\r
\r
![TCP/IP real communication flow](../../media/unit4/1-ip-real-communication-flow.gif)\r
\r
- La **capa de enlace** proporciona la comunicaci\xF3n entre dos interfaces o tarjetas de red dentro de una misma red local, con conexi\xF3n directa o a trav\xE9s de uno o varios switches.\r
- La **capa de red** proporciona comunicaci\xF3n entre dos interfaces de red o hosts. Estos hosts pueden estar en la misma red o en redes diferentes, siempre que est\xE9n interconectadas por uno o m\xE1s routers. A cada interfaz de red se le asigna una direcci\xF3n IP que identifica al equipo de forma un\xEDvoca. El protocolo IP es el m\xE1s importante de esta capa y probablemente sea el m\xE1s importante de toda la pila de protocolos.\r
- La **capa de transporte** se encarga de proporcionar una comunicaci\xF3n punto a punto, permitiendo manejar m\xFAltiples transferencias de informaci\xF3n de forma simultanea. El protocolo principal de esta capa es el protocolo \`TCP\`, que se encarga de proporcionar un servicio confiable y orientado a conexi\xF3n. \`UDP\` por su parte proporciona un servicio m\xE1s eficaz y r\xE1pido, pero lo hace de forma no fiable y no orientado a conexi\xF3n.\r
- La **capa de aplicaci\xF3n** proporciona servicios espec\xEDficos de transmisi\xF3n fiable para un tipo determinado de aplicaci\xF3n (transferencia de archivos, correo electr\xF3nico, gesti\xF3n de red, configuraci\xF3n de red, etc.). Esta capa se encuentra unas veces dentro de las aplicaciones cliente que usamos para acceder a estos servicios y en otras ocasiones como servicios del propio SO. El interfaz entre los protocolos de la capa de aplicaci\xF3n y los protocolos de la capa de transporte se definen como \`puertos \` y \`sockets\`.\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.1-ip-protocols.png)\r
\r
## 4.1.2. Direcciones y puertos - Sockets\r
\r
### Direcciones IP\r
\r
Cada host o equipo que est\xE1 en una red TCP/IP tiene asignada na direcci\xF3n IP \xFAnica consistente en un n\xFAmero de red y un n\xFAmero de host. El n\xFAmero de red sirve para identificar la red en la que se encuentran los hosts. El n\xFAmero de host sirve para identificar a un host dentro de una red.\r
\r
Las direcciones Ipv4 son direcciones de 32-bits. La direcci\xF3n IP se agrupa en cuatro octetos o bytes (grupos de 8 bits) y se representan usando el valor en notaci\xF3n decimal de cada uno de los bytes, separados por puntos. El valor m\xEDnimo para cada octeto es 0 y el valor m\xE1ximo es 255.\r
\r
> 192.168.0.100\r
>\r
> 127.0.0.1\r
>\r
> 10.1.100.1\r
\r
Las direcciones IPv6 est\xE1 formadas por 64-bits para la direcci\xF3n de red o prefijo de red, y otros 64 bits para el n\xFAmero de host. Las direcciones IPv6 se escriben como 8 grupos de 4 d\xEDgitos hexadecimales separados por el caracter ':'. Un grupo que s\xF3lo tiene ceros puede ser omitido. Los ceros iniciales tambi\xE9n se pueden omitir\r
\r
Todas estas direcciones ser\xEDan equivalentes. Se les han aplicado diferentes reglas de reducci\xF3n\r
\r
> 2001:0db8:0000:0000:0000:0000:1428:57ab\r
>\r
> 2001:0db8:0000:0000:0000::1428:57ab\r
>\r
> 2001:0db8:0:0:0:0:1428:57ab\r
>\r
> 2001:0db8:0:0::1428:57ab\r
>\r
> 2001:0db8::1428:57ab\r
>\r
> 2001:db8::1428:57ab\r
\r
![Routing](../../media/unit4/data_transfer.gif)\r
\r
### Puertos\r
\r
Cuando una aplicaci\xF3n que se est\xB4ejecutando en un equipo quiere comunicarse con otra aplicaci\xF3n de otro equipo, se identifica a s\xED misma con un n\xFAmero de 16 bits, que denominamos \`puerto\`. Ese identificador es usado por los protocolos de la capa de transporte (TCP or UDP) para entregar los mensajes a la aplicaci\xF3n correcta dentro del equipo.\r
\r
Los puertos van de 0 a 65535, y se agrupan en tres rangos\r
\r
| Grupo de puertos                      | Rango de puertos    | Descripci\xF3n                                                    |\r
| ------------------------------- | ------------- | -------------------------------------------------------------- |\r
| Puertos bien conocidos o puertos del sistema | 0 - 1023      | Los usan los protocolos est\xE1ndar y los servicios del SO |\r
| Puertos registrados | 1024- 49151   | Reservados por empresas y organizaciones para sus propios servicios |\r
| Puertos ef\xEDmeros | 49152 - 65535 | De libre disposici\xF3n y uso para aplicaciones cliente y servidor |\r
\r
Los servidores de protocolos est\xE1ndar como Telnet y FTP usan uno o m\xE1s de estos puertos bien conocidos. La mayor\xEDa de los servidores s\xF3lo utilizan un puerto aunque hay otros, como FTP, que usan dos. El uso de un puerto espec\xEDfico permite a las aplicaciones cliente el poder comunicarse con el servidor sin tener que enviar una petici\xF3n previa para determinar qu\xE9 puerto se est\xE1 usando.\r
\r
> Por ejemplo, las peticiones HTTP se env\xEDan por defecto al puerto 80 del servidor..\r
\r
Las aplicaciones cliente (navegadores, clientes de correo, etc) no necesitan usar uno de los puertos bien conocidos ya que son los que inician la comunicaci\xF3n. A los procesos cliente se les asigna un n\xFAmero de puerto de forma din\xE1mica por parte del SO. Ese n\xFAmero est\xE1 incluido en todos los datagramas que intercambia con el servidor, por lo tanto el servidor tiene acceso a esa informaci\xF3n.\r
\r
### Sockets\r
\r
Un \`socket\` es b\xE1sicamente un punto final de conexi\xF3n en una comunicaci\xF3n entre proceso y est\xE1 formado por una combinaci\xF3n unica de  **direcci\xF3n IP, puerto y protocolo de transporte (normalmente TCP)**.\r
\r
Cuando una aplicaci\xF3n cliente quiere comunicarse con un servidor, el SO crea el socket que usar\xE1 el cliente para recibir la informaci\xF3n del servidor. lA combinaci\xF3n \xFAnica de Protocolo + puerto + IP permite que este extremo de la comunicaci\xF3n sea accesible desde el servidor, de manera inequ\xEDvoca y asegura que los datos los recibe el proceso que los solicit\xF3.\r
\r
El servidor tiene su propio socket par comunicarse con el cliente, y una conexi\xF3n establecida entre el cliente y el servidor usando los dos extremos (los dos sockets cliente <--> servidor. Las aplicaciones intercambian informaci\xF3n escribiendo o leyendo en los sockets que han creado..\r
\r
La conexi\xF3n usada por un cliente est\xE1 formada por dos sockets, uno en el lado del cliente y otro en el lado des servidor. Por lo tanto, la conexi\xF3n puede identificarse con una tupla formada por cuatro n\xFAmero: la direcci\xF3n IP de origen, la direcci\xF3n IP de destino, el puerto de origen y el puerto de destino.\r
\r
Esto permite que m\xFAltiples aplicaciones cliente ejecut\xE1ndose en m\xE1quinas diferentes puedan conectarse al mismo socket de destino en el servidor. Tampoco hay confusi\xF3n de a qu\xE9 equipo se debe enviar un datagram de respuesta, incluso si el puerto de origen y destino es el mismo.\r
\r
Usando sockets tambi\xE9n es posible tener varias aplicaciones cliente corriendo en el mismo equipo y conect\xE1ndose al mismo servidor (varias pesta\xF1as de un navegador). Los datagramas de respuesta enviados por el servidor al cliente contienen la informaci\xF3n del socket en el lado del client, la cual incluye el puerto asignado individualmente a cada uno de los clientes, no pudiendo haber confusi\xF3n sobre a qu\xE9 proceso entregar la respuesta.\r
\r
![TCP/IP logical communication flow](../../media/unit4/2-ip-logical-communication-flow.gif)\r
\r
En una red, la comunicaci\xF3n real se realiza de una capa a la siguiente o a la anterior. Sin embargo, las aplicaciones de cada capa realizan una abstracci\xF3n de las capas inferiores y ven su flujo de comunicaci\xF3n como una comunicaci\xF3n directa con la capa equivalente en el otro extremo de la conexi\xF3n.\r
\r
En la pila de protocolos TCP/IP se manejan diferentes elementos de informaci\xF3n en cada nivel (frames, packets, datagramas, streams, messages, ...).\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.0-The-TCP-IP-UDP-IP-Stack_Q640.jpg)\r
\r
Como ya se ha citando anteriormente, los sockets son el puente entre la capa de transporte y la capa de aplicaci\xF3n. Este es el punto donde vamos a trabajar y desarrollar nuestras aplicaciones en este tema, ofreciendo servicios a los protocolos de la capa superior, la capa de aplicaci\xF3n.\r
\r
## 4.1.3 TCP vs UDP\r
\r
El protocolo TCP que es el m\xE1s utilizado en la navegaci\xF3n cotidiana. Es el m\xE1s habitual por tratarse de un protocolo de transporte \u2018orientado a conexi\xF3n\u2019. Esto quiere decir que el protocolo TCP est\xE1 dise\xF1ado no solo para transmitir una determinada informaci\xF3n entre un dispositivo y otro, sino tambi\xE9n para verificar la correcta recepci\xF3n de la informaci\xF3n transmitida entre un dispositivo y otro, o, dicho de otro modo, es un protocolo para manejar conexiones de extremo a extremo.\r
\r
El protocolo TCP establece una conexi\xF3n entre el dispositivo emisor y el dispositivo receptor y verifica de forma continua la emisi\xF3n y recepci\xF3n de la informaci\xF3n entre ambos. El protocolo TCP consigue esta verificaci\xF3n dividiendo los flujos de bytes en segmentos ordenados con un n\xFAmero de secuencia antes de transmitirlos a trav\xE9s del protocolo IP. Este n\xFAmero de secuencia es verificado por el dispositivo receptor y, en caso de que falte alguno de los segmentos, el protocolo TCP vuelve a solicitar su env\xEDo a trav\xE9s del protocolo IP, hasta que el mensaje llega en su totalidad al dispositivo receptor. Gracias a su fiabilidad, el protocolo TCP da soporte a los protocolos HTTP, SMTP, SSH y FTP.\r
\r
El protocolo TCP ofrece los siguientes servicios :\r
\r
- Comunicaci\xF3n Full duplex: los dos extremos pueden transmitir simultaneamente\r
- Timing: Utiliza temporizadores para asegurar que los datos se transmiten de forma s\xEDncrona\r
- Secuenciaci\xF3n: Los bloques se transmiten con un n\xFAmero de secuencia para que puedan ser reensamblados en el destino, en orden correcto, antes de pasarlos al protocolo de la capa de aplicaci\xF3n.\r
- Control de flujo: Se encarga de gestionar el congesti\xF3n y adaptar la velocidad de env\xEDo / recepci\xF3n de bloques.\r
- Gesti\xF3n de errores: Usa comprobaciones checksum para detectar posibles errores en la transmisi\xF3n de los datos y gestionar dichos errores.\r
\r
![TCP/IP logical communication flow](../../media/unit4/5-Graphic-UDP-Vs-TCP.png)\r
\r
El protocolo UDP funciona de manera similar al protocolo TCP, pero no es un protocolo de transporte orientado a conexi\xF3n. Esto quiere decir que el protocolo UDP no verifica la recepci\xF3n de los datos transmitidos entre un dispositivo y otro. Por esto, se articula en un nivel de capa inferior al protocolo TCP, con lo que el sistema de verificaci\xF3n de la recepci\xF3n de los datos debe implementarse en las capas superiores.\r
\r
La principal ventaja del protocolo UDP consiste en su velocidad. Al prescindir de un sistema de verificaci\xF3n de ida y vuelta entre el dispositivo emisor y el dispositivo receptor, el protocolo UDP permite una velocidad de transferencia superior a la del protocolo TCP. Por esto, el protocolo UDP es el m\xE1s utilizado por los servicios de transmisi\xF3n de voz o v\xEDdeo en streaming, donde la velocidad de la transmisi\xF3n es m\xE1s importante que una posible p\xE9rdida de datos puntual.\r
\r
Cabe destacar su uso especializado para transmisiones de tipo multicast y broadcast.\r
\r
![TCP/IP logical communication flow](../../media/unit4/tcp_vs_udp.png)\r
`]},{title:"4.2 Clases auxiliares para direccionamiento",headers:[{level:2,title:"4.2.1. java.net.NetworkInterface",slug:"_4-2-1-java-net-networkinterface",link:"#_4-2-1-java-net-networkinterface",children:[]},{level:2,title:"4.2.2 java.net.InterfaceAddress",slug:"_4-2-2-java-net-interfaceaddress",link:"#_4-2-2-java-net-interfaceaddress",children:[]},{level:2,title:"4.2.3. java.net.InetAddress",slug:"_4-2-3-java-net-inetaddress",link:"#_4-2-3-java-net-inetaddress",children:[]},{level:2,title:"4.2.4 java.net.URL",slug:"_4-2-4-java-net-url",link:"#_4-2-4-java-net-url",children:[]},{level:2,title:"4.2.5 java.net.URLConnection",slug:"_4-2-5-java-net-urlconnection",link:"#_4-2-5-java-net-urlconnection",children:[]}],path:"/es/unit4/urls.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.2 Clases auxiliares para direccionamiento\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.2 Clases auxiliares para direccionamiento" />\r
\r
# 4.2 Clases auxiliares para direccionamiento\r
\r
[[toc]]\r
\r
## 4.2.1. java.net.NetworkInterface\r
\r
Esta clase representa la interfaz de red, tanto software como hardware, su nombre, la lista de direcciones IP asignadas y toda la informaci\xF3n relacionada. Se puede usar en los casos en que queramos usar espec\xEDficamente una interfaz particular para transmitir nuestro paquete en un sistema con m\xFAltiples NIC.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/NetworkInterface.html)\r
\r
::: info \xBFQu\xE9 es una interfaz de red?  \r
Se puede pensar en una interfaz de red como un punto en el que su computadora se conecta a la red. No es necesariamente una pieza de hardware, pero tambi\xE9n se puede implementar en un software. Por ejemplo, una interfaz de bucle invertido que se utiliza con fines de prueba.\r
:::\r
\r
| Method                                                            | Description                                                                                                                                                                                                                        |\r
| ----------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public static Enumeration getNetworkInterfaces()                  | Devuelve todas las interfaces de red del sistema.                                                                                                                                                                                  |\r
| public List getInterfaceAddresses()                               | Devuelve una lista de todas las direcciones de interfaz en esta interfaz.                                                                                                                                                          |\r
| public Enumeration getInetAddresses()                             | Devuelve una enumeraci\xF3n de todas las Inetaddresses vinculadas a esta interfaz de red, si el administrador de seguridad lo permite.                                                                                                |\r
| public String getName()                                           | Devuelve el nombre de esta interfaz de red                                                                                                                                                                                         |\r
| public int getIndex()                                             | Devuelve el \xEDndice asignado a esta interfaz de red por el sistema. Los \xEDndices se pueden utilizar en lugar de nombres largos para hacer referencia a cualquier interfaz del dispositivo.                                           |\r
| public String getDisplayName()                                    | Este m\xE9todo devuelve el nombre de la interfaz de red en un formato de string legible.                                                                                                                                              |\r
| public static NetworkInterface getByName(String name)             | Busca y devuelve la interfaz de red con el nombre especificado, o nulo si no existe.                                                                                                                                               |\r
| public static NetworkInterface getByIndex(int index)              | Realiza una funci\xF3n similar a la funci\xF3n anterior con el \xEDndice utilizado como par\xE1metro de b\xFAsqueda en lugar del nombre.                                                                                                          |\r
| public static NetworkInterface getByInetAddress(InetAddress addr) | Este m\xE9todo se usa ampliamente ya que devuelve la interfaz de red a la que est\xE1 vinculada la direcci\xF3n de red especificada. Si una InetAddress est\xE1 vinculada a varias interfaces, se puede devolver cualquiera de las interfaces. |\r
| public boolean isUp()                                             | Devuelve un valor booleano que indica si esta interfaz de red est\xE1 en funcionamiento.                                                                                                                                              |\r
\r
\`\`\`java\r
// Java program to illustrate various java.net.NetworkInterface class methods.\r
\r
public class NetworkInterfaceExample\r
{\r
    public static void main(String[] args) throws SocketException,\r
                                                UnknownHostException\r
    {\r
\r
        // getNetworkInterfaces() returns a list of all interfaces\r
        // present in the system.\r
        ArrayList<NetworkInterface> interfaces = Collections.list(\r
                                            NetworkInterface.getNetworkInterfaces());\r
\r
        System.out.println("Information about present Network Interfaces...\\n");\r
        for (NetworkInterface iface : interfaces)\r
        {\r
            // isUp() method used for checking whether the interface in process\r
            // is up and running or not.\r
            if (iface.isUp())\r
            {\r
                // getName() method\r
                System.out.println("Interface Name: " + iface.getName());\r
\r
                // getDisplayName() method\r
                System.out.println("Interface display name: " + iface.getDisplayName());\r
\r
                // getHardwareAddress() method\r
                System.out.println("Hardware Address: " +\r
                                Arrays.toString(iface.getHardwareAddress()));\r
\r
                // getParent() method\r
                System.out.println("Parent: " + iface.getParent());\r
\r
                // getIndex() method\r
                System.out.println("Index: " + iface.getIndex());\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInterface addresses: ");\r
\r
                // getInterfaceAddresses() method\r
                for (InterfaceAddress addr : iface.getInterfaceAddresses())\r
                {\r
                    System.out.println("\\t\\t" + addr.getAddress().toString());\r
                }\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInetAddresses associated with this interface: ");\r
\r
                // getInetAddresses() method returns list of all\r
                // addresses currently bound to this interface\r
                Enumeration<InetAddress> en = iface.getInetAddresses();\r
                while (en.hasMoreElements())\r
                {\r
                    System.out.println("\\t\\t" + en.nextElement().toString());\r
                }\r
\r
                // getMTU() method\r
                System.out.println("\\tMTU: " + iface.getMTU());\r
\r
                // getSubInterfaces() method\r
                System.out.println("\\tSubinterfaces: " +\r
                                Collections.list(iface.getSubInterfaces()));\r
\r
                // isLoopback() method\r
                System.out.println("\\tis loopback: " + iface.isLoopback());\r
\r
                // isVirtual() method\r
                System.out.println("\\tis virtual: " + iface.isVirtual());\r
\r
                // isPointToPoint() method\r
                System.out.println("\\tis point to point: " + iface.isPointToPoint());\r
\r
                // supportsMulticast() method\r
                System.out.println("Supports Multicast: " + iface.supportsMulticast());\r
\r
            }\r
        }\r
\r
        // getByIndex() method returns network interface\r
        // with the specified index\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
\r
        // toString() method is used to display textual\r
        // information about this network interface\r
        System.out.println("Network interface 1: " + nif.toString());\r
\r
        // getByName() method returns network interface\r
        // with the specified name\r
        NetworkInterface nif2 = NetworkInterface.getByName("eth0");\r
        InetAddress ip = InetAddress.getByName("localhost");\r
\r
        // getbyInetAddress() method\r
        NetworkInterface nif3 = NetworkInterface.getByInetAddress(ip);\r
        System.out.println("\\nlocalhost associated with: " + nif3);\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.2 java.net.InterfaceAddress\r
\r
Esta clase representa una direcci\xF3n de interfaz de red. Cada dispositivo que tiene una direcci\xF3n IP tiene una direcci\xF3n IP en la interfaz de red. De hecho, el comando ping no hace ping a un dispositivo, sino a la direcci\xF3n de interfaz de los dispositivos.\r
\r
Java proporciona ciertos m\xE9todos para tratar con direcciones de interfaz que se pueden usar en lugares donde existe la necesidad de conocer la topolog\xEDa de la red, para la detecci\xF3n de fallas en una red, etc.\r
\r
Resumiendo, esta clase representa a una direcci\xF3n IP, una m\xE1scara de red y una direcci\xF3n broadcast (cuando la direcci\xF3n es IPv4). S\xF3lo representa una direcci\xF3n IP address y una longitud de prefijo de red en el caso de direcciones IPv6.\r
\r
> [java.net.InterfaceAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InterfaceAddress.html)\r
\r
| Method                                | Description                                                                                                                                                                                                      |\r
| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public InetAddress getAddress()       | Devuelve una InetAddress para esta direcci\xF3n                                                                                                                                                                     |\r
| public InetAddress getBroadcast()     | Devuelve InetAddress para la direcci\xF3n de transmisi\xF3n para esta direcci\xF3n de interfaz. Como solo las direcciones IPv4 tienen direcciones de transmisi\xF3n, se devolver\xEDa un valor nulo al usar una direcci\xF3n IPv6. |\r
| public short getNetworkPrefixLength() | Devuelve la longitud del prefijo para esta direcci\xF3n de interfaz, es decir, la m\xE1scara de subred para esta direcci\xF3n.                                                                                            |\r
\r
\`\`\`java\r
// Java program to illustrate methods of java.net.InterfaceAddress class\r
\r
public class InterfaceaddressExample\r
{\r
    public static void main(String[] args) throws SocketException\r
    {\r
        // Modify according to your system\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
        List<InterfaceAddress> list = nif.getInterfaceAddresses();\r
\r
        for (InterfaceAddress iaddr : list)\r
        {\r
            // getAddress() method\r
            System.out.println("getAddress() : " + iaddr.getAddress());\r
\r
            // getBroadcast() method\r
            System.out.println("getBroadcast() : " + iaddr.getBroadcast());\r
\r
            // getNetworkPrefixLength() method\r
            System.out.println("PrefixLength : " + iaddr.getNetworkPrefixLength());\r
\r
            // hashCode() method\r
            System.out.println("Hashcode : " + iaddr.hashCode());\r
\r
            // toString() method\r
            System.out.println("toString() : " + iaddr.toString());\r
        }\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.3. java.net.InetAddress\r
\r
La clase java.net.InetAddress proporciona m\xE9todos para obtener la direcci\xF3n IP de cualquier nombre de host, por ejemplo example www.google.com, www.facebook.com, etc.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InetAddress.html)\r
\r
La clase InetAddress se usa para encapsular tanto la direcci\xF3n IP num\xE9rica como el nombre de dominio para esa direcci\xF3n.\r
\r
Hay 2 tipos de direcciones:\r
\r
- Unicast: un identificador para una \xFAnica interfaz.\r
- Multicast: un identificador para un conjunto de interfaces.\r
\r
::: warning Local Name Resolver (hosts file)\r
Deber\xEDas saber que DNS traduce nombre de dominio en direcciones IP. Pero, ?sabes que hay un archivo en tu sistema que puede sobrescribir esas traducciones?\r
\r
Es el archivo \`hosts\` y nos permite mapear nombre de dominio a direcciones IP. Tu archivo HOSTS s\xF3lo afecta al comportamiento de tu equipo, por lo que podemos usarlo para crear direcciones personalizadas para IP de nuestra red, o bien para redireccionar / bloquear el acceso a determinados sitios web.\r
\r
Comp puedes imaginar, cambiar de forma incorrecta o **maliciosa** el contenido del archivo hOSTS puede romper f\xE1cilmente el comportamiento de tu conexi\xF3n a Internet, As\xED que la modificaci\xF3n del archivo no es trivial para los usuarios, algo que es de agradecer.\r
\r
- Windows\r
\r
El archivo HOSTS est\xE1 almacenado como un fichero de texto plano en la carpeta del sistema de Windows.\r
\r
Abre el men\xFA inicio y escribe "notepad".\r
\r
Pulsa con el bot\xF3n derecho y selecciona la opci\xF3n de "Ejecutar como administrador"\r
\r
En Notepad, ve a Archivo > Abrir y pega la siguiente ruta:\r
\r
c:\\Windows\\System32\\Drivers\\etc\\hosts\r
\r
Ahora ya puedes editar y guardar los cambios en tu archivo HOSTS.\r
\r
Para mapear un dominio, a\xF1ade una nueva l\xEDnea siguiendo los ejemplos que hay en el archivo.\r
\r
- OS X & GNU/Linux\r
\r
El archivo est\xE1 en /etc/hosts y debes editarlo con privilegios de administrador.\r
:::\r
\r
| Method                                                                       | Description                                                                                                       |\r
| ---------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |\r
| public static InetAddress getByName(String host) throws UnknownHostException | Este m\xE9todo devuelve la instancia de InetAddress que contiene el nombre y la IP del host recibido como par\xE1metro. |\r
| public static InetAddress getLocalHost() throws UnknownHostException         | Este m\xE9todo devuelve la instancia de InetAddress que contiene el nombre y la IP de LocalHost.                     |\r
| public String getHostName()                                                  | Este m\xE9todo devuelve el nombre de host para esta direcci\xF3n IP.                                                    |\r
| public String getHostAddress()                                               | Este m\xE9todo obtiene la direcci\xF3n IP en forma de string.                                                           |\r
| public boolean isReachable(int timeout)                                      | Este m\xE9todo prueba si esa direcci\xF3n es accesible.                                                                 |\r
\r
\`\`\`java\r
\r
class InetAddressExample {\r
    public static void main(String[] args)\r
        throws UnknownHostException\r
    {\r
        // To get and print InetAddress of Local Host\r
        InetAddress address1 = InetAddress.getLocalHost();\r
        System.out.println("InetAddress of Local Host : "\r
                        + address1);\r
\r
        // To get and print InetAddress of Named Host\r
        InetAddress address2\r
            = InetAddress.getByName("45.22.30.39");\r
        System.out.println("InetAddress of Named Host : "\r
                        + address2);\r
\r
        // To get and print ALL InetAddresses of Named Host\r
        InetAddress address3[]\r
            = InetAddress.getAllByName("172.19.25.29");\r
        for (int i = 0; i < address3.length; i++) {\r
            System.out.println(\r
                "ALL InetAddresses of Named Host : "\r
                + address3[i]);\r
        }\r
\r
        // To get and print InetAddresses of\r
        // Host with specified IP Address\r
        byte IPAddress[] = { 125, 0, 0, 1 };\r
        InetAddress address4\r
            = InetAddress.getByAddress(IPAddress);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address : "\r
            + address4);\r
\r
        // To get and print InetAddresses of Host\r
        // with specified IP Address and hostname\r
        byte[] IPAddress2\r
            = { 105, 22, (byte)223, (byte)186 };\r
        InetAddress address5 = InetAddress.getByAddress(\r
            "gfg.com", IPAddress2);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address and hostname : "\r
            + address5);\r
    }\r
}\r
\r
\`\`\`\r
\r
::: question Buscador de equipos (U4S4_HostSeeker)\r
Tu equipo est\xE1 conectado a una LAN (Red de \xC1rea Local) y probablemente est\xE9 usando una direcci\xF3n IP privada.\r
\r
Las direcciones pueden ser de clase C (192.168.X.Y), clase B (172.17.X.Y) o clase A (10.X.Y.Z). Eso depende principalmente de la m\xE1scara de red y del prefijo de red usado para la configuraci\xF3n del interfaz.\r
\r
Puedes comprobar esta configuraci\xF3n con los comandos **ifconfig** de OSX GNU/Linuxo o **ipconfig** de Windows..\r
\r
Escribe un programa que averig\xFCe, dentro de nuestra red, qu\xE9 hosts est\xE1n activos en la red, es decir, qu\xE9 hosts son "alcanzables" desde tu equipo usando uno de los interfaces disponibles.\r
\r
Primero vamos a hacerlo de forma sencilla. Escribe un programa que sabiendo la direcci\xF3n de tu equipo y la longitud del prefijo, pruebe todas las posibles combinaciones.\r
\r
> Si nuestra IP es 192.168.0.50 y el prefijo es /24, esto indica que los primeros 24 bits de la direcci\xF3n IP son el identificador de la red, y que los 8 \xFAltimos son para identificadores de hosts. Por lo que s\xF3lo tenemos que ir probando con los \xFAltimos 8 bits (el \xFAltimo d\xEDgito de la direcci\xF3n) para detectar a otros equipos en la red. Esto nos da 254 posibilidades, ya que la 0 y la 255 no se usan para hosts.\r
>\r
> Si por el contrario, el prefijo fuese 16, tendr\xEDamos que ir cambiando los dos \xFAltimos n\xFAmeros.\r
>\r
> 192.168.0.1 a 192.168.0.254, despu\xE9s 192.168.1.1 a 192.168.1.254, as\xED hasta 192.168.255.1 a 192.168.255.254, es decir, tendr\xEDa que usar un bucle anidado.\r
\r
La aplicaci\xF3n s\xF3lo debe mostrar la direcci\xF3n IP de los equipos que sean alcanzables.\r
\r
**Optativo**: Una vez que tengas tu aplicaci\xF3n funcionando, intenta hacerla gen\xE9rica y reutilizable para que funcione en cualquier red, obteniendo el prefijo de red y comprobando todas las posibles direcciones en la red en funci\xF3n del prefijo obtenido.\r
\r
En ambos casos la aplicaci\xF3n recibir\xE1 el nombre de una NIC como argumento y comprobar\xE1 s\xF3lo las direcciones IP asignadas a esa interfaz.\r
\r
Podemos saber si una direcci\xF3n es IPv4 o IPv6 usando el operador \`\xECnstanceof\` con las subclases Inet4Address y Inet6Address.\r
:::\r
\r
::: details C\xF3digo del ejemplo\r
\r
\`\`\`java\r
    // Code not visible yet\r
\`\`\`\r
\r
:::\r
\r
## 4.2.4 java.net.URL\r
\r
URL es un acr\xF3nimo de Localizador de recursos uniforme. Un recurso puede ser cualquier cosa, desde un simple archivo de texto hasta cualquier otro como im\xE1genes, directorio de archivos, etc.\r
\r
> [java.net.URL specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html)\r
\r
Es un puntero para localizar recursos en www (World Wide Web), por ejemplo:\r
\r
> http://psp2dam.github.io/psp_pages/\r
\r
La URL tiene las siguientes partes:\r
\r
- **Protocolo**: en este caso el protocolo es HTTP, puede ser HTTPS en algunos casos\r
- **Nombre de host o IP**: el nombre de host representa la direcci\xF3n de la m\xE1quina en la que se encuentra el recurso, en este caso, www.example.com\r
- **N\xFAmero de puerto**: es un atributo opcional. Si no se especifica, devuelve -1. En el caso anterior, el n\xFAmero de puerto es 80. Si no se indica se usa el puerto usado por defecto por el protocolo indicado en el primer campo.\r
- **Nombre del recurso**: es el nombre de un recurso ubicado en el servidor dado que queremos ver (la carpeta /psp_pages). Dependiendo de la configuraci\xF3n del servidor, el nombre del archivo puede tener un valor por defecto. En el ejemplo s\xF3lo se ha indicado una ruta, por lo que se intentar\xE1 devolver el archivo \`\xECndex.html\` si se encuentra en esa carpeta.\r
\r
| Constructor                                              | Descripci\xF3n                                                                                                                                                                       |\r
| -------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| URL(String spec)                                         | Este constructor crea un objeto de clase URL a partir de una representaci\xF3n de string dada                                                                                        |\r
| URL(String protocol, String host, int port, String file) | Este constructor crea un objeto de URL a partir del protocolo, host, n\xFAmero de puerto y archivo especificados.                                                                    |\r
| URL(String protocol, String host, String file)           | Este constructor crea un objeto de URL a partir del protocolo, el servidor y la ruta/archivo especificados.                                                                       |\r
| URL(URL context, String spec)                            | Este constructor crea una instancia de una URL analizando el src dado con el controlador especificado dentro de un contexto dado. Se usa cuando tenemos rutas relativas a una URL |\r
\r
Estos son los m\xE9todos mas importantes y utilizados de la clase de URL:\r
\r
| M\xE9todo                                | Descripci\xF3n                                                                                                                     |\r
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |\r
| public String getProtocol()           | Este m\xE9todo obtiene el nombre de protocolo de esta URL.                                                                         |\r
| public String getHost()               | Este m\xE9todo obtiene el nombre de host de esta URL, si corresponde.                                                              |\r
| public String getPort()               | Este m\xE9todo obtiene el n\xFAmero de puerto de esta URL.                                                                            |\r
| public String getFile()               | Este m\xE9todo obtiene la parte de la ruta de esta URL.                                                                            |\r
| public String getAuthority()          | Este m\xE9todo obtiene la parte de autoridad de esta URL.                                                                          |\r
| public String toString()              | Este m\xE9todo construye una representaci\xF3n de string de esta URL.                                                                 |\r
| public String getQuery()              | Este m\xE9todo obtiene la parte de consulta de esta URL.                                                                           |\r
| public String getDefaultPort()        | Este m\xE9todo obtiene el n\xFAmero de puerto predeterminado del protocolo asociado con esta URL.                                     |\r
| public URLConnection openConnection() | Este m\xE9todo devuelve una instancia de URLConnection que representa una conexi\xF3n al objeto remoto al que hace referencia la URL. |\r
| public InputStream openStream()       | Este m\xE9todo abre una conexi\xF3n a esta URL y devuelve un InputStream para leer desde esa conexi\xF3n.                                |\r
| public boolean equals(Object obj)     | Este m\xE9todo compara la igualdad de esta URL con otro objeto.                                                                    |\r
| public Object getContent()            | Este m\xE9todo obtiene el contenido de esta URL.                                                                                   |\r
| public String getRef()                | Este m\xE9todo obtiene el ancla (tambi\xE9n conocido como la \xABreferencia\xBB) de esta URL.                                               |\r
| public URI toURI()                    | Este m\xE9todo devuelve un URI equivalente a esta URL.                                                                             |\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args) throws MalformedURLException{  \r
\r
    URL url=new URL("http://psp2dam.github.io/psp_pages");  \r
  \r
    System.out.println("Protocol: "+url.getProtocol());  \r
    System.out.println("Host Name: "+url.getHost());  \r
    System.out.println("Port Number: "+url.getPort());  \r
    System.out.println("File Name: "+url.getFile());  \r
}   \r
\`\`\`\r
\r
Vamos con otro ejemplo m\xE1s completo de uso de los m\xE9todos de URL.\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args){    \r
    URL url=new URL("https://www.google.com/search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8");    \r
        \r
    System.out.println("Protocol: "+url.getProtocol());    \r
    System.out.println("Host Name: "+url.getHost());    \r
    System.out.println("Port Number: "+url.getPort());    \r
    System.out.println("Default Port Number: "+url.getDefaultPort());    \r
    System.out.println("Query String: "+url.getQuery());    \r
    System.out.println("Path: "+url.getPath());    \r
    System.out.println("File: "+url.getFile());      \r
}    \r
\`\`\`\r
\r
\`\`\`bash:no-line-numbers{3}\r
Protocol: https\r
Host Name: www.google.com\r
Port Number: -1\r
Default Port Number: 443\r
Query String: q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
Path: /search\r
File: /search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
\`\`\`\r
\r
## 4.2.5 java.net.URLConnection\r
\r
La clase URLConnection se utiliza para dos prop\xF3sitos diferentes pero relacionados.\r
\r
- En primer lugar, proporciona m\xE1s control sobre la interacci\xF3n con un servidor (especialmente un servidor HTTP) que la clase URL.\r
- En segundo lugar, con una URLConnection podemos verificar el encabezado enviado por el servidor y responder en consecuencia, podemos configurar los campos de encabezado utilizados en las requests de los clientes. Tambi\xE9n podemos descargar archivos binarios usando URLConnection.\r
\r
La clase URLConnection representa un enlace entre la URL y la aplicaci\xF3n. Puede usarse para leer y escribir datos en el recurso se\xF1alado por la URL.\r
\r
> [java.net.URLConnection specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLConnection.html)\r
\r
La clase URLConnection en Java es una clase abstracta que representa una conexi\xF3n de un recurso seg\xFAn lo especificado por la URL correspondiente. Tiene dos subclases \`HttpURLConnection\` y \`JarURLConnection\` que se encargan de hacer la conexi\xF3n entre el programa cliente y el recurso indicado en URL.\r
\r
La clase URLConnection proporciona una gran cantidad de m\xE9todos. Podemos mostrar el contenido de una p\xE1gina web usando el m\xE9todo \`getInputStream()\` , de un modo similar a como lo hac\xEDamos con los procesos.\r
\r
| M\xE9todo                                            | Descripci\xF3n                                                                                                                             |\r
| ------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |\r
| void connect()                                    | Este m\xE9todo se utiliza para establecer una conexi\xF3n con el recurso especificado por la URL, si dicha conexi\xF3n a\xFAn no se ha establecido. |\r
| Object getContent()                               | Recupera el contenido de esta conexi\xF3n URL.                                                                                             |\r
| String getContentEncoding()                       | Devuelve el valor del campo de encabezado de codificaci\xF3n de contenido.                                                                 |\r
| int getContentLength()                            | Devuelve el valor del campo de encabezado de longitud del contenido.                                                                    |\r
| long getContentLengthLong()                       | Devuelve el valor del campo de encabezado de longitud del contenido como long.                                                          |\r
| String getContentType()                           | Devuelve el valor del campo de encabezado de tipo de contenido.                                                                         |\r
| long getDate()                                    | Devuelve el valor del campo de encabezado de fecha.                                                                                     |\r
| boolean getDoInput()                              | Devuelve el valor del indicador doInput de esta URLConnection.                                                                          |\r
| boolean getDoInput()                              | Devuelve el valor del indicador doInput de esta URLConnection.                                                                          |\r
| String getHeaderField(int n)                      | obtiene el valor del en\xE9simo campo de encabezado.                                                                                       |\r
| String getHeaderField(String name)                | Devuelve el valor del campo de encabezado con nombre.                                                                                   |\r
| String getHeaderFieldKey(int n)                   | obtiene el valor del en\xE9simo campo de encabezado.                                                                                       |\r
| Map<String, List&lt;String&gt;> getHeaderFields() | Devuelve un mapa no modificable de los campos de encabezado.                                                                            |\r
| long getIfModifiedSince()                         | Devuelve el valor del campo ifModifiedSince de este objeto.                                                                             |\r
| InputStream getInputStream()                      | Devuelve un flujo de entrada que lee de esta conexi\xF3n abierta                                                                           |\r
| long getLastModified()                            | Devuelve el valor del campo de encabezado modificado por \xFAltima vez.                                                                    |\r
| OutputStream getOutputStream()                    | Devuelve un flujo de salida que escribe en esta conexi\xF3n.                                                                               |\r
| URL getURL()                                      | Devuelve el valor del campo URL de este URLConnection.                                                                                  |\r
| void setDoInput(boolean doinput)                  | Establece el valor del campo doInput para esta URLConnection en el valor especificado.                                                  |\r
| void setDoOutput(boolean dooutput)                | Establece el valor del campo doOutput para esta URLConnection en el valor especificado.                                                 |\r
\r
::: info C\xF3mo obtener un objeto de tipo URLConnection\r
El m\xE9todo openConnection() de la clase URL devuelve un objeto de tipo URLConnection.\r
:::\r
\r
\`\`\`java{11}\r
// URLConnectionExample\r
public static void main(String[] args) throws MalformedURLException, IOException{\r
\r
    // Creating an object of URL class\r
\r
    // Custom input URL is passed as an argument\r
    URL u = new URL("www.google.com");\r
\r
    // Creating an object of URLConnection class to\r
    // communicate between application and URL\r
    URLConnection urlconnect = u.openConnection();\r
\r
    // Creating an object of InputStream class\r
    // for our application streams to be read\r
    InputStream stream\r
        = urlconnect.getInputStream();\r
\r
    BufferedReader in =  \r
        new BufferedReader(\r
            new InputStreamReader(stream));\r
    // Till the time URL is being read\r
    String line;\r
    while ((line = in.readLine()) != null) {\r
\r
        // Continue printing the stream\r
        System.out.println(line);\r
    }\r
}\r
\`\`\`\r
\r
::: question Descargar im\xE1genes (U4S7_ImagesDownloader)\r
Crea una nueva aplicaci\xF3n que descargue im\xE1genes de una URL.\r
\r
La URL de la imagen se debe pasar como argumento a la aplicaci\xF3n. La imagen descargada debe guardarse en una carpeta images, en la ra\xEDz del proyecto, con el mismo nombre que tuviese el recurso online.\r
:::\r
\r
::: details C\xF3digo del ejemplo\r
\r
\`\`\`java\r
    // Code not visible yet\r
\`\`\`\r
\r
:::\r
`]},{title:"6.4 Encriptaci\xF3n asim\xE9trica",headers:[{level:2,title:"6.4.1. Clave p\xFAblica y clave privada",slug:"_6-4-1-clave-publica-y-clave-privada",link:"#_6-4-1-clave-publica-y-clave-privada",children:[]},{level:2,title:"6.4.2. Firma digital",slug:"_6-4-2-firma-digital",link:"#_6-4-2-firma-digital",children:[{level:3,title:"Integridad",slug:"integridad",link:"#integridad",children:[]},{level:3,title:"Autenticaci\xF3n y no repudio",slug:"autenticacion-y-no-repudio",link:"#autenticacion-y-no-repudio",children:[]}]},{level:2,title:"6.4.3 Certificados digitales",slug:"_6-4-3-certificados-digitales",link:"#_6-4-3-certificados-digitales",children:[{level:3,title:"Claves digitales",slug:"claves-digitales",link:"#claves-digitales",children:[]},{level:3,title:"Infraestructura de clave p\xFAblica (PKI)",slug:"infraestructura-de-clave-publica-pki",link:"#infraestructura-de-clave-publica-pki",children:[]}]},{level:2,title:"6.4.4. Generaci\xF3n de pares de claves",slug:"_6-4-4-generacion-de-pares-de-claves",link:"#_6-4-4-generacion-de-pares-de-claves",children:[{level:3,title:"Tipos de ficheros para certificados digitales",slug:"tipos-de-ficheros-para-certificados-digitales",link:"#tipos-de-ficheros-para-certificados-digitales",children:[]},{level:3,title:"Generaci\xF3n de claves desde Java",slug:"generacion-de-claves-desde-java",link:"#generacion-de-claves-desde-java",children:[]}]},{level:2,title:"6.4.5. Cifrado y descifrado usando un par de claves",slug:"_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",link:"#_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",children:[]},{level:2,title:"6.2.3. Cifrado asim\xE9trico con GnuPG",slug:"_6-2-3-cifrado-asimetrico-con-gnupg",link:"#_6-2-3-cifrado-asimetrico-con-gnupg",children:[]}],path:"/es/unit6/asymmetric-keys.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.4 Encriptaci\xF3n asim\xE9trica\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.4 Encriptaci\xF3n asim\xE9trica" />\r
\r
# 6.4 Encriptaci\xF3n asim\xE9trica\r
\r
[[toc]]\r
\r
## 6.4.1. Clave p\xFAblica y clave privada\r
\r
La criptograf\xEDa asim\xE9trica o **criptograf\xEDa de clave p\xFAblica** supuso una aut\xE9ntica revoluci\xF3n en su momento. Permit\xEDa el intercambio seguro de informaci\xF3n (confidencialidad, autenticaci\xF3n y no repudio) entre interlocutores que no compart\xEDan ning\xFAn secreto.\r
\r
Se cre\xF3 en los a\xF1os 70 a partir del trabajo de *Diffie y Hellman* por una parte y de *Rivest, Shamir y Adleman* por otra.\r
\r
Se basa en la existencia de un par de claves, una p\xFAblica y otra privada, entre las cuales existe una relaci\xF3n matem\xE1tica, de manera que es muy dif\xEDcil obtener la clave privada a partir de la p\xFAblica. Sin embargo, es muy sencillo obtener la clave p\xFAblica a partir de la privada.\r
\r
::: info Algoritmo RSA\r
En la familia de algoritmos RSA (Rivest, Shamir y Adleman) la clave p\xFAblica consiste en un n\xFAmero que es el producto de dos factores primos muy grandes (mayores que 10^100) y la clave privada se deriva de la factorizaci\xF3n de dicho n\xFAmero, es decir, los dos factores primos.\r
\r
Requiere poco procesamiento multiplicar dos n\xFAmeros primos tan grandes, pero requiere una cantidad enorme de c\xE1lculos encontrar la factorizaci\xF3n del n\xFAmero.\r
:::\r
\r
A diferencia del cifrado sim\xE9trico, el el cifrado asim\xE9trico se usan funciones diferentes para cifrar y descifrar los mensajes.\r
\r
- Para **encriptaci\xF3n** se usa la **clave p\xFAblica**. Cualquiera puede tener acceso a la clave p\xFAblica, mediante la cual, usando la funci\xF3n de cifrado, se encripta la informaci\xF3n dirigida a un destinatario concreto (el propietario de la clave privada asociada).\r
- Para **desencriptaci\xF3n** se usa la **clave privada**, que debe mantenerse a buen recaudo ya que s\xF3lo con esa clave y la funci\xF3n de descifrado se puede desencriptar un mensaje cifrado con la clave p\xFAblica correspondiente.\r
\r
Entre los algoritmos de cifrado asim\xE9trico m\xE1s utilizados se encuentran\r
\r
- Rivest Shamir Adleman (RSA). Basado en la factorizaci\xF3n de n\xFAmeros primos grandes.\r
- Digital Signature Standard (DSS), que incorpora Digital Signature Algorithm (DSA).\r
- Elliptical Curve Cryptography (ECC). Est\xE1 basado en las matem\xE1ticas de las curvas el\xEDpticas\r
- the Diffie-Hellman exchange method.\r
- TLS/SSL protocol.\r
\r
![cifrado asim\xE9trico](../../media/unit6/asymmetric-encryption-primitive.png)\r
\r
## 6.4.2. Firma digital\r
\r
Con la firma digital Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
![cifrado asim\xE9trico](../../media/unit6/proceso-firma-digital.png)\r
\r
El proceso b\xE1sico que se sigue para la firma electr\xF3nica es el siguiente:\r
\r
1. El usuario dispone de un documento electr\xF3nico (una hoja de c\xE1lculo, un pdf, una imagen, incluso un formulario en una p\xE1gina web) y de un **certificado** (clave p\xFAblica y clave privada) que le pertenece y le identifica.\r
2. La aplicaci\xF3n o dispositivo digital utilizados para la firma realiza un **resumen del documento**. El resumen de un documento de gran tama\xF1o puede llegar a ser tan solo de unas l\xEDneas. Este resumen es \xFAnico y cualquier modificaci\xF3n del documento implica tambi\xE9n una modificaci\xF3n del resumen.\r
3. La aplicaci\xF3n utiliza la clave privada para codificar el resumen.\r
4. La aplicaci\xF3n crea otro documento electr\xF3nico que contiene ese resumen codificado. Este nuevo documento es la firma electr\xF3nica.\r
\r
El resultado de todo este proceso es un documento electr\xF3nico obtenido a partir del documento original y de las claves del firmante. La firma electr\xF3nica, por tanto, es el mismo documento electr\xF3nico resultante.\r
\r
![verificaci\xF3n de firma digital](../../media/unit6/digital-signature-sign-verify.png)\r
\r
### Integridad\r
\r
Como estamos comparando funciones de resumen de un documento, se puede detectar de forma muy sencilla si el documento ha sufrido alguna modificaci\xF3n respecto al momento en el que se firm\xF3, garantizando de esta forma la integridad de la informaci\xF3n firmada.\r
\r
### Autenticaci\xF3n y no repudio\r
\r
Por las caracter\xEDsticas de los algoritmos de cifrado se puede determinar, a partir del resumen cifrado con la clave privada, mediante el uso de la clave p\xFAblica, que el mensaje recibido lo gener\xF3 el propietario de la clave privada.\r
\r
Con esta caracter\xEDstica se puede probar y demostrar que el mensaje lo firm\xF3 el emisor y no cualquier otra persona, garantizando por un lado la autor\xEDa y por otro evitando que el emisor niegue haber generado esa informaci\xF3n.\r
\r
## 6.4.3 Certificados digitales\r
\r
Un certificado digital es un documento electr\xF3nico expedido por una **Autoridad de Certificaci\xF3n** e identifica a una persona (f\xEDsica o jur\xEDdica) con un par de claves.Tiene como misi\xF3n validar y certificar que una firma electr\xF3nica se corresponde con una persona o entidad concreta.\r
\r
Contiene la informaci\xF3n necesaria para firmar electr\xF3nicamente e identificar a su propietario con sus datos: nombre, NIF, algoritmo y claves de firma, fecha de expiraci\xF3n y organismo que lo expide.\r
\r
La Autoridad de Certificaci\xF3n da fe de que la firma electr\xF3nica se corresponde con un usuario concreto. Esa es la raz\xF3n por la que los certificados est\xE1n firmados, a su vez, por la Autoridad de Certificaci\xF3n.\r
\r
### Claves digitales\r
\r
En un certificado, las claves digitales son los elementos esenciales para la firma e identificaci\xF3n del firmante. Existen dos claves, la **clave privada** y **clave p\xFAblica**, y trabajan de forma complementaria. *Lo que cifra o codifica una clave s\xF3lo lo puede descifrar o decodificar la otra*.\r
\r
La diferencia entre ellas es que la clave privada est\xE1 pensada para que nunca salga del certificado y est\xE9 siempre bajo el control del firmante. En cambio, la clave p\xFAblica se puede repartir o enviar a otros usuarios.\r
\r
En ocasiones, se habla de Certificado Privado para referirse al certificado que contiene la clave privada y la p\xFAblica y del Certificado P\xFAblico para referirse al certificado que s\xF3lo contiene la clave p\xFAblica.\r
\r
::: info Creaci\xF3n de Certificados digitales\r
Obtener el Certificado Digital depende de si el certificado est\xE1 contenido en una tarjeta, como el DNIe, o de si el certificado se guarda en un fichero software.\r
\r
En ambos procesos hay un paso que es la identificaci\xF3n del responsable o usuario del certificado, lo cual requiere que \xE9ste **se persone en las oficinas de una Autoridad de Registro**. Estas oficinas corroboran la identidad.\r
:::\r
\r
### Infraestructura de clave p\xFAblica (PKI)\r
\r
Una infraestructura de clave p\xFAblica (PKI) es una combinaci\xF3n de hardware, software, procedimientos de seguridad y marco legal que, en su conjunto, permite la ejecuci\xF3n con garant\xEDas de operaciones criptogr\xE1ficas, cumpliendo los requisitos de integridad, confidencialidad, autenticaci\xF3n y no repudio.\r
\r
Una PKI permite establecer y gestionar asociaciones entre claves p\xFAblicas e identidades de personas y organizaciones.\r
\r
La cuesti\xF3n entonces es determinar si un certificado es v\xE1lido o de confianza, ol o que es lo mismo, si representa a la persona u organizaci\xF3n que aparece como titular y propietario  del certificado.\r
\r
Para dar por v\xE1lido un certificado digital su firma digital debe ser v\xE1lida y su emisor debe ser un emisor de confianza. Por lo tanto, ahora queda determinar qu\xE9 emisores son de confianza.\r
\r
::: warning Autenticidad de los certificados\r
Los certificados deben estar firmados por una AC por dos motivos\r
\r
1. Garantizar su integridad, de forma que cualquier intento de modificaci\xF3n del certificado lo invalide.\r
2. Identificar al creador del certificado digital. Todo el sistema est\xE1 basado en una relaci\xF3n de confianza, en la que la AC que ha firmado el certificado es un emisor de confianza, normalmente instituciones p\xFAblicas o privadas de reconocido prestigio\r
:::\r
\r
En nuestro sistema podemos ver y modificar qu\xE9 entidades de certificaci\xF3n consideramos como seguras, es decir, que los certificados que \xE9stas hayan firmado los tomaremos como v\xE1lidos.\r
\r
[Autoridades de confianza para apps de Azure](https://docs.microsoft.com/es-es/exchange/trusted-root-certification-authorities-for-federation-trusts-exchange-2013-help)\r
\r
En Windows, si ejecutamos \`certmgr.msc\` podemos acceder a la configuraci\xF3n de certificados del sistema. En OSX lo podemos hacer con la aplicaci\xF3n \`Llavero\`.\r
\r
Para nuestra navegaci\xF3n, la informaci\xF3n de qu\xE9 certificados considera el navegador como seguros, depende de en qu\xE9 AC confiemos (por defecto en la instalaci\xF3n vienen configurados los m\xE1s comunes)\r
\r
[Ver certificados y AC en Chrome](https://www.adminfacil.es/como-ver-los-certificados-instalados-en-google-chrome/)\r
\r
::: danger Certificados autofirmados\r
**Hemos de tener en cuenta que, con herramientas como las que proporciona Java, SSH o GnuPG cualquiera puede generar un certificado digital con la informaci\xF3n que quiera**\r
\r
Para las pruebas vamos a firmar nuestros propios certificados. Incluso dentro de una compa\xF1\xEDa podemos ejercer nosotros mismos como Autoridad de Certificaci\xF3n de Confianza, firmando nuestros certificados.\r
\r
Debemos preparar la configuraci\xF3n de nuestros sistemas para que **conf\xEDen** en esos certificados autofirmados, asumiendo el riesgo que esto conlleva.\r
:::\r
\r
## 6.4.4. Generaci\xF3n de pares de claves\r
\r
La generaci\xF3n y gesti\xF3n de pares de claves implica dos aspectos fundamentales.\r
\r
Por un lado, tenemos la creaci\xF3n de las claves. Las claves las podemos haber descargado, generado con alguna de las utilidades disponibles para ellos o bien, como veremos a continuaci\xF3n, se pueden generar desde una aplicaci\xF3n, igual que hacemos con las claves sim\xE9tricas.\r
\r
Por otro lado, tenemos la gesti\xF3n del almacenamiento de las claves. Las claves no dejan de ser archivos, que podemos tratar como archivos especiales, pero que usualmente se almacenan en repositorios especiales, denominados \`keyrings\` a los que puede acceder una aplicaci\xF3n y desde los que gestionamos las relaciones de confianza.\r
\r
El JCA nos proporciona clases generadoras de claves. Estas clases se apoyan en buenos algoritmos de generaci\xF3n de n\xFAmeros aleatorios para satisfacer unos requisitos m\xEDnimos de seguridad.\r
\r
::: info SecureRandom\r
La generaci\xF3n de n\xFAmeros aleatorios juega un papel fundamental en la criptograf\xEDa, siendo uno de los **Engine** que proporciona el JCA junto con un amplio grupo de algoritmos.\r
\r
La clase **SecureRandom** genera n\xFAmero aleatorios empleando alguno de los algoritmos disponibles y se puede utilizar un objeto de tipo SecureRandom para que los utilicen las clases generadoras de claves, tanto sim\xE9tricas como asim\xE9tricas\r
:::\r
\r
### Tipos de ficheros para certificados digitales\r
\r
Hay varios tipos de ficheros que se utilizan para guardar certificados digitales siguiendo el est\xE1ndar X.509. Generalmente uncertificado no contiene s\xF3lo la clave, sino que tiene informaci\xF3n adicional.\r
\r
Esxiten dos posibles codificaciones para almacenar certificados X.509\r
\r
- der: Es una codificaci\xF3n binaria\r
- dem: Es una codificaci\xF3n en formato texto guardado en Base64 y tienen un encabezado y pie que delimita el contenido del certificado\r
\r
Veamos un ejemplo de certificado con codificaci\xF3n dem\r
\r
\`\`\`sh\r
-----BEGIN CERTIFICATE----- \r
MIIDijCCAvOgAwIBAgIJAKRvtQxONVZoMA0GCSqGSIb3DQEBBAUAMIGLMQswCQYD \r
VQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxl \r
MSAwHgYDVQQKExdBcnViYSBXaXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFD \r
MSMwIQYDVQQDExpteXNlcnZlci5hcnViYW5ldHdvcmtzLmNvbTAeFw0wODA0MzAy \r
MzM3MDJaFw0xMDA0MzAyMzM3MDJaMIGLMQswCQYDVQQGEwJVUzETMBEGA1UECBMK \r
Q2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxlMSAwHgYDVQQKExdBcnViYSBX \r
aXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFDMSMwIQYDVQQDExpteXNlcnZl \r
ci5hcnViYW5ldHdvcmtzLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA \r
zRwqc9prVXycGhHcsAjGPzC2MKU4DhXSr86Z89Jk8/cXEJBJ0C/NgdAqqDgxneUh \r
nVyxGxODa7BNGAWSagdCsKLrbkchr479E3xLfgdc3UzAJITLGCXGiQ66NwQDyM5I \r
G/xKYm4oqgyOE/lFTTkK0M8V0NmmJynyOCYC/AwQKjMCAwEAAaOB8zCB8DAdBgNV \r
HQ4EFgQUM5btT6IlPGkLTTPvFccTVURO1p0wgcAGA1UdIwSBuDCBtYAUM5btT6Il \r
PGkLTTPvFccTVURO1p2hgZGkgY4wgYsxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpD \r
YWxpZm9ybmlhMRIwEAYDVQQHEwlTdW5ueXZhbGUxIDAeBgNVBAoTF0FydWJhIFdp \r
cmVsZXNzIE5ldHdvcmtzMQwwCgYDVQQLEwNUQUMxIzAhBgNVBAMTGm15c2VydmVy \r
LmFydWJhbmV0d29ya3MuY29tggkApG+1DE41VmgwDAYDVR0TBAUwAwEB/zANBgkq \r
hkiG9w0BAQQFAAOBgQBp71WeF6dKvqUSO1JFsVhBeUesbEgx9+tx6eP328uL0oSC \r
fQ6EaiXZVbrQt+PMqG0F80+4wxVXug9EW5Ob9M/opaCGI+cgtpLCwSf6CjsmAcUc \r
b6EjG/l4HW2BztYJfx15pk51M49TYS7okDKWYRT10y65xcyQdfUKvfDC1k5P9Q== \r
-----END CERTIFICATE-----\r
\`\`\`\r
\r
Adem\xE1s de la codificaci\xF3n, tenemos formatos de fichero est\xE1ndar para guardar los certificados usando una de las codificaciones anteriores\r
\r
- cer, crt, der: Contienen certificados X.509 est\xE1ndares codificados como \`der\`\r
- p12: Realmente hace referencia a toda una familia de est\xE1ndares asociados al algoritmo RSA y definen el formato de almacenamiento de distintos tipos de claves, los PKCS#n (PKCS#8, PKCS#12, etc). Pueden contener, adem\xE1s de los datos del certificado, una clave privada. Si contiene la clave privada, \xE9sta estar\xE1 protegida por una contrase\xF1a que ser\xE1 necesaria para acceder a la clave privada. [PKCS en Wikipedia](https://es.wikipedia.org/wiki/PKCS)\r
\r
### Generaci\xF3n de claves desde Java\r
\r
Usando las clases del JCA, estos son los pasos que debemos seguir para generar un par de claves desde c\xF3digo\r
\r
1. El primer paso para obtener un par de claves es obtener un objeto *keyPairGenerator* para el algoritmo que queramos utilizar.\r
2. A continuaci\xF3n se inicializa el generador del par de claves llamando a alguna de las versiones del m\xE9todo *initialize*. En nuestro caso indicaremos el tama\xF1o de clave para el algoritmo seleccionado y un generador de n\xFAmeros aleatorios.\r
3. El \xFAltimo paso es generar el par de claves y guardarlas en los objetos PrivateKey y PublicKey respectivamente.\r
4. A partir de ese momento ya se pueden usar las claves para cifrar, descifrar e incluso para firmar. Sin embargo, si queremos reutilizar estas claves, lo que tendremos que hacer ser\xE1 guardarlas en sendos archivos.\r
\r
A continuaci\xF3n podemos ver un ejemplo de generaci\xF3n de claves, almacenamiento de las claves en un fichero y visualizaci\xF3n de la clave obtenida.\r
\r
\`\`\`java{14,15,18-20,39,52}\r
public class U6S5_GenerateRsaKeyPair {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            // Elijo un algoritmo de generaci\xF3n de n\xFAmeros aleatorios de los denominados\r
            // altamente seguros para generar el par de claves\r
            SecureRandom algoritmoSeguro = SecureRandom.getInstanceStrong();\r
            // Preparo el generados de claves para usar el algortimo RSA\r
            KeyPairGenerator genParClaves = KeyPairGenerator.getInstance(algoritmoClaveAsimetrica);\r
            genParClaves.initialize(tamanoClaveAsimetrica, algoritmoSeguro);\r
\r
            // Creo el par de claves y lo guardo en objetos\r
            KeyPair parClaves = genParClaves.generateKeyPair();\r
            PublicKey clavePublica = parClaves.getPublic();\r
            PrivateKey clavePrivada = parClaves.getPrivate();\r
\r
            // Guardamos la clave p\xFAblica en un archivo y la visualizamos\r
            // La clave se guarda con codificaci\xF3n DER y en formato X.509\r
            guardaClavePublicaX509(clavePublica);\r
            \r
            // Guardamos la clave privada en un archivo y la visualizamos\r
            // La clave se guarda con codificaci\xF3n DER y en formato PKCS#8\r
            guardaClavePrivadaPKCS8(clavePrivada);\r
            \r
\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementaci\xF3n del algortimo en ning\xFAn Provider");\r
        }\r
\r
    }\r
\r
    private static void guardaClavePublicaX509(PublicKey clavePublica) {\r
        try (FileOutputStream publicKeyFile = new FileOutputStream(ficheroClavePublica)) {\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublica.getEncoded(), algoritmoClaveAsimetrica);\r
            publicKeyFile.write(clavePublica.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePublica.getEncoded(),\r
                    codificacionClavePublica.getFormat(), ficheroClavePublica);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave p\xFAblica en " + ficheroClavePublica);\r
        }                \r
    }\r
\r
    private static void guardaClavePrivadaPKCS8(PrivateKey clavePrivada) {\r
        try (FileOutputStream privateKeyFile = new FileOutputStream(ficheroClavePrivada)) {\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivada.getEncoded(), algoritmoClaveAsimetrica);\r
            privateKeyFile.write(clavePrivada.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePrivada.getEncoded(),\r
                    codificacionClavePrivada.getFormat(), ficheroClavePrivada);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave privada en " + ficheroClavePrivada);\r
        }        \r
    }\r
\r
    private static void MostrarClaveBase64(byte[] clave, String formatoClave, String ficheroClave) {\r
        System.out.println("Clave guardada en formato " + formatoClave \r
                + " en fichero " + ficheroClave);\r
        System.out.println(Base64.getEncoder().encodeToString(clave).replaceAll("(.{76})", "$1\\n"));\r
    }\r
}\r
\`\`\`\r
\r
Esta ser\xEDa la salida proporcionada\r
\r
\`\`\`sh\r
Clave guardada en formato X.509 en fichero claves/clavepublica.der\r
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC4UFRgEIm3lFKO75QmqTPvkDs0fM6NUm2FHQcA\r
cQHawLx9/WKXh9xkx/xYZZcc4L2YQYcwTu4jfk889iGKGLn2Kh4ywBY+g8uZ6ljM5PT6f95dU6Zd\r
xATWOn1qsizBubf7kKhBL7xDnKU5do3XYzrSjme+9uIsgS7HQ7K0MbKrpQIDAQAB\r
\r
Clave guardada en formato PKCS#8 en fichero claves/claveprivada.pkcs8\r
MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALhQVGAQibeUUo7vlCapM++QOzR8\r
zo1SbYUdBwBxAdrAvH39YpeH3GTH/FhllxzgvZhBhzBO7iN+Tzz2IYoYufYqHjLAFj6Dy5nqWMzk\r
9Pp/3l1Tpl3EBNY6fWqyLMG5t/uQqEEvvEOcpTl2jddjOtKOZ7724iyBLsdDsrQxsqulAgMBAAEC\r
gYA97xBLL4N3YqnTSgIYc6b2Cxs56e5mYppWrohZx5996GHuXCSzEn4mh2TuN0Tt+T78WJiazQsM\r
djceHv7qLqDd2kWn3IR0gX207KxwjG0I/sAP2z/i9NZ7DPL+FUv8lmeYUfDj8h3wkyhmBqn+tan1\r
0xIOcZUrr/yRhrjZLI1SCQJBAPEc4uWSbyBLHVC6SNga7XWNmwi8Mq4PZJdhW9RJWDxg9zOlC/HV\r
rV60ddbfW/ldIqCH33DUge5U5YhD6Mla/XMCQQDDsahcwTksp2bJowMTRgFHT094sihtSlQ7sgdI\r
uAemuMvBmVTHleFBWMqz1rAN6A/76yef3WK4I+nsmeCGa+yHAkEA7BR1kYT8q+kATi/n7TkIcoZx\r
W28yTD2kJ5jbWhNqgswKn5WmCWdH9qfJjddrbdEke3wuaoKYqeyURgUAJE+kQwJADhEsQBanrH0Q\r
F3h/VRhYKS8bUFrGKy0Hpw7iFSkda6+m/fCutnYgrhja4ViSaT2AQKSjwYsheIkkXJynFiKV6wJA\r
PUHXqlvfgPr4w2U+Ddq7h/gp59kO0uojGrEBO0B2wt3PuuSQlZlMN97Ly9QmB6LYRtw6woCZZZOD\r
ePqA7rf8IA==\r
\`\`\`\r
\r
En el ejemplo anterior en lugar de utilizar clases est\xE1ndar para volcar el contenido binario de las claves a un archivo en formato raw, se utilizan clases codificadoras para generar ficheros binarios en formatos est\xE1ndares, tanto para la clave p\xFAblica como para la privada.\r
\r
Esto tiene la enorme ventaja de que se pueden utilizar las claves generadas con herramientas est\xE1ndar como openssl. Adem\xE1s, facilita la tarea ya que las claves p\xFAblica y privada para criptograf\xEDa asim\xE9trica son objetos compuestos.\r
\r
::: info Codificaci\xF3n Base64\r
Base64 es un grupo de esquemas de codificaci\xF3n de binario a texto que representa los datos binarios mediante una cadena.\r
\r
Los esquemas de codificaci\xF3n Base64 son com\xFAnmente usados cuando se necesita codificar datos binarios para que sean almacenados y transferidos sobre un medio dise\xF1ado para tratar con datos textuales. Esto es para asegurar que los datos se mantienen intactos y sin modificaciones durante la transmisi\xF3n.\r
\r
Los valores codificados en Base64 como texto se muestran en filas de 76 caracteres como m\xE1ximo, para mejor legibilidad, y siguiendo convenciones habituales.\r
\r
Para verlos en pantalla se a\xF1ade un salto de l\xEDnea despu\xE9s de cada grupo de 76 caracteres usando  \`replaceAll("(.{76})", "$1\\n")\`.\r
:::\r
\r
Las claves que se han guardado con el programa tienen las siguientes caracter\xEDsticas:\r
\r
- La clave p\xFAblica se guarda en un fichero \`clavepublica.der\`, con el formato de la estructura *SubjectPublicKeyInfo* en formato *ASN.1* definido en el est\xE1ndar *X.509*, y con codificaci\xF3n *DER (binaria)*. Para eso se ha utilizado la clase codificadora **X509EncodedKeySpec**.\r
- La clave privada se guarda en un fichero \`claveprivada.pkcs8\`, en formato *PKCS#8*, y con codificaci\xF3n *DER (binaria)*. Para eso se ha utilizado la clase codificadora **PKCS8EncodedKeySpec**.\r
\r
::: info Codificaciones por defecto\r
Las codificaciones usadas en el programa coinciden con las codificacione por defecto que usan las clases PrivateKey y PublicKey, como se puede ver en los valores proporcionados por los m\xE9todos getFormat() y getEncoded().\r
:::\r
\r
## 6.4.5. Cifrado y descifrado usando un par de claves\r
\r
Aunque ya hemos visto que las claves se pueden generar desde c\xF3digo, lo normal es que una vez hayamos generado un par de claves, estas se puedan reutilizar desde las aplicaciones para cifrar y descifrar informaci\xF3n.\r
\r
Si hemos guardado las claves en archivos, el primer paso que tendremos que realizar es recuperar esas claves para poder realizar las operaciones criptogr\xE1ficas con ellas.\r
\r
::: question Prueba de claves online\r
Podemos probar las claves generadas con una herramienta online.\r
\r
[Online RSA tool](https://www.devglan.com/online-tools/rsa-encryption-decryption)\r
\r
Prueba a copiar el contenido (en Base64) de las claves p\xFAblica y privada para hacer un cifrado y un descifrado de la informaci\xF3n.\r
\r
Tambi\xE9n puedes probar a simular una firma digital, realizando el cifrado con la clave privada y el descifrado con la clave p\xFAblica.\r
:::\r
\r
Veamos un ejemplo de c\xF3mo se hace todo este proceso en Java\r
\r
\`\`\`java{23-25,38-40,76-78,108-110}\r
public class U6S6_RsaKeyPairEncrypt {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            //////////////////////////////////////////////////\r
            // CIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave p\xFAblica de un archivo\r
            PublicKey clavePublica = leerClavePublica(ficheroClavePublica);\r
\r
            // Preparamos la informaci\xF3n que queremos cifrar\r
            String textoEnClaro = "Quiero cifrar este mensaje de prueba";\r
            byte[] mensajeEnClaro = textoEnClaro.getBytes("UTF-8");\r
            \r
            // Realizamos el proceso de cifrado con clave p\xFAblica\r
            // Los pasos son exactamente los mismos que con el cifrado sim\xE9trico\r
            Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.ENCRYPT_MODE, clavePublica);\r
            byte[] mensajeCifrado = cifrado.doFinal(mensajeEnClaro);\r
            // Visualizamos el mensaje cifrado en modo texto\r
            MostrarMensajeBase64(mensajeCifrado);\r
            \r
            //////////////////////////////////////////////////\r
            // DESCIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave privada de un archivo\r
            PrivateKey clavePrivada = leerClavePrivada(ficheroClavePrivada);\r
\r
            // Realizamos el proceso de descifrado con clave privada\r
            // Los pasos son exactamente los mismos que con el cifrado sim\xE9trico\r
            // Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.DECRYPT_MODE, clavePrivada);\r
            byte[] mensajeDescifrado = cifrado.doFinal(mensajeCifrado);\r
            // Visualizamos el mensaje descifrado\r
            System.out.println("Texto descifrado:\\n" + new String(mensajeDescifrado, "UTF-8"));\r
                        \r
        } catch (UnsupportedEncodingException ex) {\r
            System.out.println("Codificaci\xF3n de caracteres UTF-8 no soportada");\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementaci\xF3n del algoritmo " + algoritmoClaveAsimetrica + " en ning\xFAn Provider");\r
        } catch (NoSuchPaddingException ex) {\r
            System.err.println("El relleno especificado para el algoritmo no est\xE1 permitido");\r
        } catch (InvalidKeyException ex) {\r
            System.err.println("Especificaci\xF3n de clave no v\xE1lida");\r
        } catch (IllegalBlockSizeException ex) {\r
            System.err.println("Tama\xF1o de bloque no v\xE1lido");\r
        } catch (BadPaddingException ex) {\r
            System.err.println("Excepci\xF3n con el relleno usado por el algoritmo");\r
        }\r
    }\r
\r
    private static PublicKey leerClavePublica(String ficheroClave) {\r
        byte[] clavePublicaEncoded;\r
\r
        // Leemos la informaci\xF3n del archivo\r
        try (FileInputStream publicKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePublicaEncoded = publicKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave p\xFAblica.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave p\xFAblica.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes le\xEDdos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublicaEncoded);\r
            PublicKey clavePublica = keyFactory.generatePublic(codificacionClavePublica);\r
\r
            // Devolvemos la clave p\xFAblica generada\r
            return clavePublica;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementaci\xF3n del algoritmo " + algoritmoClaveAsimetrica + " en ning\xFAn Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
\r
    private static PrivateKey leerClavePrivada(String ficheroClave) {\r
        byte[] clavePrivadaEncoded;\r
\r
        // Leemos la informaci\xF3n del archivo\r
        try (FileInputStream privateKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePrivadaEncoded = privateKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave privada.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave privada.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes le\xEDdos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivadaEncoded);\r
            PrivateKey clavePrivada = keyFactory.generatePrivate(codificacionClavePrivada);\r
\r
            // Devolvemos la clave p\xFAblica generada\r
            return clavePrivada;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementaci\xF3n del algoritmo " + algoritmoClaveAsimetrica + " en ning\xFAn Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
    \r
    private static void MostrarMensajeBase64(byte[] mensajeCifrado) {\r
        System.out.println("Mensaje cifrado visualizado como texto en Base64:");                \r
        System.out.println(Base64.getEncoder().encodeToString(mensajeCifrado).replaceAll("(.{76})", "$1\\n"));\r
    }    \r
}\r
\`\`\`\r
\r
Y esta es la salida proporcionada\r
\r
\`\`\`sh\r
Mensaje cifrado visualizado como texto en Base64:\r
EV+7WrEf+4CYwckys9blk6DXnLHUm4i0k+4BIp3oNmPdo2skYY8bQsAhXToBx2gi/rMIK9wiJTH0\r
yg99jpyaLeUgtga8PxWx1plgvxohzO/lALkf5AFRUczZh8F5QvOXCi93v2ycZCZXq7QmZTopkEQh\r
ARSezD/1Al2UYPc2X68=\r
\r
Texto descifrado:\r
Quiero cifrar este mensaje de prueba\r
\`\`\`\r
\r
::: warning Cifrado siempre diferente, descifrado siempre igual\r
El resultado de cifrar un mensaje con la misma clave p\xFAblica no siempre es igual, aunque al descifrar los mensajes con la clave privada siempre se obtiene el mensaje original.\r
\r
Esto es debido a que, para aumentar la variabilidad (**entrop\xEDa**) del mensaje cifrado al mensaje que se cifra se le a\xF1ade una parte aleatoria (**salt**) que se descarta cuando se descifra.\r
:::\r
\r
En el c\xF3digo podemos observar c\xF3mo los procesos para cargar la clave desde un archivo usan las mismas clases que cuando se generaron, siendo el c\xF3digo muy parecido.\r
\r
En cuanto al cifrado y descifrado se realiza con el *Engine Cipher* usando la misma secuencia de llamadas que con el cifrado sim\xE9trico.\r
\r
## 6.2.3. Cifrado asim\xE9trico con GnuPG\r
\r
Con la suite GnuPG tambi\xE9n podemos generar pares de claves y cifrar y descifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la informaci\xF3n de los algoritmos disponibles para cada tipo de servicio. En concreto, de res\xFAmenes, en mi versi\xF3n instalada:\r
\r
Clave p\xFAblica: RSA, ELG, DSA, ECDH, ECDSA, EDDSA\r
:::\r
\r
Para generar las claves, ejecutamos los siguientes comandos\r
\r
TO-DO: Completar\r
\r
Para cifrar y descifrar un archivo con las claves generadas, ejecutamos los siguientes comandos\r
\r
TO-DO: Completar\r
`]},{title:"6.2 Funciones resumen",headers:[{level:2,title:"6.2.1. Funciones hash",slug:"_6-2-1-funciones-hash",link:"#_6-2-1-funciones-hash",children:[]},{level:2,title:"6.2.2. MessageDigest",slug:"_6-2-2-messagedigest",link:"#_6-2-2-messagedigest",children:[]},{level:2,title:"6.2.3. MessageDigest con GnuPG",slug:"_6-2-3-messagedigest-con-gnupg",link:"#_6-2-3-messagedigest-con-gnupg",children:[]}],path:"/es/unit6/hash-functions.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.2 Funciones resumen\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.2 Funciones resumen" />\r
\r
# 6.2 Funciones resumen\r
\r
[[toc]]\r
\r
## 6.2.1. Funciones hash\r
\r
Un *Message digest* o resumen de mensaje, m\xE1s conocidos como **funciones hash**, es una marca digital de un bloque de datos. Existe un gran n\xFAmero de algoritmos dise\xF1ados para procesar esto res\xFAmenes, los dos m\xE1s conocidos son SHA-1 y MD5.\r
\r
De un resumen cabe destacar las siguientes caracter\xEDsticas:\r
\r
- Para el mismo algoritmo, el resumen siempre tiene el mismo tama\xF1o, independientemente del tama\xF1o de los datos que se haya usado para generarlo.\r
- Es imposible recuperar la informaci\xF3n original a partir de un resumen.\r
- El resumen no debe desvelar nada sobre los datos que se utilizaron para generarlo.\r
- Es computacionalmente inviable encontrar dos mensajes que tengan el mismo valor de resumen.  Matem\xE1ticamente es altamente improbable, pero no imposible.\r
- Un peque\xF1o cambio en los datos resumidos genera un resumen completamente diferente.\r
\r
Los res\xFAmenes se usan para generar identificadores \xFAnicos y confiables. A veces se les llama *checksum*, ya que sirven para comprobar si una descarga se ha realizado correctamente, generando su resumen y compar\xE1ndolo con el que gener\xF3 el archivo original.\r
\r
::: warning Un hash no sirve para cifrar\r
Es importante destacar que, debido a que es imposible obtener los datos que generaron un resumen a partir del propio resumen, el resumen no se puede usar para cifrar informaci\xF3n.\r
\r
Por el contrario, es un mecanismo que se usa para comparar. Su uso m\xE1s extendido es con las contrase\xF1as, ya que en las bases de datos se guarda un resumen en vez de la contrase\xF1a en claro. De esta forma, cuando se recibe una contrase\xF1a se genera su resumen y se compara con el valor almacenado.\r
:::\r
\r
## 6.2.2. MessageDigest\r
\r
La clase *MessageDigest* permite a las aplicaciones implementar algoritmos de resumen criptogr\xE1ficamente seguros como SHA-256 o SHA-512\r
\r
Para generar un hash con JCA se procede de la siguiente forma:\r
\r
1. Se crea un objeto de la clase *MesageDigest* con el m\xE9todo est\xE1tico *getInstance()* de la misma clase, especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.\r
2. Se a\xF1aden datos con el m\xE9todo *update()*. Se puede a\xF1adir un byte o un array de bytes. Este m\xE9todo se puede invocar varias veces para ir a\xF1adiendo nuevos datos.\r
3. Se obtiene el valor de hash con el m\xE9todo *digest()*.\r
4. Si se quisiera calcular un nuevo hash, se invocar\xEDa el m\xE9todo *reset()* para volver a empezar el proceso.\r
\r
A continuaci\xF3n podemos ver un ejemplo\r
\r
\`\`\`java\r
public class U6S2_MessageDigest {\r
\r
    public static void main(String[] args) {\r
        String plaintext = "Esto es un texto plano.";\r
        try {\r
            // Obtenemos un ENGINE que implementa el algoritmo especificado\r
            // Se puede indicar cualquier algoritmo disponible en el sistema\r
            // SHA-224, SHA-512, SHA-256, SHA3-224, ...\r
            MessageDigest m = MessageDigest.getInstance("SHA-256");\r
\r
            // Opcional - Reinicia el objeto para un nuevo uso \r
            // Por si queremos poner este c\xF3digo en un bucle y procesar m\xE1s\r
            // de un mensaje\r
            m.reset();\r
\r
            // Realiza el resumen de los datos pasados por par\xE1metro\r
            // Si queremos procesar la informaci\xF3n poco a poco, \r
            // debemos ir llamando al m\xE9todo update para cada bloque de datos\r
            m.update(plaintext.getBytes());\r
\r
            // Completa el c\xE1lculo del valor del hash y devuelve el resumen\r
            byte[] digest = m.digest();\r
\r
            // Mensaje de resumen\r
            System.out.println("Resumen (raw data): " + new String(digest));\r
\r
            // Mensaje en formato hexadecimal\r
            System.out.println("Resumen (hex data): " + toHexadecimal(digest));\r
            \r
            \r
            // Informaci\xF3n del proceso\r
            System.out.println("=> Algoritmo: " + m.getAlgorithm() + ", Provider: " + m.getProvider().getName() + " " + m.getProvider().getVersionStr());\r
        } catch (NoSuchAlgorithmException e) {\r
            System.err.println("No se ha encontrado la implementaci\xF3n del algoritmo MD5 en ning\xFAn Provider");\r
        }\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
}\r
\`\`\`\r
\r
y esta ser\xEDa la salida proporcionada\r
\r
\`\`\`sh\r
Resumen (raw data): \uFFFDY\uFFFD"\uFFFD3\x1B\uFFFD\uFFFD\`b\uFFFD\uFFFD\uFFFD\uFFFDbs?;\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD~E\r
Resumen (hex data): FB59D31122913314111B92CD60628ED7E7DE62733F3B10DEDAF303AAABE57E45\r
=> Algoritmo: SHA-256, Provider: SUN 11\r
\`\`\`\r
\r
## 6.2.3. MessageDigest con GnuPG\r
\r
Con la suite GnuPG podemos generar res\xFAmenes de archivos utilizando los algoritmos que nos proporciona la suite.\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la informaci\xF3n de los algoritmos disponibles para cada tipo de servicio. En concreto, de res\xFAmenes, en mi versi\xF3n instalada:\r
\r
Resumen: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224\r
:::\r
\r
Para generar un resumen de un archivo, ejecutamos el comando de la siguiente forma\r
\r
\`\`\`sh\r
gpg --print-md SHA256 filename.ext\r
\`\`\``]},{title:"6 Introducci\xF3n",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit6/",pathLocale:"/es/",extraFields:[`---\r
title: 6 Introducci\xF3n\r
---\r
\r
# Tema 6. T\xE9cnicas de programaci\xF3n segura\r
\r
El t\xE9rmino criptograf\xEDa es un derivado de la palabra riega *kryptos* que significa oculto y *grafos* que significa escritura. El objetivo de la criptograf\xEDa es ocultar el significado de un mensaje mediante el cifrado o codificaci\xF3n del mensaje.\r
\r
De todas las t\xE9cnicas de programaci\xF3n segura, nosotros vamos a estudiar en este tema\r
\r
- Las funciones de resumen (Hash)\r
- El **cifrado sim\xE9trico** o de clave oculta\r
- El **cifrado asim\xE9trico** o de clave privada\r
\r
Tambi\xE9n estudiaremos c\xF3mo usar canales seguros de comunicaci\xF3n para nuestras aplicaciones, mediante el uso de sockets seguros empleando SSL/TLS.\r
\r
Adem\xE1s, veremos una herramienta de seguridad que incorpora Java, las pol\xEDticas de seguridad.\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Identificar principios y pr\xE1cticas de programaci\xF3n segura.\r
- Analizar t\xE9cnicas y pr\xE1cticas criptogr\xE1ficas.\r
- Definir pol\xEDticas de seguridad.\r
- Emplear algoritmos criptogr\xE1ficos.\r
- Utilizar sockets seguros para la transmisi\xF3n de informaci\xF3n.\r
- Estudiar el funcionamiento de TLS/SSL sobre el protocolo TCP\r
- Conocer herramientas de uso gen\xE9rico en la criptograf\xEDa\r
`]},{title:"6.5 Comunicaciones seguras en Java",headers:[{level:2,title:"6.5.1. Protocolo SSL (Secure Sockets Layer)",slug:"_6-5-1-protocolo-ssl-secure-sockets-layer",link:"#_6-5-1-protocolo-ssl-secure-sockets-layer",children:[]},{level:2,title:"6.5.2. JSSE",slug:"_6-5-2-jsse",link:"#_6-5-2-jsse",children:[{level:3,title:"SSLSocket y SSLServerSocket",slug:"sslsocket-y-sslserversocket",link:"#sslsocket-y-sslserversocket",children:[]},{level:3,title:"keytool: certificados, confianza y almacenes de claves",slug:"keytool-certificados-confianza-y-almacenes-de-claves",link:"#keytool-certificados-confianza-y-almacenes-de-claves",children:[]}]},{level:2,title:"6.5.3. Servidor y Cliente SSL",slug:"_6-5-3-servidor-y-cliente-ssl",link:"#_6-5-3-servidor-y-cliente-ssl",children:[]}],path:"/es/unit6/jsse.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.5 Comunicaciones seguras en Java\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.5 Comunicaciones seguras en Java" />\r
\r
# 6.5 Comunicaciones seguras en Java\r
\r
[[toc]]\r
\r
## 6.5.1. Protocolo SSL (Secure Sockets Layer)\r
\r
SSL es el protocolo habitualmente usado para encriptar la comunicaci\xF3n cliente-servidor. Casi todo el tr\xE1fico de la red puede encriptarse con SSL: POP, IMAP, telnet, FTP, etc, pero es especialmente interesante para dotar de seguridad al protocolo HTTP, es decir como base del HTTPS.\r
\r
La implementaci\xF3n de SSL es una extensi\xF3n de los sockets que permite establecer un canal (stream) de comunicaci\xF3n. Dicha comunicaci\xF3n se inicia con un **handshake** durante el cual, el cliente y el servidor construyen una session-key (clave sim\xE9trica encriptada con par de claves asim\xE9tricas) compartida para verificar su identidad mutua.\r
\r
## 6.5.2. JSSE\r
\r
JSSE (Java Secure Socket Extension) es un conjunto de paquetes que permiten el desarrollo de aplicaciones seguras en Internet. Proporciona un marco y una implementaci\xF3n para Java de los protocolos SSL y TSL e incluye funcionalidad de\r
\r
- encriptaci\xF3n de datos\r
- autenticaci\xF3n de servidores\r
- integridad de mensajes\r
- autenticaci\xF3n de clientes\r
\r
Con JSSE, los programadores  pueden ofrecer intercambio seguro de datos entre un cliente y un servidor que ejecuta un protocolo de aplicaci\xF3n, tales como HTTP, Telnet o FTP, a trav\xE9s de TCP/IP.\r
\r
Las clases de JSSE se encuentran en los paquetes javax.net y javax.net.ssl.\r
\r
### SSLSocket y SSLServerSocket\r
\r
Las clases SSLSocket y SSLServerSocket representan sockets seguros y son derivadas de las ya conocidas Socket y ServerSocket respectivamente.\r
\r
JSSE tiene dos clases SSLServerSocketFactory y SSLSocketFactory para la creaci\xF3n de sockets seguros. No tienen constructor, se obtienen a trav\xE9s del m\xE9todo est\xE1tico getDefault().\r
\r
Para obtener un socket servidor seguro o *SSLServerSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
SSLServerSocket servidorSSL = (SSLServerSocket) = sfact.createServerSocket(puerto);\r
\`\`\`\r
\r
El m\xE9todo **createServerSocket(int puerto)** devuelve un socket de servidor enlazado al puerto especificado.\r
\r
Para crear un *SSLSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
SSLSocket Cliente = (SSLSocket) sfact.createSocket(Host, puerto);\r
\`\`\`\r
\r
El m\xE9todo createSocket (String host, int puerto) crea un socket y lo conecta con el host y el puerto especificados.\r
\r
### keytool: certificados, confianza y almacenes de claves\r
\r
Cuando dos socket SSL, uno cliente y otro servidor, intentan establecer conexi\xF3n, tienen que "presentarse" el uno al otro y comprobar que el otro es de confianza. Si todo va bien y uno conf\xEDa en l otro, la conexi\xF3n se establece, en caso contrario, no se establece.\r
\r
Para establecer esa confianza se debe crear un certificado en el servidor y a\xF1adirlo a los certificados de confianza del cliente.\r
\r
- El servidor debe tener su propio certificado. Si no lo tenemos, se puede generar primero una pareja de claves con la herramienta **keytool**, que viene incluida en el JDK de Java. La herramienta guardar\xE1 la pareja de claves en un almac\xE9n (el cual tiene su propia clave).\r
- Despu\xE9s generaremos un certificado a partir de esa pareja.\r
- El c\xF3digo del servidor necesitar\xE1 indicar el fichero donde se almacenan las claves y la clave para acceder a ese almac\xE9n.\r
- El cliente necesitar\xE1 indicar que conf\xEDa en el certificado del servidor. Dicho certificado del servidor puede estar guardado (por ejemplo) en el almac\xE9n de claves del cliente.\r
\r
::: info Seguridad mutua\r
Aunque no suele hacerse tambi\xE9n podr\xEDa hacerse a la inversa y obligar al cliente a tener un certificado que el servidor pudiera importar, lo que aumentar\xEDa la seguridad.\r
:::\r
\r
Vamos a ver c\xF3mo realizar estas operaciones previas con la herramienta **keytool**\r
\r
Primero las acciones a realizar en el servidor\r
\r
\`\`\`sh:no-line-numbers\r
# El servidor genera una pareja de claves que se almacena en un\r
# fichero llamado "clavesservidor". Dentro del fichero se indica\r
# un alias para poder referirnos a esa clave f\xE1cilmente\r
# keytool -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
What is your first and last name?\r
  [Unknown]:  Vicente Martinez\r
What is the name of your organizational unit?\r
  [Unknown]:  Dpto. Informatica\r
What is the name of your organization?\r
  [Unknown]:  IES Doctor Balmis\r
What is the name of your City or Locality?\r
  [Unknown]:  Alicante\r
What is the name of your State or Province?\r
  [Unknown]:  Alicante\r
What is the two-letter country code for this unit?\r
  [Unknown]:  ES\r
Is CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES correct?\r
  [no]: yes\r
\r
# El servidor genera su "certificado", es decir un fichero que\r
# de alguna forma indica quien es \xE9l. El certificado se almacena\r
# en un fichero llamado clavesservidor y a partir de \xE9l queremos\r
# generar el certificado de un alias creado previamente con nombre servidor\r
# keytool -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
Enter keystore password:\r
Certificate stored in file <servidor.cer>\r
\`\`\`\r
\r
En la carpeta donde hemos ejecutado el comando keytool, se ha creado el almac\xE9n de claves en un fichero llamado **ClavesServidor** y el certificado exportado en el archivo **servidor.cer**\r
\r
y a continuaci\xF3n las que habr\xEDa que realizar en el cliente para generar el almac\xE9n de confianza que, en nuestro caso contenga el mismo certificado que hemos exportado del servidor.\r
\r
\`\`\`sh:no-line-numbers\r
# Se importa el certificado del servidor indicando que pertenece a\r
# la lista de certificados confiables.\r
# keytool -importcert -trustcacerts -alias servidor -file servidor.cer -keystore clavescliente  -storepass 87654321\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -importcert -trustcacerts -alias servidor -file servidor.cer -keystore CertificadosConfianzaCliente -storepass 87654321\r
Owner: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Issuer: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Serial number: 4eb6f2a5\r
Valid from: Mon Jan 24 00:20:24 CET 2022 until: Sun Apr 24 01:20:24 CEST 2022\r
Certificate fingerprints:\r
         SHA1: DD:A2:75:4C:1C:BC:39:60:BE:B1:20:67:E1:5C:45:8C:48:B5:1F:54\r
         SHA256: 82:C8:56:C2:DB:DE:8C:73:A9:21:C6:7D:DE:1F:39:4F:79:CC:5F:D5:10:BC:61:DA:E3:EE:E1:1D:21:EA:D2:33\r
Signature algorithm name: SHA256withRSA\r
Subject Public Key Algorithm: 2048-bit RSA key\r
Version: 3\r
\r
Extensions:\r
\r
#1: ObjectId: 2.5.29.14 Criticality=false\r
SubjectKeyIdentifier [\r
KeyIdentifier [\r
0000: 16 AE 35 7C 58 97 B1 95   91 9B FA 6C 2A 80 D2 90  ..5.X......l*...\r
0010: 1C 50 7F C0                                        .P..\r
]\r
]\r
\r
Trust this certificate? [no]:  yes\r
Certificate was added to keystore\r
\`\`\`\r
\r
En esta ocasi\xF3n tambi\xE9n se crea, en la carpeta donde se ha ejecutado el comando keytool, un fichero **CertificadosConfianzaCliente** con el/los certificados de confianza para el cliente.\r
\r
## 6.5.3. Servidor y Cliente SSL\r
\r
En le siguiente ejemplo podemos observar como la inicializaci\xF3n del ServerSocket es diferente, pero a partir de que se llama al m\xE9todo accept y, en este caso se obtiene una instancia de tipo SSLSocket, el resto del c\xF3digo es igual que con la clase Socket.\r
\r
\`\`\`java{5,16,17,24}\r
public class U6S2_SSLServer {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteConectado = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante c\xF3digo, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicaci\xF3n\r
        // System.setProperty("javax.net.ssl.keyStore", System.getProperty("user.dir") + "\\\\ClavesServidor");\r
        // System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
        \r
        // Inicializaci\xF3n del ServerSocket SSL\r
        int puerto = 6000;\r
        SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
        SSLServerSocket servidorSSL = (SSLServerSocket) sfact.createServerSocket(puerto);\r
\r
        for (int i = 1; i < 5; i++) {\r
\r
            System.out.println("Esperando al cliente " + i);\r
\r
            // Se espera la conexi\xF3n de un cliente con accept\r
            clienteConectado = (SSLSocket) servidorSSL.accept();\r
            // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
            // el c\xF3digo del ejemplo\r
            flujoEntrada = new DataInputStream(clienteConectado.getInputStream());\r
            flujoSalida = new DataOutputStream(clienteConectado.getOutputStream());\r
\r
            // El cliente env\xEDa un mensaje\r
            System.out.println("Recibiendo del CLIENTE: " + i + " \\n\\t" + flujoEntrada.readUTF());\r
\r
            // El Servidor responde con un saludo\r
            flujoSalida.writeUTF("Saludos al cliente del servidor");\r
        }\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteConectado.close();\r
        servidorSSL.close();\r
    }\r
}\r
\`\`\`\r
\r
En el cliente el proceso es el mismo, tras la llamada al m\xE9todo createSocket, obtenemos una instancia de SSLSocket que utilizamos igual que si fuese un Socket.\r
\r
\`\`\`java{5,12,13,19,20}\r
public class U6S2_SSLClient {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteSSL = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante c\xF3digo, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicaci\xF3n\r
        // System.setProperty("javax.net.ssl.trustStore", System.getProperty("user.dir") + "/CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
        // Inicializaci\xF3n del ServerSocket SSL\r
        int puerto = 6000;\r
        String host = "localhost";\r
\r
        System.out.println("Programa Cliente iniciado....");\r
        SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
        clienteSSL = (SSLSocket) sfact.createSocket(host, puerto);\r
\r
        // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
        // el c\xF3digo del ejemplo\r
        flujoSalida = new DataOutputStream(clienteSSL.getOutputStream());\r
        flujoEntrada = new DataInputStream(clienteSSL.getInputStream());\r
\r
        // Env\xEDo un saludo al servidor\r
        flujoSalida.writeUTF("Saludos al SERVIDOR DESDE EL CLIENTE");\r
\r
        // El Servidor responde con un mensaje\r
        System.out.println("Recibiendo del SERVIDOR: \\n\\t" + flujoEntrada.readUTF());\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteSSL.close();\r
    }\r
\r
    void mostrarInformacionSesionSSL(SSLSocket cliente) throws SSLPeerUnverifiedException {\r
\r
        //------------------------------------------------------------------------------\r
        //Ejemplo de la m\xFAltiple informaci\xF3n sobre la sesi\xF3n SSL\r
        // que se puede obtener a partir \r
        SSLSession session = ((SSLSocket) cliente).getSession();\r
        System.out.println("Host: " + session.getPeerHost());\r
        System.out.println("Cifrado: " + session.getCipherSuite());\r
        System.out.println("Protocolo: " + session.getProtocol());\r
\r
        System.out.println("IDentificador:" + new BigInteger(session.getId()));\r
\r
        System.out.println("Creaci\xF3n de la sesi\xF3n: " + session.getCreationTime());\r
\r
        X509Certificate certificate = (X509Certificate) session.getPeerCertificates()[0];\r
        System.out.println("Propietario: " + certificate.getSubjectDN());\r
        System.out.println("Algoritmo: " + certificate.getSigAlgName());\r
        System.out.println("Tipo: " + certificate.getType());\r
        System.out.println("Emisor: " + certificate.getIssuerDN());\r
        System.out.println("N\xFAmero Serie: " + certificate.getSerialNumber());\r
        //-----------------------------------------------------------------------------\r
    }\r
}\r
\`\`\`\r
\r
Si ejecutamos el cliente y el servidor directamente, obtendremos el siguiente error\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Exception in thread "main" javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure\r
\`\`\`\r
\r
Para ejecutar el programa servidor es necesario indicar el certificado que se utilizar\xE1. \r
\r
Lo podemos indicar a la hora de ejecutar el programa, a\xF1adiendo a la l\xEDnea de comandos\r
\r
> java -Djavax.net.ssl.keyStore=ClavesServidor -Djavax.net.ssl.keyStorePassword=12345678\r
\r
y en el programa cliente es necesario indicar la ubicaci\xF3n de los certificados de confianza\r
\r
> java -Djavax.net.ssl.trustStore=CertificadosConfianzaCliente -Djavax.net.ssl.trustStorePassword=87654321\r
\r
![Netbeans: Opciones de la JVM](../../media/unit6/VM_Options.png)\r
\r
::: info Par\xE1metros de JVM o c\xF3digo\r
En el c\xF3digo anterior hay unas l\xEDneas comentadas que especifican c\xF3mo podemos configurar el valor de las propiedades desde c\xF3digo mediante el uso del m\xE9todo System.setProperty(String propiedad, String valor).\r
\r
En el programa servidor incluir\xEDamos las siguientes l\xEDneas:\r
\r
System.setProperty("javax.net.ssl.keyStore", "ClavesServidor");\r
System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
\r
Y en el programa cliente ser\xEDan estas:\r
\r
System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
\r
Adem\xE1s del nombre, podemos indicar la ruta donde se encuentran los almacenes, recordando que NO ES RECOMENDABLE el uso de barras invertidas para indicar rutas.\r
:::\r
\r
Una vez hechos los cambios, bien en las opciones de la JVM o bien en el c\xF3digo de las aplicaciones, la salida que obtendremos ser\xE1 esta\r
\r
<CodeGroup>\r
<CodeGroupItem title="Servidor" active>\r
\r
\`\`\`sh:no-line-numbers\r
Esperando al cliente 1\r
Recibiendo del CLIENTE: 1 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 2\r
Recibiendo del CLIENTE: 2 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 3\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Cliente">\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Recibiendo del SERVIDOR: \r
	Saludos al cliente del servidor\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
</CodeGroup>\r
\r
::: warning Default trusted certificates\r
Whenever Java attempts to connect to another application over SSL (e.g.: HTTPS, IMAPS, LDAPS), it will only be able to connect to that application if it can trust it. The way trust is handled in the Java world is that you have a keystore (typically $JAVA_HOME/lib/security/cacerts), also known as the truststore. This contains a list of all known Certificate Authority (CA) certificates, and Java will only trust certificates that are signed by one of those CAs or public certificates that exist within that keystore.\r
\r
If -Djavax.net.ssl.trustStore has been configured, it will override the location of the default truststore, which will need to be checked.\r
:::`]},{title:"6.1 Seguridad",headers:[{level:2,title:"6.1.1. Seguridad digital",slug:"_6-1-1-seguridad-digital",link:"#_6-1-1-seguridad-digital",children:[]},{level:2,title:"6.1.2. Seguridad en Java",slug:"_6-1-2-seguridad-en-java",link:"#_6-1-2-seguridad-en-java",children:[{level:3,title:"JCA: Engines, algoritmos y proveedores",slug:"jca-engines-algoritmos-y-proveedores",link:"#jca-engines-algoritmos-y-proveedores",children:[]}]},{level:2,title:"6.1.3. Proveedores",slug:"_6-1-3-proveedores",link:"#_6-1-3-proveedores",children:[]},{level:2,title:"6.1.4. Engines",slug:"_6-1-4-engines",link:"#_6-1-4-engines",children:[{level:3,title:"6.1.5. Algoritmos",slug:"_6-1-5-algoritmos",link:"#_6-1-5-algoritmos",children:[]}]}],path:"/es/unit6/security.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.1 Seguridad \r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.1 Seguridad" />\r
\r
# 6.1 Seguridad\r
\r
[[toc]]\r
\r
## 6.1.1. Seguridad digital\r
\r
Los aspectos fundamentales de la seguridad en las comunicaciones digitales son los siguientes\r
\r
- **Integridad**: Permite asegurar que los datos que recibe un receptor son id\xE9nticos a los que ha enviado el emisor. Es decir, no se ha modificado en ning\xFAn punto intermedio en **el canal, que como sabemos, es un canal compartido y por tanto, inseguro**. Las modificaciones pueden ser causadas por fallos en la transmisi\xF3n a trav\xE9s del canal o bien por una acci\xF3n intencionada de un tercero.\r
- **Confidencialidad**: Nos asegura que los datos transmitidos son inteligibles s\xF3lo para el receptor del mensaje. Por las caracter\xEDsticas del medio no podemos evitar que el mensaje llegue a otros destinatarios, pero lo que s\xED podemos evitar es que estos puedan ver el contenido original del mensaje. Esto se consigue cifrando el mensaje.\r
- **Autenticaci\xF3n**: Permite asegurar al receptor de un mensaje que el emisor del mensaje es quien dice ser y no cualquier otro. Esto se consigue con los certificados y la firma digital.\r
- **No repudio**: Es una consecuencia de la caracter\xEDstica anterior, ya que un receptor puede demostrar que el mensaje fue enviado por un emisor de forma inequ\xEDvoca.\r
\r
## 6.1.2. Seguridad en Java\r
\r
[oracle Security Developers Guide](https://docs.oracle.com/en/java/javase/11/security/java-cryptography-architecture-jca-reference-guide.html)\r
\r
Desde el punto de vista de la seguridad, el conjunto de clases de seguridad distribuidas con el SDK de Java 2 pueden dividirse en dos subconjuntos:\r
\r
- Clases relacionadas con el control de acceso y la gesti\xF3n de permisos.\r
- Clases relacionadas con la Criptograf\xEDa.\r
\r
Java incluye APIs de acceso a funciones criptogr\xE1ficas de prop\xF3sito general, conocidas como la **Arquitectura Criptogr\xE1fica de Java o Java Cryptography Architecture (JCA)** y la **Extension Criptogr\xE1fica de Java o Java Cryptography Extension (JCE)**.\r
\r
El JCA est\xE1 formado por las clases b\xE1sicas relacionadas con criptograf\xEDa distribuidas con el JDK y el soporte para la encriptaci\xF3n lo proporciona el paquete de extensi\xF3n JCE.\r
\r
Java tambi\xE9n incluye un conjunto de paquetes para la comunicaci\xF3n segura en Internet, conocidos como la **Extensi\xF3n de Sockets Seguros de Java o Java Secure Socket Extension (JSSE)**. Implementa una versi\xF3n Java de los protocolos SSL y TLS, adem\xE1s incluye funcionalidades como cifrado de datos, autenticaci\xF3n del servidor, integridad de mensajes y autenticaci\xF3n del cliente.\r
\r
Por \xFAltimo Java incluye una interfaz que permite a las aplicaciones Java acceder a servicios de control de autenticaci\xF3n y acceso, el **Servicio de Autentificaci\xF3n y Autorizaci\xF3n de Java o Java Authentication and Authorization Service (JAAS)**. Puede usarse con dos fines: la autenticaci\xF3n de usuarios para conocer qui\xE9n est\xE1 ejecutando c\xF3digo Java; y la autorizaci\xF3n de usuarios para garantizar que qui\xE9n lo ejecuta tiene los permisos necesarios para hacerlo.\r
\r
### JCA: Engines, algoritmos y proveedores\r
\r
Java tiene una Arquitectura de Proveedores, que permite que coexistan multiples implementaciones de algoritmos criptogr\xE1ficos (es decir multiples implementaciones del JCE). La plataforma Java 2 extiende substancialmente la JCA, entre otras cosas se ha mejorado la infraestructura de gesti\xF3n de certificados para soportar los certificados X.509 V3.\r
\r
Para comprender el funcionamiento del JCA tenemos que definir algunos t\xE9rminos b\xE1sicos:\r
\r
#### Engine\r
\r
En el contexto del JCA utilizamos el t\xE9rmino motor (engine) para referirnos a una representaci\xF3n abstracta de un servicio criptogr\xE1fico que no tiene una implementaci\xF3n concreta. Un servicio criptogr\xE1fico siempre est\xE1 asociado con un algoritmo o tipo de algoritmo y puede tener alguna de las siguientes funciones:\r
\r
- Proporcionar operaciones criptogr\xE1ficas (como las empleadas en el firmado y el resumen de mensajes)- Generar o proporcionar el material criptogr\xE1fico (claves o par\xE1metros) necesario para realizar las operaciones.\r
- Generar objetos (almacenes de claves o certificados) que agrupen claves criptogr\xE1ficas de modo seguro.\r
\r
#### Algoritmo\r
\r
Un algoritmo es una implementaci\xF3n de un motor. Por ejemplo, el algoritmo MD5 es una implementaci\xF3n del motor de algoritmos de resumen de mensajes. La implementaci\xF3n interna puede variar dependiendo del c\xF3digo que proporcione la clase MD5.\r
\r
#### Proveedor\r
\r
Un proveedor es el encargado de proporcionar la implementaci\xF3n de uno o varios algoritmos al programador (es decir, darle acceso a una implementaci\xF3n interna concreta de los algoritmos).\r
\r
## 6.1.3. Proveedores\r
\r
La JCA define el concepto de proveedor mediante la clase Provider del paquete java.security. Se trata de una clase abstracta que debe ser redefinida por clases proveedor espec\xEDficas.\r
\r
El constructor de una clase proveedor ajusta los valores de varias propiedades que necesita el API de seguridad de Java para localizar los algoritmos u otras facilidades implementadas por el proveedor.\r
\r
La clase Provider tiene m\xE9todos para acceder al nombre del proveedor, el n\xFAmero de versi\xF3n y otras informaciones sobre las implementaciones de los algoritmos para la generaci\xF3n, conversi\xF3n y gesti\xF3n de claves y la generaci\xF3n de firmas y res\xFAmenes.\r
\r
Si un programador desea saber los proveedores disponibles puede emplear los m\xE9todos\r
\r
- getProvider("nombre") para saber si un proveedor concreto est\xE1 instalado\r
- getProviders() que retorna un vector de cadenas con los nombres de los proveedores\r
\r
::: info Archivo java.security\r
%JAVA_HOME%/conf/security/java.security es el archivo que contiene la informaci\xF3n de la configuraci\xF3n de seguridad que utilizan las clases de la JCA.\r
\r
Ah\xED est\xE1n declarados todos los proveedores y algoritmos que est\xE1n disponibles, as\xED como el orden en el que las clases los buscar\xE1n.\r
:::\r
\r
Para entender como funcionan los proveedores daremos un ejemplo. Supongamos que un programa necesita una implementaci\xF3n del algoritmo MD5. Para obtenerla el programador necesita crear una instancia del mismo y lo har\xE1 escribiendo la siguiente l\xEDnea de c\xF3digo:\r
\r
\`\`\`java\r
MessageDigest m = MessageDigest.getInstance("MD5");\r
\`\`\`\r
\r
Internamente, el m\xE9todo getInstance() solicita a la clase java.security.Security que le proporcione el objeto solicitado. Como no se ha especificado proveedor la clase Security consulta a todos los proveedores disponibles, solicitando una implementaci\xF3n del algoritmo "MD5", hasta que encuentra una o se queda sin proveedores. La consulta se realiza seg\xFAn la lista de proveedores del archivo java.security, que por defecto s\xF3lo contiene la entrada:\r
\r
Security.provider.1=sun.security.provider.Sun\r
\r
## 6.1.4. Engines\r
\r
En el JDK el JCA define las siguientes clases Engine\r
\r
| Clase JCA | Funci\xF3n |\r
|---|---|\r
|java.security.MessageDigest | Calculo de resumen de mensajes (hash).|\r
|java.security.Signature| Firma de datos y verificaci\xF3n firmas.|\r
|java.security.KeyPairGenerator | Generar pares de claves (p\xFAblica y privada) para un algoritmo.|\r
|java.security.KeyFactory| Convertir claves de formato criptogr\xE1fico, especificaciones de claves y viceversa|\r
|java.security.certificate.CertificateFactory| Crear certificados de clave p\xFAblica y listas de revocaci\xF3n(CRLs).|\r
|java.security.KeyStore | Crear y gestionar un almac\xE9n de claves (keystore).|\r
|java.security.AlgorithmParameters | Gestionar los par\xE1metros de un algoritmo, incluyendo codificaci\xF3n y descodificaci\xF3n.|\r
|java.security.AlgorithmParameterGenerator | Generar un conjunto de par\xE1metros para un algoritmo.|\r
|java.security.SecureRandom | Generar n\xFAmeros aleatorios o pseudo aleatorios.|\r
\r
Para instanciar una clase motor se debe invocar el m\xE9todo est\xE1tico *getInstance()*, si se le pasa un nombre de algoritmo se intentar\xE1 obtener una implementaci\xF3n de alg\xFAn proveedor.\r
\r
### 6.1.5. Algoritmos\r
\r
Al igual que pasa con las herramientas de l\xEDnea de comandos, debemos saber qu\xE9 algoritmos est\xE1n disponibles para su uso por las aplicaciones en nuestra m\xE1quina virtual.\r
\r
El siguiente programa nos permite saber que proveedores y algoritmos tenemos instalados en nuestro sistema.\r
\r
Adem\xE1s, si lo invocamos con la opci\xF3n -l nos dir\xE1 que algoritmos implementan (leyendo las propiedades del proveedor)\r
\r
Toda la informaci\xF3n mostrada se extrae del archivo *java.security*\r
\r
\`\`\`java\r
class InfoProveedoresJCA {\r
\r
    public static void main(String[] args) {\r
        boolean listarProps = false;\r
        if (args.length > 0 && args[0].equals("-l")) {\r
            listarProps = true;\r
        }\r
        System.out.println("------------------------------------");\r
        System.out.println("Proveedores instalados en su sistema");\r
        System.out.println("------------------------------------");\r
        int i = 0;\r
        for (Provider proveedor: Security.getProviders()) {\r
            System.out.println("N\xFAm. proveedor : " + (i + 1));\r
            System.out.println("Nombre         : " + proveedor.getName());\r
            System.out.println("Versi\xF3n        : " + proveedor.getVersion());\r
            System.out.println("Informaci\xF3n    :\\n  " + proveedor.getInfo());\r
            System.out.println("Propiedades    :");\r
            if (listarProps) {\r
                Enumeration propiedades = proveedor.propertyNames();\r
                while (propiedades.hasMoreElements()) {\r
                    String clave = (String) propiedades.nextElement();\r
                    String valor = proveedor.getProperty(clave);\r
                    System.out.println("  " + clave + " = " + valor);\r
                }\r
            }\r
            System.out.println("------------------------------------");\r
        }\r
    }\r
}\r
\`\`\`\r
`]},{title:"6.3 Encriptaci\xF3n sim\xE9trica",headers:[{level:2,title:"6.3.1. Clave secreta",slug:"_6-3-1-clave-secreta",link:"#_6-3-1-clave-secreta",children:[]},{level:2,title:"6.3.2. Cipher",slug:"_6-3-2-cipher",link:"#_6-3-2-cipher",children:[{level:3,title:"Transformaciones b\xE1sicas en Java",slug:"transformaciones-basicas-en-java",link:"#transformaciones-basicas-en-java",children:[]}]},{level:2,title:"6.3.3. Clases stream para cifrado y descifrado sim\xE9trico",slug:"_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",link:"#_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",children:[]},{level:2,title:"6.3.4. Cifrado sim\xE9trico con GnuPG",slug:"_6-3-4-cifrado-simetrico-con-gnupg",link:"#_6-3-4-cifrado-simetrico-con-gnupg",children:[]}],path:"/es/unit6/symmetric-key.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.3 Encriptaci\xF3n sim\xE9trica\r
# Frontmatter para guardar im\xE1genes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.3 Encriptaci\xF3n sim\xE9trica" />\r
\r
# 6.3 Encriptaci\xF3n sim\xE9trica\r
\r
[[toc]]\r
\r
## 6.3.1. Clave secreta\r
\r
Ahora nos interesa no s\xF3lo verificar la integridad de la informaci\xF3n intercambiada, sino tambi\xE9n mantener su privacidad, es decir, que no sea "comprensible" durante la transmisi\xF3n, intercambio o almacenamiento. \r
\r
Tenemos un conjunto de algoritmos denominados de **clave sim\xE9trica** (tambi\xE9n conocidos como de clave secreta) en los que, mediante la aplicaci\xF3n de una clave conocida tanto por el emisos como por el receptor, la informaci\xF3n se **encripta o cifra** de forma que s\xF3lo pueda ser **desencriptada o descifrada** utilizando el mismo algoritmo y la misma clave.\r
\r
::: info El c\xF3digo Enigma\r
Como ejemplo de sistema sim\xE9trico est\xE1 Enigma. Este fue un sistema empleado por Alemania durante la Segunda Guerra Mundial, en el que las claves se distribu\xEDan a diario en forma de libros de c\xF3digos. \r
\r
Cada d\xEDa, un operador de radio, receptor o transmisor, consultaba su copia del libro de c\xF3digos para encontrar la clave del d\xEDa. Todo el tr\xE1fico enviado por ondas de radio durante aquel d\xEDa era cifrado y descifrado usando las claves del d\xEDa.\r
\r
Inglaterra us\xF3 m\xE1quinas para descifrar las claves durante aquella guerra y aunque el citado sistema alem\xE1n, Enigma, estaba provisto de un amplio abanico de claves, los ingleses dise\xF1aron m\xE1quinas de c\xF3mputo especializado, los Bombes, para comprobar las claves de modo mec\xE1nico hasta que la clave del d\xEDa era encontrada. \r
\r
Esto significaba que algunas veces encontraban la clave del d\xEDa pocas horas despu\xE9s de que \xE9sta fuera puesta en uso, pero tambi\xE9n que otros d\xEDas no pod\xEDan encontrar la clave correcta. \r
\r
Los Bombes no fueron m\xE1quinas de c\xF3mputo general, sino las precursoras de los ordenadores (computadoras) actuales.\r
:::\r
\r
Entre los algoritmos de cifrado sim\xE9trico m\xE1s utilizados se encuentran\r
\r
- DES\r
- 3DES o Tiple DES\r
- RC5\r
- AES\r
- Blowfish\r
- IDEA\r
\r
![cifrado sim\xE9trico](../../media/unit6/symmetric-encryption-primitive.png)\r
\r
## 6.3.2. Cipher\r
\r
Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
1. Se crea un objeto de la clase *SecretKey* a partir de un KeyGenerator obtenido con el m\xE9todo est\xE1tico *getInstance()*, especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.\r
2. As\xED podemos utilizar una clave prefijada o incluso una clave aleatoria de tipo OTP (One Time Password) ya que cada vez que ejecutemos el programa la clave ser\xE1 diferente.\r
3. Se crea un objeto de tipo Cipher indicando qu\xE9 algoritmo vamos a usar. Y despu\xE9s, con el m\xE9todo *init()* se indica qu\xE9 vamos a hacer (cifrar/descifrar) y con qu\xE9 clave.\r
4. Se a\xF1aden datos con el m\xE9todo *update()*. Se puede a\xF1adir un byte o un array de bytes. Este m\xE9todo se puede invocar varias veces para ir a\xF1adiendo nuevos datos.\r
5. Se obtiene el valor cifrado con el m\xE9todo *doFinal()*.\r
6. Si se quisiera descifrar, s\xF3lo hay que volver a invocar al m\xE9todo *init()* indicando en este caso que queremos descifrar.\r
\r
A continuaci\xF3n podemos ver un ejemplo\r
\r
\`\`\`java\r
public class SecretKeyEncrypt {\r
\r
    public static void main(String[] args) {\r
        SecretKey claveSecreta = null;\r
        \r
        try {\r
\r
            //Generamos clave secreta\r
            // Podemos crear una nueva clave\r
            claveSecreta = getNewKey();\r
            // O bien usar una clave guardada en alg\xFAn almac\xE9n, fichero, etc.\r
            claveSecreta = getKeyFromData();\r
\r
            System.out.println("Clave usada: " + claveSecreta.getFormat());\r
            //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
            Cipher c = Cipher.getInstance("DESede"); // AES/ECB/PKCS5Padding\r
            // Configuramos el modo de CIFRADO\r
            c.init(Cipher.ENCRYPT_MODE, claveSecreta);\r
\r
            // Aqu\xED leemos la informaci\xF3n que queremos cifrar\r
            // Puede ser una cadena o leerla de un archivo\r
            byte[] textoPlano = "Texto que queremos cifrar para la prueba".getBytes();\r
            \r
            // Si queremos ir cifrando poco a poco, vamos haciendo llamadas\r
            // al m\xE9todo update\r
            // c.update(textoPlano);\r
            // Se realiza el proceso final de cifrado de la informaci\xF3n\r
            byte[] textoCifrado = c.doFinal(textoPlano);\r
            System.out.println("Texto cifrado con clave secreta (raw):\\n" + new String(textoCifrado));\r
            System.out.println("Texto cifrado con clave secreta (hex):\\n" + toHexadecimal(textoCifrado));\r
                        \r
            \r
            // El proceso de descifrado es equivalente\r
            // Cambiamos el modo de ENCRYPT a DECRYPT\r
            // Usamos la misma clave\r
            // Pasamos el texto cifrado para obtener el original\r
            c.init(Cipher.DECRYPT_MODE, claveSecreta);\r
            byte[] textoOriginal = c.doFinal(textoCifrado);\r
            //Leemos bloques de bytes del fichero y lo vamos escribiendo ya cifrado en el fichero de salida\r
            System.out.println("Texto descifrado:\\n" + new String(textoOriginal));\r
            \r
        } catch (Exception e) {\r
            e.printStackTrace();\r
        }\r
    }\r
\r
    static SecretKey getNewKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
    \r
            KeyGenerator kg = KeyGenerator.getInstance("DESede");\r
            kg.init(112);\r
            SecretKey clave = kg.generateKey();\r
            \r
            return clave;\r
    }\r
\r
    static SecretKey getNewRandomKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // Clave obtenida usando un generador de n\xFAmero aleatorios seguro\r
        KeyGenerator genClaves = KeyGenerator.getInstance("DESede");\r
        // Utilizamos un algoritmo de generaci\xF3n de aleatorios        \r
        SecureRandom srand = SecureRandom.getInstance("SHA1PRNG");\r
        genClaves.init(srand);\r
        \r
        SecretKey clave = genClaves.generateKey();\r
        System.out.println("Formato de clave: " + clave.getFormat());\r
        \r
        /*\r
        SecretKeyFactory keySpecFactory = SecretKeyFactory.getInstance("DESede");\r
        DESedeKeySpec keySpec = (DESedeKeySpec) keySpecFactory.getKeySpec(clave, DESedeKeySpec.class);\r
        byte[] valorClave = keySpec.getKey();\r
        */\r
        \r
        return clave;\r
    }\r
    \r
    static SecretKey getKeyFromData() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        SecretKeySpec keySpec = new SecretKeySpec (valorClave, "DESede");\r
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DESede");\r
        SecretKey clave = keyFactory.generateSecret(keySpec);\r
        \r
        return clave;\r
    }\r
\r
    static Key getKeyFromData2() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        Key clave = new SecretKeySpec(valorClave, "AES");\r
\r
        return clave;\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
    \r
}\r
\`\`\`\r
\r
y esta ser\xEDa la salida proporcionada\r
\r
\`\`\`sh\r
Texto cifrado con clave secreta:\r
D0A61CD14B5844AD98B2C7BA795B327ACA0795B658C6F93EC6E1586A246BE71AC180B574207E8C4FFEB959B7D4642FCB\r
Texto descifrado:\r
Texto que queremos cifrar para la prueba\r
\`\`\`\r
\r
Hay que tener en cuenta que en el ejemplo la clave se est\xE1 usando primero para cifrar y luego para descifrar. Si esto lo hacemos en programas separados, los programas que quieran comunicarse deber\xE1n tener acceso a la clave.\r
\r
Lo que se suele hacer es almacenar la clave en un archivo y, cuando se necesita para cifrar o descifrar, se lee con un m\xE9todo similar al m\xE9todo *getKeyFromData()* del ejemplo anterior.\r
\r
### Transformaciones b\xE1sicas en Java\r
\r
En la siguiente tabla tenemos los algoritmos, modos y tipos de relleno, junto con la longitud de clave empleada, de los algoritmos de cifrado sim\xE9trico m'as comunes.\r
\r
|Transformaci\xF3n (algoritmo/modo/relleno)|Key Size|\r
|---|---|\r
|AES/CBC/NoPadding|128|\r
|AES/CBC/PKCS5Padding|128|\r
|AES/ECB/NoPadding|128|\r
|AES/ECB/PKCS5Padding|128|\r
|DES/CBC/NoPadding|56|\r
|DES/CBC/PKCS5Padding|56|\r
|DES/ECB/NoPadding|56|\r
|DES/ECB/PKCS5Padding|56|\r
|DESede/CBC/NoPadding|168|\r
|DESede/CBC/PKCS5Padding|168|\r
|DESede/ECB/NoPadding|168|\r
|DESede/ECB/PKCS5Padding|168|\r
|RSA/ECB/PKCS1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-1AndMGF1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-256AndMGF1Padding|1024, 2048|\r
\r
\r
## 6.3.3. Clases stream para cifrado y descifrado sim\xE9trico\r
\r
Existen dos clases stream que permiten cifrar y descifrar directamente. Pertenecen al paquete *java.crypto* pero por lo dem\xE1s funcionan exactamente igual que las clases Stream del paquete *java.io*, de las que adem\xE1s son clases descendientes y y tienen constructores que permiten crear streams encriptados sobre un InputStream y un OutputStream.\r
\r
| Clase |Ejemplo |\r
| --- | --- |\r
| CipherInputStream | CipherInputStream (InputStream is, Cipher c) |\r
| CipherOutputStream | CipherOutputStream (OutputStream os, Cipher c) |\r
\r
Por lo tanto, cuando tenemos que leer o escribir informaci\xF3n, podemos a\xF1adir un envoltorio m\xE1s al wrapper que utilizamos habitualmente y esto nos permite que tanto las lecturas como las escrituras se hagan cifradas, usando el algoritmo y la clave definidos para el objeto Cipher.\r
\r
El uso m\xE1s com\xFAn es para leer o escribir en archivos en los que, de igual forma, cambiando el wrapper nos permite leer o escribir la informaci\xF3n de forma cifrada/descifrada.\r
\r
::: warning Tama\xF1o de bloque\r
Muchos de los algoritmos de cifrado sim\xE9trico trabajan con bloques de datos, por lo que no debemos intentar cifrar o descifrar m\xE1s informaci\xF3n de la que permite el tama\xF1o de bloque.\r
\r
La clase Cipher tiene un m\xE9todo **getBlockSize()** que nos devuelve el tama\xF1o de bloque que permite el algoritmo configurado en su m\xE9todo **init()**.\r
:::\r
\r
Veamos un ejemplo de c\xF3mo quedar\xEDa el wrapper\r
\r
\`\`\`java\r
public class StreamCrypto {\r
\r
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException {\r
        File file;\r
        String filePath = "a.txt";\r
\r
        file = new File(filePath);\r
\r
        //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
        Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding"); //DESede\r
        // Configuramos el modo de CIFRADO\r
        byte[] valorClave = "12345678123456781234567812345678".getBytes();\r
\r
        // CIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.ENCRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (OutputStream outputStream = new BufferedOutputStream(\r
                new CipherOutputStream(new FileOutputStream(file), c))) {\r
            for (int i = 0; i < 10; i++) {\r
                outputStream.write(new String("Hello World\\n").getBytes());\r
            }\r
\r
        }\r
\r
        // DESCIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.DECRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (InputStream inputStream = new BufferedInputStream(\r
                new CipherInputStream(new FileInputStream(file), c))) {\r
\r
            System.out.println("Contenido del fichero (descifrado):\\n" + new String(inputStream.readAllBytes()));\r
        }\r
\r
    }\r
}\r
\`\`\`\r
\r
## 6.3.4. Cifrado sim\xE9trico con GnuPG\r
\r
Con la suite GnuPG tambi\xE9n podemos cifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la informaci\xF3n de los algoritmos disponibles para cada tipo de servicio. En concreto, de res\xFAmenes, en mi versi\xF3n instalada:\r
\r
Cifrado: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,\r
         CAMELLIA128, CAMELLIA192, CAMELLIA256\r
:::\r
\r
Para cifrar y descifrar un archivo, ejecutamos los siguientes comandos\r
\r
\`\`\`sh\r
gpg --symmetric --cipher-algo 3DES filename.ext\r
gpg --decrypt filename.ext.gpg\r
\`\`\`\r
\r
Vemos que para el cifrado nos solicita una clave y que con el par\xE1metro *--cipher-algo* indicamos qu\xE9 algoritmo de encriptaci\xF3n queremos utilizar.\r
\r
El cifrado genera un archivo filename.ext.gpg.\r
\r
Para el descifrado, no hace falta indicar el algoritmo, aunque se puede volver a usar el par\xE1metro *--cipher-algo* y la clave se queda en una cache de GnuPG durante un tiempo, por lo que no siempre la solicita.\r
`]},{title:"",headers:[],path:"/404.html",pathLocale:"/",extraFields:[""]}],Wi=qe(pg),hg=()=>Wi;import.meta.webpackHot&&(__VUE_HMR_RUNTIME__.updateSearchIndex=e=>{Wi.value=e});const gg=({searchIndex:e,routeLocale:n,query:r,maxSuggestions:a})=>{const o=J(()=>e.value.filter(t=>t.pathLocale===n.value));return J(()=>{const t=r.value.trim().toLowerCase();if(!t)return[];const s=[],i=(l,c)=>{ls(t,[c.title])&&s.push({link:`${l.path}#${c.slug}`,title:l.title,header:c.title});for(const d of c.children){if(s.length>=a.value)return;i(l,d)}};for(const l of o.value){if(s.length>=a.value)break;if(ls(t,[l.title,...l.extraFields])){s.push({link:l.path,title:l.title});continue}for(const c of l.headers){if(s.length>=a.value)break;i(l,c)}}return s})},fg=e=>{const n=qe(0);return{focusIndex:n,focusNext:()=>{n.value<e.value.length-1?n.value+=1:n.value=0},focusPrev:()=>{n.value>0?n.value-=1:n.value=e.value.length-1}}},vg=ge({name:"SearchBox",props:{locales:{type:Object,required:!1,default:()=>({})},hotKeys:{type:Array,required:!1,default:()=>[]},maxSuggestions:{type:Number,required:!1,default:5}},setup(e){const{locales:n,hotKeys:r,maxSuggestions:a}=qa(e),o=ar(),t=wr(),s=hg(),i=qe(null),l=qe(!1),c=qe(""),d=J(()=>{var C;return(C=n.value[t.value])!=null?C:{}}),m=gg({searchIndex:s,routeLocale:t,query:c,maxSuggestions:a}),{focusIndex:u,focusNext:p,focusPrev:b}=fg(m);mg({input:i,hotKeys:r});const q=J(()=>l.value&&!!m.value.length),w=()=>{!q.value||b()},f=()=>{!q.value||p()},S=C=>{if(!q.value)return;const R=m.value[C];!R||o.push(R.link).then(()=>{c.value="",u.value=0})};return()=>pe("form",{class:"search-box",role:"search"},[pe("input",{ref:i,type:"search",placeholder:d.value.placeholder,autocomplete:"off",spellcheck:!1,value:c.value,onFocus:()=>l.value=!0,onBlur:()=>l.value=!1,onInput:C=>c.value=C.target.value,onKeydown:C=>{switch(C.key){case"ArrowUp":{w();break}case"ArrowDown":{f();break}case"Enter":{C.preventDefault(),S(u.value);break}}}}),q.value&&pe("ul",{class:"suggestions",onMouseleave:()=>u.value=-1},m.value.map(({link:C,title:R,header:U},X)=>pe("li",{class:["suggestion",{focus:u.value===X}],onMouseenter:()=>u.value=X,onMousedown:()=>S(X)},pe("a",{href:C,onClick:x=>x.preventDefault()},[pe("span",{class:"page-title"},R),U&&pe("span",{class:"page-header"},`> ${U}`)]))))])}});const bg={"/en/":{placeholder:"Search"},"/es/":{placeholder:"Buscar"}},yg=["s","/"],Sg=5,wg=kn({enhance({app:e}){e.component("SearchBox",n=>pe(vg,{locales:bg,hotKeys:yg,maxSuggestions:Sg,...n}))}});const Pg={},Eg=e=>{const n=wr();return J(()=>e[n.value])};class qg{constructor(){this.messageElements={};const n="message-container",r=document.getElementById(n);r?this.containerElement=r:(this.containerElement=document.createElement("div"),this.containerElement.id=n,document.body.appendChild(this.containerElement))}pop(n,r=2e3){const a=document.createElement("div"),o=Date.now();return a.className="message move-in",a.innerHTML=n,this.containerElement.appendChild(a),this.messageElements[o]=a,r>0&&setTimeout(()=>{this.close(o)},r),o}close(n){if(n){const r=this.messageElements[n];r.className=r.className.replace("move-in",""),r.className+="move-out",r.addEventListener("animationend",()=>{r.remove(),delete this.messageElements[n]})}else Object.keys(this.messageElements).forEach(r=>this.close(Number(r)))}destory(){document.body.removeChild(this.containerElement)}}var Ga,yn=function(){var e=1e3,n=6e4,r=36e5,a="millisecond",o="second",t="minute",s="hour",i="day",l="week",c="month",d="quarter",m="year",u="date",p="Invalid Date",b=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,q=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,w={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},f=function(D,y,P){var j=String(D);return!j||j.length>=y?D:""+Array(y+1-j.length).join(P)+D},S={s:f,z:function(D){var y=-D.utcOffset(),P=Math.abs(y),j=Math.floor(P/60),_=P%60;return(y<=0?"+":"-")+f(j,2,"0")+":"+f(_,2,"0")},m:function D(y,P){if(y.date()<P.date())return-D(P,y);var j=12*(P.year()-y.year())+(P.month()-y.month()),_=y.clone().add(j,c),I=P-_<0,N=y.clone().add(j+(I?-1:1),c);return+(-(j+(P-_)/(I?_-N:N-_))||0)},a:function(D){return D<0?Math.ceil(D)||0:Math.floor(D)},p:function(D){return{M:c,y:m,w:l,d:i,D:u,h:s,m:t,s:o,ms:a,Q:d}[D]||String(D||"").toLowerCase().replace(/s$/,"")},u:function(D){return D===void 0}},C="en",R={};R[C]=w;var U=function(D){return D instanceof Y},X=function D(y,P,j){var _;if(!y)return C;if(typeof y=="string"){var I=y.toLowerCase();R[I]&&(_=I),P&&(R[I]=P,_=I);var N=y.split("-");if(!_&&N.length>1)return D(N[0])}else{var G=y.name;R[G]=y,_=G}return!j&&_&&(C=_),_||!j&&C},x=function(D,y){if(U(D))return D.clone();var P=typeof y=="object"?y:{};return P.date=D,P.args=arguments,new Y(P)},g=S;g.l=X,g.i=U,g.w=function(D,y){return x(D,{locale:y.$L,utc:y.$u,x:y.$x,$offset:y.$offset})};var Y=function(){function D(P){this.$L=X(P.locale,null,!0),this.parse(P)}var y=D.prototype;return y.parse=function(P){this.$d=function(j){var _=j.date,I=j.utc;if(_===null)return new Date(NaN);if(g.u(_))return new Date;if(_ instanceof Date)return new Date(_);if(typeof _=="string"&&!/Z$/i.test(_)){var N=_.match(b);if(N){var G=N[2]-1||0,ce=(N[7]||"0").substring(0,3);return I?new Date(Date.UTC(N[1],G,N[3]||1,N[4]||0,N[5]||0,N[6]||0,ce)):new Date(N[1],G,N[3]||1,N[4]||0,N[5]||0,N[6]||0,ce)}}return new Date(_)}(P),this.$x=P.x||{},this.init()},y.init=function(){var P=this.$d;this.$y=P.getFullYear(),this.$M=P.getMonth(),this.$D=P.getDate(),this.$W=P.getDay(),this.$H=P.getHours(),this.$m=P.getMinutes(),this.$s=P.getSeconds(),this.$ms=P.getMilliseconds()},y.$utils=function(){return g},y.isValid=function(){return this.$d.toString()!==p},y.isSame=function(P,j){var _=x(P);return this.startOf(j)<=_&&_<=this.endOf(j)},y.isAfter=function(P,j){return x(P)<this.startOf(j)},y.isBefore=function(P,j){return this.endOf(j)<x(P)},y.$g=function(P,j,_){return g.u(P)?this[j]:this.set(_,P)},y.unix=function(){return Math.floor(this.valueOf()/1e3)},y.valueOf=function(){return this.$d.getTime()},y.startOf=function(P,j){var _=this,I=!!g.u(j)||j,N=g.p(P),G=function(Q,z){var K=g.w(_.$u?Date.UTC(_.$y,z,Q):new Date(_.$y,z,Q),_);return I?K:K.endOf(i)},ce=function(Q,z){return g.w(_.toDate()[Q].apply(_.toDate("s"),(I?[0,0,0,0]:[23,59,59,999]).slice(z)),_)},ue=this.$W,we=this.$M,De=this.$D,Te="set"+(this.$u?"UTC":"");switch(N){case m:return I?G(1,0):G(31,11);case c:return I?G(1,we):G(0,we+1);case l:var $e=this.$locale().weekStart||0,A=(ue<$e?ue+7:ue)-$e;return G(I?De-A:De+(6-A),we);case i:case u:return ce(Te+"Hours",0);case s:return ce(Te+"Minutes",1);case t:return ce(Te+"Seconds",2);case o:return ce(Te+"Milliseconds",3);default:return this.clone()}},y.endOf=function(P){return this.startOf(P,!1)},y.$set=function(P,j){var _,I=g.p(P),N="set"+(this.$u?"UTC":""),G=(_={},_[i]=N+"Date",_[u]=N+"Date",_[c]=N+"Month",_[m]=N+"FullYear",_[s]=N+"Hours",_[t]=N+"Minutes",_[o]=N+"Seconds",_[a]=N+"Milliseconds",_)[I],ce=I===i?this.$D+(j-this.$W):j;if(I===c||I===m){var ue=this.clone().set(u,1);ue.$d[G](ce),ue.init(),this.$d=ue.set(u,Math.min(this.$D,ue.daysInMonth())).$d}else G&&this.$d[G](ce);return this.init(),this},y.set=function(P,j){return this.clone().$set(P,j)},y.get=function(P){return this[g.p(P)]()},y.add=function(P,j){var _,I=this;P=Number(P);var N=g.p(j),G=function(we){var De=x(I);return g.w(De.date(De.date()+Math.round(we*P)),I)};if(N===c)return this.set(c,this.$M+P);if(N===m)return this.set(m,this.$y+P);if(N===i)return G(1);if(N===l)return G(7);var ce=(_={},_[t]=n,_[s]=r,_[o]=e,_)[N]||1,ue=this.$d.getTime()+P*ce;return g.w(ue,this)},y.subtract=function(P,j){return this.add(-1*P,j)},y.format=function(P){var j=this,_=this.$locale();if(!this.isValid())return _.invalidDate||p;var I=P||"YYYY-MM-DDTHH:mm:ssZ",N=g.z(this),G=this.$H,ce=this.$m,ue=this.$M,we=_.weekdays,De=_.months,Te=function(z,K,me,fe){return z&&(z[K]||z(j,I))||me[K].slice(0,fe)},$e=function(z){return g.s(G%12||12,z,"0")},A=_.meridiem||function(z,K,me){var fe=z<12?"AM":"PM";return me?fe.toLowerCase():fe},Q={YY:String(this.$y).slice(-2),YYYY:this.$y,M:ue+1,MM:g.s(ue+1,2,"0"),MMM:Te(_.monthsShort,ue,De,3),MMMM:Te(De,ue),D:this.$D,DD:g.s(this.$D,2,"0"),d:String(this.$W),dd:Te(_.weekdaysMin,this.$W,we,2),ddd:Te(_.weekdaysShort,this.$W,we,3),dddd:we[this.$W],H:String(G),HH:g.s(G,2,"0"),h:$e(1),hh:$e(2),a:A(G,ce,!0),A:A(G,ce,!1),m:String(ce),mm:g.s(ce,2,"0"),s:String(this.$s),ss:g.s(this.$s,2,"0"),SSS:g.s(this.$ms,3,"0"),Z:N};return I.replace(q,function(z,K){return K||Q[z]||N.replace(":","")})},y.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},y.diff=function(P,j,_){var I,N=g.p(j),G=x(P),ce=(G.utcOffset()-this.utcOffset())*n,ue=this-G,we=g.m(this,G);return we=(I={},I[m]=we/12,I[c]=we,I[d]=we/3,I[l]=(ue-ce)/6048e5,I[i]=(ue-ce)/864e5,I[s]=ue/r,I[t]=ue/n,I[o]=ue/e,I)[N]||ue,_?we:g.a(we)},y.daysInMonth=function(){return this.endOf(c).$D},y.$locale=function(){return R[this.$L]},y.locale=function(P,j){if(!P)return this.$L;var _=this.clone(),I=X(P,j,!0);return I&&(_.$L=I),_},y.clone=function(){return g.w(this.$d,this)},y.toDate=function(){return new Date(this.valueOf())},y.toJSON=function(){return this.isValid()?this.toISOString():null},y.toISOString=function(){return this.$d.toISOString()},y.toString=function(){return this.$d.toUTCString()},D}(),W=Y.prototype;return x.prototype=W,[["$ms",a],["$s",o],["$m",t],["$H",s],["$W",i],["$M",c],["$y",m],["$D",u]].forEach(function(D){W[D[1]]=function(y){return this.$g(y,D[0],D[1])}}),x.extend=function(D,y){return D.$i||(D(y,Y,x),D.$i=!0),x},x.locale=X,x.isDayjs=U,x.unix=function(D){return x(1e3*D)},x.en=R[C],x.Ls=R,x.p={},x}(),Cg=(Ga={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},function(e,n,r){var a=n.prototype,o=a.format;r.en.formats=Ga,a.format=function(t){t===void 0&&(t="YYYY-MM-DDTHH:mm:ssZ");var s=this.$locale().formats,i=function(l,c){return l.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,function(d,m,u){var p=u&&u.toUpperCase();return m||c[u]||Ga[u]||c[p].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,function(b,q,w){return q||w.slice(1)})})}(t,s===void 0?{}:s);return o.call(this,i)}}),Vi=function(e,n,r){var a=n.prototype,o=function(c){var d,m=c.date,u=c.utc,p={};if(!((d=m)instanceof Date)&&!(d instanceof Array)&&d instanceof Object){if(!Object.keys(m).length)return new Date;var b=u?r.utc():r();Object.keys(m).forEach(function(X){var x,g;p[x=X,g=a.$utils().p(x),g==="date"?"day":g]=m[X]});var q=p.day||(p.year||p.month>=0?1:b.date()),w=p.year||b.year(),f=p.month>=0?p.month:p.year||p.day?0:b.month(),S=p.hour||0,C=p.minute||0,R=p.second||0,U=p.millisecond||0;return u?new Date(Date.UTC(w,f,q,S,C,R,U)):new Date(w,f,q,S,C,R,U)}return m},t=a.parse;a.parse=function(c){c.date=o.bind(this)(c),t.bind(this)(c)};var s=a.set,i=a.add,l=function(c,d,m,u){if(u===void 0&&(u=1),d instanceof Object){var p=Object.keys(d),b=this;return p.forEach(function(q){b=c.bind(b)(d[q]*u,q)}),b}return c.bind(this)(d*u,m)};a.set=function(c,d){return d=d===void 0?c:d,l.bind(this)(function(m,u){return s.bind(this)(u,m)},d,c)},a.add=function(c,d){return l.bind(this)(i,c,d)},a.subtract=function(c,d){return l.bind(this)(i,c,d,-1)}},Ji=function(){var e={year:0,month:1,day:2,hour:3,minute:4,second:5},n={};return function(r,a,o){var t,s=function(d,m,u){u===void 0&&(u={});var p=new Date(d),b=function(q,w){w===void 0&&(w={});var f=w.timeZoneName||"short",S=q+"|"+f,C=n[S];return C||(C=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:q,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",timeZoneName:f}),n[S]=C),C}(m,u);return b.formatToParts(p)},i=function(d,m){for(var u=s(d,m),p=[],b=0;b<u.length;b+=1){var q=u[b],w=q.type,f=q.value,S=e[w];S>=0&&(p[S]=parseInt(f,10))}var C=p[3],R=C===24?0:C,U=p[0]+"-"+p[1]+"-"+p[2]+" "+R+":"+p[4]+":"+p[5]+":000",X=+d;return(o.utc(U).valueOf()-(X-=X%1e3))/6e4},l=a.prototype;l.tz=function(d,m){d===void 0&&(d=t);var u=this.utcOffset(),p=this.toDate(),b=p.toLocaleString("en-US",{timeZone:d}),q=Math.round((p-new Date(b))/1e3/60),w=o(b).$set("millisecond",this.$ms).utcOffset(15*-Math.round(p.getTimezoneOffset()/15)-q,!0);if(m){var f=w.utcOffset();w=w.add(u-f,"minute")}return w.$x.$timezone=d,w},l.offsetName=function(d){var m=this.$x.$timezone||o.tz.guess(),u=s(this.valueOf(),m,{timeZoneName:d}).find(function(p){return p.type.toLowerCase()==="timezonename"});return u&&u.value};var c=l.startOf;l.startOf=function(d,m){if(!this.$x||!this.$x.$timezone)return c.call(this,d,m);var u=o(this.format("YYYY-MM-DD HH:mm:ss:SSS"));return c.call(u,d,m).tz(this.$x.$timezone,!0)},o.tz=function(d,m,u){var p=u&&m,b=u||m||t,q=i(+o(),b);if(typeof d!="string")return o(d).tz(b);var w=function(R,U,X){var x=R-60*U*1e3,g=i(x,X);if(U===g)return[x,U];var Y=i(x-=60*(g-U)*1e3,X);return g===Y?[x,g]:[R-60*Math.min(g,Y)*1e3,Math.max(g,Y)]}(o.utc(d,p).valueOf(),q,b),f=w[0],S=w[1],C=o(f).utcOffset(S);return C.$x.$timezone=b,C},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(d){t=d}}}(),Gi=function(){var e="minute",n=/[+-]\d\d(?::?\d\d)?/g,r=/([+-]|\d\d)/g;return function(a,o,t){var s=o.prototype;t.utc=function(p){return new o({date:p,utc:!0,args:arguments})},s.utc=function(p){var b=t(this.toDate(),{locale:this.$L,utc:!0});return p?b.add(this.utcOffset(),e):b},s.local=function(){return t(this.toDate(),{locale:this.$L,utc:!1})};var i=s.parse;s.parse=function(p){p.utc&&(this.$u=!0),this.$utils().u(p.$offset)||(this.$offset=p.$offset),i.call(this,p)};var l=s.init;s.init=function(){if(this.$u){var p=this.$d;this.$y=p.getUTCFullYear(),this.$M=p.getUTCMonth(),this.$D=p.getUTCDate(),this.$W=p.getUTCDay(),this.$H=p.getUTCHours(),this.$m=p.getUTCMinutes(),this.$s=p.getUTCSeconds(),this.$ms=p.getUTCMilliseconds()}else l.call(this)};var c=s.utcOffset;s.utcOffset=function(p,b){var q=this.$utils().u;if(q(p))return this.$u?0:q(this.$offset)?c.call(this):this.$offset;if(typeof p=="string"&&(p=function(C){C===void 0&&(C="");var R=C.match(n);if(!R)return null;var U=(""+R[0]).match(r)||["-",0,0],X=U[0],x=60*+U[1]+ +U[2];return x===0?0:X==="+"?x:-x}(p),p===null))return this;var w=Math.abs(p)<=16?60*p:p,f=this;if(b)return f.$offset=w,f.$u=p===0,f;if(p!==0){var S=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(f=this.local().add(w+S,e)).$offset=w,f.$x.$localOffset=S}else f=this.utc();return f};var d=s.format;s.format=function(p){var b=p||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return d.call(this,b)},s.valueOf=function(){var p=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*p},s.isUTC=function(){return!!this.$u},s.toISOString=function(){return this.toDate().toISOString()},s.toString=function(){return this.toDate().toUTCString()};var m=s.toDate;s.toDate=function(p){return p==="s"&&this.$offset?t(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():m.call(this)};var u=s.diff;s.diff=function(p,b,q){if(p&&this.$u===p.$u)return u.call(this,p,b,q);var w=this.local(),f=t(p).local();return u.call(w,f,b,q)}}}();yn.extend(Cg),yn.extend(Vi),yn.extend(Gi),yn.extend(Ji);const kg={name:"zh-cn",weekdays:"\u661F\u671F\u65E5_\u661F\u671F\u4E00_\u661F\u671F\u4E8C_\u661F\u671F\u4E09_\u661F\u671F\u56DB_\u661F\u671F\u4E94_\u661F\u671F\u516D".split("_"),weekdaysShort:"\u5468\u65E5_\u5468\u4E00_\u5468\u4E8C_\u5468\u4E09_\u5468\u56DB_\u5468\u4E94_\u5468\u516D".split("_"),weekdaysMin:"\u65E5_\u4E00_\u4E8C_\u4E09_\u56DB_\u4E94_\u516D".split("_"),months:"\u4E00\u6708_\u4E8C\u6708_\u4E09\u6708_\u56DB\u6708_\u4E94\u6708_\u516D\u6708_\u4E03\u6708_\u516B\u6708_\u4E5D\u6708_\u5341\u6708_\u5341\u4E00\u6708_\u5341\u4E8C\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),ordinal:(e,n)=>n==="W"?`${e}\u5468`:`${e}\u65E5`,weekStart:1,yearStart:4,formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5E74M\u6708D\u65E5",LLL:"YYYY\u5E74M\u6708D\u65E5Ah\u70B9mm\u5206",LLLL:"YYYY\u5E74M\u6708D\u65E5ddddAh\u70B9mm\u5206",l:"YYYY/M/D",ll:"YYYY\u5E74M\u6708D\u65E5",lll:"YYYY\u5E74M\u6708D\u65E5 HH:mm",llll:"YYYY\u5E74M\u6708D\u65E5dddd HH:mm"},relativeTime:{future:"%s\u5185",past:"%s\u524D",s:"\u51E0\u79D2",m:"1 \u5206\u949F",mm:"%d \u5206\u949F",h:"1 \u5C0F\u65F6",hh:"%d \u5C0F\u65F6",d:"1 \u5929",dd:"%d \u5929",M:"1 \u4E2A\u6708",MM:"%d \u4E2A\u6708",y:"1 \u5E74",yy:"%d \u5E74"},meridiem:(e,n)=>{const r=100*e+n;return r<600?"\u51CC\u6668":r<900?"\u65E9\u4E0A":r<1100?"\u4E0A\u5348":r<1300?"\u4E2D\u5348":r<1800?"\u4E0B\u5348":"\u665A\u4E0A"}},jg={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")};yn.locale("zh",kg),yn.locale("en",jg),yn.extend(Vi),yn.extend(Gi),yn.extend(Ji);const Vn={duration:3e3,delay:250},cs=()=>!!navigator&&/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/iu.test(navigator.userAgent),xg=()=>{const e=jn(),n=Eg({"/en/":{copy:"Copied successfully",hint:"Copy code"},"/es/":{copy:"Copiado con \xE9xito",hint:"Copiar c\xF3digo"},"/":{copy:"Copied successfully",hint:"Copy code"}});let r;const a=t=>{if(!t.hasAttribute("copy-code-registered")){const s=document.createElement("button");Vn.pure?(s.className="copy-code-pure-button",s.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" class="icon-copy-code"><path d="M704 896v80c0 26.51-21.49 48-48 48H112c-26.51 0-48-21.49-48-48V240c0-26.51 21.49-48 48-48h144v592c0 61.758 50.242 112 112 112h336zm0-688V0H368c-26.51 0-48 21.49-48 48v736c0 26.51 21.49 48 48 48h544c26.51 0 48-21.49 48-48V256H752c-26.4 0-48-21.6-48-48zm241.942-62.058L814.058 14.058A48 48 0 0 0 780.118 0H768v192h192v-12.118a48 48 0 0 0-14.058-33.94z"/></svg>'):(s.className="copy-code-button",s.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" class="icon-copy-code"><path fill="currentColor" d="M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 00-6-6H102a6 6 0 00-6 6v20a6 6 0 006 6h180a6 6 0 006-6z" /></svg>'),s.addEventListener("click",()=>{(i=>{const l=document.getSelection(),c=!!(l&&l.rangeCount>0)&&l.getRangeAt(0),d=document.createElement("textarea");d.value=i,d.setAttribute("readonly",""),d.style.position="absolute",d.style.top="-9999px",document.body.appendChild(d),d.select(),document.execCommand("copy"),Vn.pure||r.pop(`<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="#06a35a"><path d="M822.812 824.618c-83.076 81.992-188.546 124.614-316.05 127.865-122.085-3.251-223.943-45.873-305.935-127.865S76.213 640.406 72.962 518.682c3.251-127.503 45.873-232.973 127.865-316.05 81.992-83.075 184.211-126.058 305.936-129.309 127.503 3.251 232.973 46.234 316.049 129.31 83.076 83.076 126.059 188.546 129.31 316.05-2.89 121.723-46.234 223.943-129.31 305.935zM432.717 684.111c3.973 3.974 8.307 5.78 13.364 6.14 5.057.362 9.753-1.444 13.365-5.417l292.57-287.515c3.974-3.973 5.78-8.307 5.78-13.364s-1.806-9.753-5.78-13.365l1.807 1.806c-3.973-3.973-8.669-5.779-14.087-6.14-5.418-.361-10.475 1.445-14.809 5.418L460.529 592.006c-3.973 3.25-8.669 4.695-14.448 4.695-5.78 0-10.836-1.445-15.531-3.973l-94.273-72.962c-4.335-3.251-9.392-4.335-14.448-3.973s-9.392 3.25-12.642 7.585l-2.89 3.973c-3.25 4.334-4.334 9.391-3.973 14.81.722 5.417 2.528 10.113 5.779 14.086L432.717 684.11z"/></svg><span>${n.value.copy} \u{1F389}</span>`,Vn.duration),document.body.removeChild(d),c&&l&&(l.removeAllRanges(),l.addRange(c))})(t.innerText)}),s.setAttribute("aria-label",n.value.hint),s.setAttribute("data-balloon-pos","left"),t.parentElement&&t.parentElement.insertBefore(s,t),t.setAttribute("copy-code-registered","")}},o=()=>{const t=Vn.selector||'.theme-default-content div[class*="language-"] pre';setTimeout(()=>{typeof t=="string"?document.querySelectorAll(t).forEach(a):Array.isArray(t)&&t.forEach(s=>{document.querySelectorAll(s).forEach(a)})},Vn.delay)};Ke(()=>{r=new qg,cs()&&!Vn.showInMobile||o()}),dn(()=>e.path,()=>{cs()&&!Vn.showInMobile||o()})};var Ag=kn({setup:()=>{xg()}});const ta=[Hu,Ju,Yu,em,tm,$h,Yh,lg,wg,Pg,Ag];var Ki=qe(al),$i=qo({key:"",path:"",title:"",lang:"",frontmatter:{},excerpt:"",headers:[]}),Sn=qe($i),On=()=>Sn;import.meta.webpackHot&&(__VUE_HMR_RUNTIME__.updatePageData=e=>{Ki.value[e.key]=()=>Promise.resolve(e),e.key===Sn.value.key&&(Sn.value=e)});var Yi=Symbol(""),Pn=()=>{const e=Be(Yi);if(!e)throw new Error("usePageFrontmatter() is called without provider.");return e},Qi=Symbol(""),Ig=()=>{const e=Be(Qi);if(!e)throw new Error("usePageHead() is called without provider.");return e},_g=Symbol(""),Xi=Symbol(""),Tg=()=>{const e=Be(Xi);if(!e)throw new Error("usePageLang() is called without provider.");return e},Bo=Symbol(""),wr=()=>{const e=Be(Bo);if(!e)throw new Error("useRouteLocale() is called without provider.");return e},Dn=qe(_d),Zi=()=>Dn;import.meta.webpackHot&&(__VUE_HMR_RUNTIME__.updateSiteData=e=>{Dn.value=e});var el=Symbol(""),Fo=()=>{const e=Be(el);if(!e)throw new Error("useSiteLocaleData() is called without provider.");return e},Lg=Symbol(""),Kn=Sr({resolvePageData:async e=>{const n=Ki.value[e],r=await(n==null?void 0:n());return r!=null?r:$i},resolvePageFrontmatter:e=>e.frontmatter,resolvePageHead:(e,n,r)=>{const a=Ee(n.description)?n.description:r.description,o=[...oe(n.head)?n.head:[],...r.head,["title",{},e],["meta",{name:"description",content:a}]];return Ld(o)},resolvePageHeadTitle:(e,n)=>`${e.title?`${e.title} | `:""}${n.title}`,resolvePageLang:e=>e.lang||"en",resolveRouteLocale:(e,n)=>pi(e,n),resolveSiteLocaleData:(e,n)=>({...e,...e.locales[n]})}),Uo=ge({name:"ClientOnly",setup(e,n){const r=qe(!1);return Ke(()=>{r.value=!0}),()=>{var a,o;return r.value?(o=(a=n.slots).default)==null?void 0:o.call(a):null}}}),Dg=ge({name:"Content",props:{pageKey:{type:String,required:!1,default:""}},setup(e){const n=On(),r=J(()=>hi[e.pageKey||n.value.key]);return()=>r.value?pe(r.value):pe("div","404 Not Found")}}),Rg="Layout",zg="NotFound",Og=ta.reduce((e,n)=>({...e,...n.layouts}),{}),ds=ge({name:"Vuepress",setup(){const e=On(),n=J(()=>{let r;if(e.value.path){const a=e.value.frontmatter.layout;Ee(a)?r=a:r=Rg}else r=zg;return Og[r]});return()=>pe(n.value)}}),Ho=e=>Gr(e)?e:`${Zi().value.base}${mi(e)}`;const Mg=[["v-8daa1a0e","/",{title:""},["/index.html","/README.md"]],["v-705d1b76","/test_page.html",{title:"PSP"},["/test_page","/test_page.md"]],["v-2d0a870d","/en/",{title:"PSP - Documentation Site"},["/en/index.html","/en/README.md"]],["v-2d0a87a8","/es/",{title:"PSP - P\xE1gina  de documentaci\xF3n"},["/es/index.html","/es/README.md"]],["v-5aa74f15","/en/unit1/concurrency.html",{title:"1.2 Concurrency"},["/en/unit1/concurrency","/en/unit1/concurrency.md"]],["v-b73e5022","/en/unit1/",{title:"1 Introduction"},["/en/unit1/index.html","/en/unit1/index.md"]],["v-4b0532d0","/en/unit1/operatingsystem.html",{title:"1.3 Processes in the OS"},["/en/unit1/operatingsystem","/en/unit1/operatingsystem.md"]],["v-3f423939","/en/unit1/process.html",{title:"1.1 Processes, programs, threads"},["/en/unit1/process","/en/unit1/process.md"]],["v-8100edac","/en/unit2/curl_annex.html",{title:"2.4 Annex I - Curl"},["/en/unit2/curl_annex","/en/unit2/curl_annex.md"]],["v-b73e4fe4","/en/unit2/",{title:"2 Introduction"},["/en/unit2/index.html","/en/unit2/index.md"]],["v-74406b7a","/en/unit2/iostreams.html",{title:"2.3 Handling Process Streams"},["/en/unit2/iostreams","/en/unit2/iostreams.md"]],["v-348bab3f","/en/unit2/processbuilder.html",{title:"2.2 Process management in Java - ProcessBuilder and Process"},["/en/unit2/processbuilder","/en/unit2/processbuilder.md"]],["v-1daecb0f","/en/unit2/runtime.html",{title:"2.1 Running processes in Java with Runtime"},["/en/unit2/runtime","/en/unit2/runtime.md"]],["v-5bb12cb4","/en/unit3/alternatives.html",{title:"3.4 Alternative synchronization techniques"},["/en/unit3/alternatives","/en/unit3/alternatives.md"]],["v-10f2297a","/en/unit3/arraylist_annex.html",{title:"3.6 Annex III - ArrayList cheat sheet by students"},["/en/unit3/arraylist_annex","/en/unit3/arraylist_annex.md"]],["v-737de6d4","/en/unit3/debugger_annex.html",{title:"3.5 Annex I - Debugging multithread apps in Netbeans"},["/en/unit3/debugger_annex","/en/unit3/debugger_annex.md"]],["v-3714d943","/en/unit3/hashmap_annex.html",{title:"3.6 Annex II - HashMap cheat sheet by students"},["/en/unit3/hashmap_annex","/en/unit3/hashmap_annex.md"]],["v-b73e4fa6","/en/unit3/",{title:"3 Introduction"},["/en/unit3/index.html","/en/unit3/index.md"]],["v-30e3afd6","/en/unit3/producer-consumer.html",{title:"3.3 Producer-Consumer model"},["/en/unit3/producer-consumer","/en/unit3/producer-consumer.md"]],["v-27271e62","/en/unit3/runnable.html",{title:"3.1 Java classes for threads"},["/en/unit3/runnable","/en/unit3/runnable.md"]],["v-1dbfca26","/en/unit3/synchronization.html",{title:"3.2 Threads synchronization and communication"},["/en/unit3/synchronization","/en/unit3/synchronization.md"]],["v-b73e4f68","/en/unit4/",{title:"4 Introduction"},["/en/unit4/index.html","/en/unit4/index.md"]],["v-14f705b1","/en/unit4/sockets-tcp.html",{title:"4.3 TCP Sockets"},["/en/unit4/sockets-tcp","/en/unit4/sockets-tcp.md"]],["v-9c83245e","/en/unit4/sockets-udp.html",{title:"4.4 UDP Sockets"},["/en/unit4/sockets-udp","/en/unit4/sockets-udp.md"]],["v-17f557b3","/en/unit4/stateful-protocols.html",{title:"4.5 Stateful protocols"},["/en/unit4/stateful-protocols","/en/unit4/stateful-protocols.md"]],["v-de8e734c","/en/unit4/tcp-ip.html",{title:"4.1 TCP IP protocol stack"},["/en/unit4/tcp-ip","/en/unit4/tcp-ip.md"]],["v-3af7f8ae","/en/unit4/urls.html",{title:"4.2 Auxiliary classes for networking"},["/en/unit4/urls","/en/unit4/urls.md"]],["v-6e11e1d8","/en/unit6/asymmetric-keys.html",{title:"6.4 Encriptaci\xF3n asim\xE9trica"},["/en/unit6/asymmetric-keys","/en/unit6/asymmetric-keys.md"]],["v-4e4467f3","/en/unit6/hash-functions.html",{title:"6.2 Funciones resumen"},["/en/unit6/hash-functions","/en/unit6/hash-functions.md"]],["v-b73e4eec","/en/unit6/",{title:"6 Introducci\xF3n"},["/en/unit6/index.html","/en/unit6/index.md"]],["v-6fa59714","/en/unit6/jsse.html",{title:"6.5 Comunicaciones seguras en Java"},["/en/unit6/jsse","/en/unit6/jsse.md"]],["v-2e9c294f","/en/unit6/security.html",{title:"6.1 Seguridad"},["/en/unit6/security","/en/unit6/security.md"]],["v-0b29848c","/en/unit6/symmetric-key.html",{title:"6.3 Encriptaci\xF3n sim\xE9trica"},["/en/unit6/symmetric-key","/en/unit6/symmetric-key.md"]],["v-46af1970","/es/unit1/concurrency.html",{title:"1.2 Concurrencia"},["/es/unit1/concurrency","/es/unit1/concurrency.md"]],["v-a8728f6c","/es/unit1/",{title:"1 Introducci\xF3n"},["/es/unit1/index.html","/es/unit1/index.md"]],["v-e2dae91a","/es/unit1/operatingsystem.html",{title:"1.3 Procesos en el SO"},["/es/unit1/operatingsystem","/es/unit1/operatingsystem.md"]],["v-75292dd8","/es/unit1/process.html",{title:"1.1 Procesos, programas, hilos"},["/es/unit1/process","/es/unit1/process.md"]],["v-3277876f","/es/unit2/curl_annex.html",{title:"2.4 Anexo I - Curl"},["/es/unit2/curl_annex","/es/unit2/curl_annex.md"]],["v-a8728f2e","/es/unit2/",{title:"2 Introducci\xF3n"},["/es/unit2/index.html","/es/unit2/index.md"]],["v-14dd1095","/es/unit2/iostreams.html",{title:"2.3 Gesti\xF3n de la E-S de un proceso"},["/es/unit2/iostreams","/es/unit2/iostreams.md"]],["v-5320ff04","/es/unit2/processbuilder.html",{title:"2.2 Gesti\xF3n de procesos en Java - ProcessBuilder y Process"},["/es/unit2/processbuilder","/es/unit2/processbuilder.md"]],["v-b8500a2c","/es/unit2/runtime.html",{title:"2.1 Creaci\xF3n de procesos en Java con Runtime"},["/es/unit2/runtime","/es/unit2/runtime.md"]],["v-6718eaab","/es/unit3/alternatives.html",{title:"3.4 Mecanismos alternativos de sincronizaci\xF3n"},["/es/unit3/alternatives","/es/unit3/alternatives.md"]],["v-75f16356","/es/unit3/arraylist_annex.html",{title:"3.6 Annex III - ArrayList hoja de referencia de los alumnos"},["/es/unit3/arraylist_annex","/es/unit3/arraylist_annex.md"]],["v-36533f4a","/es/unit3/debugger_annex.html",{title:"3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans"},["/es/unit3/debugger_annex","/es/unit3/debugger_annex.md"]],["v-405378de","/es/unit3/hashmap_annex.html",{title:"3.6 Anexo II - HashMap hoja de referencia de los alumnos"},["/es/unit3/hashmap_annex","/es/unit3/hashmap_annex.md"]],["v-a8728ef0","/es/unit3/",{title:"3 Introducci\xF3n"},["/es/unit3/index.html","/es/unit3/index.md"]],["v-2a24fba0","/es/unit3/producer-consumer.html",{title:"3.3 Modelo productor-consumidor"},["/es/unit3/producer-consumer","/es/unit3/producer-consumer.md"]],["v-2b693c54","/es/unit3/runnable.html",{title:"3.1. Clases Java para la gesti\xF3n de hilos"},["/es/unit3/runnable","/es/unit3/runnable.md"]],["v-5c5621fe","/es/unit3/synchronization.html",{title:"3.2 Sincronizaci\xF3n y comunicaci\xF3n de hilos"},["/es/unit3/synchronization","/es/unit3/synchronization.md"]],["v-a8728eb2","/es/unit4/",{title:"4 Introducci\xF3n"},["/es/unit4/index.html","/es/unit4/index.md"]],["v-00fed00c","/es/unit4/sockets-tcp.html",{title:"4.3 Sockets TCP"},["/es/unit4/sockets-tcp","/es/unit4/sockets-tcp.md"]],["v-c4738fa8","/es/unit4/sockets-udp.html",{title:"4.4 Sockets UDP"},["/es/unit4/sockets-udp","/es/unit4/sockets-udp.md"]],["v-fefd7e10","/es/unit4/stateful-protocols.html",{title:"4.5 Protocolos con estado"},["/es/unit4/stateful-protocols","/es/unit4/stateful-protocols.md"]],["v-d5e6a1c2","/es/unit4/tcp-ip.html",{title:"4.1 Pila de protocolos TCP IP"},["/es/unit4/tcp-ip","/es/unit4/tcp-ip.md"]],["v-75d559ae","/es/unit4/urls.html",{title:"4.2 Clases auxiliares para direccionamiento"},["/es/unit4/urls","/es/unit4/urls.md"]],["v-222706b3","/es/unit6/asymmetric-keys.html",{title:"6.4 Encriptaci\xF3n asim\xE9trica"},["/es/unit6/asymmetric-keys","/es/unit6/asymmetric-keys.md"]],["v-6cd9bbb8","/es/unit6/hash-functions.html",{title:"6.2 Funciones resumen"},["/es/unit6/hash-functions","/es/unit6/hash-functions.md"]],["v-a8728e36","/es/unit6/",{title:"6 Introducci\xF3n"},["/es/unit6/index.html","/es/unit6/index.md"]],["v-02f6ed19","/es/unit6/jsse.html",{title:"6.5 Comunicaciones seguras en Java"},["/es/unit6/jsse","/es/unit6/jsse.md"]],["v-6d98f4d4","/es/unit6/security.html",{title:"6.1 Seguridad"},["/es/unit6/security","/es/unit6/security.md"]],["v-03a9dd55","/es/unit6/symmetric-key.html",{title:"6.3 Encriptaci\xF3n sim\xE9trica"},["/es/unit6/symmetric-key","/es/unit6/symmetric-key.md"]],["v-3706649a","/404.html",{title:""},["/404"]]];var Ng=()=>Mg.reduce((e,[n,r,a,o])=>(e.push({name:n,path:r,component:ds,meta:a},...o.map(t=>({path:t,redirect:r}))),e),[{name:"404",path:"/:catchAll(.*)",component:ds}]),Bg=Zd,Fg=()=>{const e=zu({history:Bg(ui(Dn.value.base)),routes:Ng(),scrollBehavior:(n,r,a)=>a||(n.hash?{el:n.hash}:{top:0})});return e.beforeResolve(async(n,r)=>{var a;(n.path!==r.path||r===vn)&&([Sn.value]=await Promise.all([Kn.resolvePageData(n.name),(a=hi[n.name])==null?void 0:a.__asyncLoader()]))}),e},Ug=e=>{e.component("ClientOnly",Uo),e.component("Content",Dg)},Hg=(e,n)=>{const r=J(()=>Kn.resolveRouteLocale(Dn.value.locales,n.currentRoute.value.path)),a=J(()=>Kn.resolveSiteLocaleData(Dn.value,r.value)),o=J(()=>Kn.resolvePageFrontmatter(Sn.value)),t=J(()=>Kn.resolvePageHeadTitle(Sn.value,a.value)),s=J(()=>Kn.resolvePageHead(t.value,o.value,a.value)),i=J(()=>Kn.resolvePageLang(Sn.value));return e.provide(Bo,r),e.provide(el,a),e.provide(Yi,o),e.provide(_g,t),e.provide(Qi,s),e.provide(Xi,i),Object.defineProperties(e.config.globalProperties,{$frontmatter:{get:()=>o.value},$head:{get:()=>s.value},$headTitle:{get:()=>t.value},$lang:{get:()=>i.value},$page:{get:()=>Sn.value},$routeLocale:{get:()=>r.value},$site:{get:()=>Dn.value},$siteLocale:{get:()=>a.value},$withBase:{get:()=>Ho}}),{pageData:Sn,pageFrontmatter:o,pageHead:s,pageHeadTitle:t,pageLang:i,routeLocale:r,siteData:Dn,siteLocaleData:a}},Wg=()=>{const e=jn(),n=Ig(),r=Tg(),a=qe([]),o=()=>{n.value.forEach(s=>{const i=Vg(s);i&&a.value.push(i)})},t=()=>{document.documentElement.lang=r.value,a.value.forEach(s=>{s.parentNode===document.head&&document.head.removeChild(s)}),a.value.splice(0,a.value.length),n.value.forEach(s=>{const i=Jg(s);i!==null&&(document.head.appendChild(i),a.value.push(i))})};er(Lg,t),Ke(()=>{o(),t(),dn(()=>e.path,()=>t())})},Vg=([e,n,r=""])=>{const a=Object.entries(n).map(([i,l])=>Ee(l)?`[${i}="${l}"]`:l===!0?`[${i}]`:"").join(""),o=`head > ${e}${a}`;return Array.from(document.querySelectorAll(o)).find(i=>i.innerText===r)||null},Jg=([e,n,r])=>{if(!Ee(e))return null;const a=document.createElement(e);return To(n)&&Object.entries(n).forEach(([o,t])=>{Ee(t)?a.setAttribute(o,t):t===!0&&a.setAttribute(o,"")}),Ee(r)&&a.appendChild(document.createTextNode(r)),a},Gg=Ad,Kg=async()=>{var r;const e=Gg({name:"VuepressApp",setup(){var a;Wg();for(const o of ta)(a=o.setup)==null||a.call(o);return()=>[pe(ki),...ta.flatMap(({rootComponents:o=[]})=>o.map(t=>pe(t)))]}}),n=Fg();Ug(e),Hg(e,n);for(const a of ta)await((r=a.enhance)==null?void 0:r.call(a,{app:e,router:n,siteData:Dn}));return e.use(n),{app:e,router:n}};Kg().then(({app:e,router:n})=>{n.isReady().then(()=>{e.mount("#app")})});export{Le as _,ye as a,Fn as b,ae as c,Kg as createVueApp,se as d,Re as e,Wc as f,V as o,qn as r,Me as t,Fe as w};
