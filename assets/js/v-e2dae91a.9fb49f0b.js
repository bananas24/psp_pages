"use strict";(self.webpackChunkapuntes_psp=self.webpackChunkapuntes_psp||[]).push([[922],{2717:(e,t,s)=>{s.r(t),s.d(t,{data:()=>n});const n={key:"v-e2dae91a",path:"/es/unit1/operatingsystem.html",title:"1.3 Procesos en el SO",lang:"es-ES",frontmatter:{title:"1.3 Procesos en el SO"},excerpt:"",headers:[{level:2,title:"1.3.1. El kernel del SO",slug:"_1-3-1-el-kernel-del-so",children:[]},{level:2,title:"1.3.2. Control de procesos en GNU/Linux",slug:"_1-3-2-control-de-procesos-en-gnu-linux",children:[{level:3,title:"Comandos para saber el pid de los procesos",slug:"comandos-para-saber-el-pid-de-los-procesos",children:[]},{level:3,title:"Comandos para ver los procesos activos",slug:"comandos-para-ver-los-procesos-activos",children:[]},{level:3,title:"Control de procesos",slug:"control-de-procesos",children:[]}]},{level:2,title:"1.3.3. Estados de un proceso",slug:"_1-3-3-estados-de-un-proceso",children:[]},{level:2,title:"1.3.4 Planificación de procesos",slug:"_1-3-4-planificacion-de-procesos",children:[]},{level:2,title:"1.3.5. Algoritmos de planificación de procesos",slug:"_1-3-5-algoritmos-de-planificacion-de-procesos",children:[{level:3,title:"FCFS - First Come First Served",slug:"fcfs-first-come-first-served",children:[]},{level:3,title:"SJF - Shortest Job First",slug:"sjf-shortest-job-first",children:[]},{level:3,title:"Planificación por prioridad",slug:"planificacion-por-prioridad",children:[]},{level:3,title:"Round Robin",slug:"round-robin",children:[]},{level:3,title:"Procesos con operaciones de E/S o bloqueos",slug:"procesos-con-operaciones-de-e-s-o-bloqueos",children:[]}]}],filePathRelative:"es/unit1/operatingsystem.md",git:{updatedTime:1629986222e3,contributors:[{name:"Vicente Martínez",email:"vicente@iesdoctorbalmis.com",commits:1}]}}},7264:(e,t,s)=>{s.r(t),s.d(t,{default:()=>z});var n=s(6252);const a=(0,n._)("h1",{id:"_1-3-procesos-en-el-sistema-operativo",tabindex:"-1"},"1.3. Procesos en el Sistema Operativo",-1),o={class:"table-of-contents"},l=(0,n.Uk)("1.3.1. El kernel del SO"),r=(0,n.Uk)("1.3.2. Control de procesos en GNU/Linux"),i=(0,n.Uk)("Comandos para saber el pid de los procesos"),c=(0,n.Uk)("Comandos para ver los procesos activos"),d=(0,n.Uk)("Control de procesos"),p=(0,n.Uk)("1.3.3. Estados de un proceso"),u=(0,n.Uk)("1.3.4 Planificación de procesos"),m=(0,n.Uk)("1.3.5. Algoritmos de planificación de procesos"),g=(0,n.Uk)("FCFS - First Come First Served"),y=(0,n.Uk)("SJF - Shortest Job First"),x=(0,n.Uk)("Planificación por prioridad"),b=(0,n.Uk)("Round Robin"),h=(0,n.Uk)("Procesos con operaciones de E/S o bloqueos"),A=(0,n.uE)('<h2 id="_1-3-1-el-kernel-del-so" tabindex="-1">1.3.1. El kernel del SO</h2><p>El <code>kernel o núcleo de un SO</code> se encarga de la funcionalidad básica del sistema, el responsable de la gestión de los recursos del ordenador, se accede al núcleo a través de las llamadas al sistema, es la parte más pequeña del sistema en comparación con la interfaz. El resto del sistema operativo se le denomina como programas del sistema.</p><p>Todos los programas que se ejecutan en el ordenador se organizan como un conjunto de procesos. Es el sistema operativo el que decide parar la ejecución , por ejemplo, porque lleva mucho tiempo en la CPu, y decide cuál será el siguiente proceso que pasará a ejecutarse.</p><p>Cuando se suspende la ejecución de un proceso, luego deberá reiniciarse en el mismo estado en el que se encontraba antes de ser suspendido. Esto implica que debemos almacenar en algún sitio la información referente a ese proceso para poder luego restaurarla tal como estaba antes. Esta información se almacena en el <code>PCB</code> (Bloque de control de procesos).</p><p>Estos <code>cambios de contexto</code>, que es como se conoce al reemplazo de un proceso por otro, son bastante costosos (en tiempo y recursos) por toda la información que hay que guardar. Ya veremos más adelante que existe otra unidad de ejecución, los <code>hilos</code>, que solucionan en parte este problema.</p><p><img src="/media/process_control_blocks.gif" alt="Process Control Block"></p><h2 id="_1-3-2-control-de-procesos-en-gnu-linux" tabindex="-1">1.3.2. Control de procesos en GNU/Linux</h2><p>Los sistemas Linux identifican a los procesos por su PID (Process ID) así como por su PPID (Parent PID). De esta forma, los procesos pueden clasificarse en:</p><ul><li>Procesos padre: Son procesos que crean otros procesos durante su ejecución</li><li>Procesos hijos: son procesos creados por otros procesos</li></ul><p>Cuando se arranca el sistema, el kernel lanza el proceso <strong>init</strong> que es la madre de todos los demás procesos. Al ser el primero que se lanza es el único que no tiene padre. El proceso init se encarga de gestionar todos los demás procesos que se van ejecutando en el SO.</p><div class="custom-container info"><p class="custom-container-title">proceso init</p><p>El proceso init tiene el pid 1 y, como ya hemos dicho no tiene padre.</p><p>Este proceso se utiliza como padre &quot;adoptivo&quot; para todos aquellos procesos que se quedan huérfanos.</p></div><h3 id="comandos-para-saber-el-pid-de-los-procesos" tabindex="-1">Comandos para saber el pid de los procesos</h3><p>El comando <code>pidof cmdname</code> nos dice el nombre de todos los procesos asociados a ese comando. Es importante recordar que cada vez que ejecutamos un comando, se crea un nuevo proceso.</p><p>Las variables $$ y $PPID nos indican el pid del proceso actual y su ppid respectivamente.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="shiki" style="background-color:#FAFAFA;"><code><span class="line"><span style="color:#90A4AE;font-style:italic;"># pidof systemd</span></span>\n<span class="line"><span style="color:#90A4AE;">1</span></span>\n<span class="line"><span style="color:#90A4AE;font-style:italic;"># pidof top</span></span>\n<span class="line"><span style="color:#90A4AE;">2060</span></span>\n<span class="line"><span style="color:#90A4AE;font-style:italic;"># pidof httpd</span></span>\n<span class="line"><span style="color:#90A4AE;">2103 2102 2101 2100 2099 1076</span></span>\n<span class="line"><span style="color:#90A4AE;font-style:italic;"># Process pid</span></span>\n<span class="line"><span style="color:#6182B8;">echo</span><span style="color:#90A4AE;"> </span><span style="color:#39ADB5;">$</span><span style="color:#90A4AE;">$</span></span>\n<span class="line"><span style="color:#90A4AE;">2109</span></span>\n<span class="line"><span style="color:#90A4AE;font-style:italic;"># Process parent pid</span></span>\n<span class="line"><span style="color:#6182B8;">echo</span><span style="color:#90A4AE;"> </span><span style="color:#39ADB5;">$</span><span style="color:#90A4AE;">PPID</span></span>\n<span class="line"><span style="color:#90A4AE;">2106</span></span>\n<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="comandos-para-ver-los-procesos-activos" tabindex="-1">Comandos para ver los procesos activos</h3><p>El principal comando para conocer los procesos que se están ejecutando en un equipo es el comando <code>ps</code>. Con este comando podemos ver parte de la información asociada a un proceso.</p><p>El comando ps tiene múltiples opciones que nos permiten ver más o menos información de los procesos, así como los procesos de nuestro usuario o del resto de usuarios, estadísticas sobre el uso de recursos de cada proceso, etc.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="shiki" style="background-color:#FAFAFA;"><code><span class="line"><span style="color:#90A4AE;">vicente@Desktop-Vicente:</span><span style="color:#39ADB5;">~</span><span style="color:#90A4AE;">$ ps -AF</span></span>\n<span class="line"><span style="color:#90A4AE;">UID        PID  PPID  C    SZ   RSS PSR STIME TTY          TIME CMD</span></span>\n<span class="line"><span style="color:#90A4AE;">root         1     0  0   223   576   5 11:00 </span><span style="color:#39ADB5;">?</span><span style="color:#90A4AE;">        00:00:00 /init</span></span>\n<span class="line"><span style="color:#90A4AE;">root         7     1  0   223    80   3 11:00 </span><span style="color:#39ADB5;">?</span><span style="color:#90A4AE;">        00:00:00 /init</span></span>\n<span class="line"><span style="color:#90A4AE;">root         8     7  0   223    80   1 11:00 </span><span style="color:#39ADB5;">?</span><span style="color:#90A4AE;">        00:00:00 /init</span></span>\n<span class="line"><span style="color:#90A4AE;">vicente      9     8  0  2508  5032   4 11:00 pts/0    00:00:00 -bash</span></span>\n<span class="line"><span style="color:#90A4AE;">vicente     70     9  0  2650  3224   5 11:06 pts/0    00:00:00 ps -AF</span></span>\n<span class="line"><span style="color:#90A4AE;">vicente@Desktop-Vicente:</span><span style="color:#39ADB5;">~</span><span style="color:#90A4AE;">$ ps -auxf</span></span>\n<span class="line"><span style="color:#90A4AE;">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span></span>\n<span class="line"><span style="color:#90A4AE;">root         1  0.0  0.0    892   576 </span><span style="color:#39ADB5;">?</span><span style="color:#90A4AE;">        Sl   11:00   0:00 /init</span></span>\n<span class="line"><span style="color:#90A4AE;">root         7  0.0  0.0    892    80 </span><span style="color:#39ADB5;">?</span><span style="color:#90A4AE;">        Ss   11:00   0:00 /init</span></span>\n<span class="line"><span style="color:#90A4AE;">root         8  0.0  0.0    892    80 </span><span style="color:#39ADB5;">?</span><span style="color:#90A4AE;">        S    11:00   0:00  \\_ /init</span></span>\n<span class="line"><span style="color:#90A4AE;">vicente      9  0.0  0.0  10032  5032 pts/0    Ss   11:00   0:00      \\_ -bash</span></span>\n<span class="line"><span style="color:#90A4AE;">vicente     72  0.0  0.0  10832  3408 pts/0    R+   11:09   0:00          \\_ ps -auxf</span></span>\n<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div>',19),v={class:"custom-container info"},f=(0,n._)("p",{class:"custom-container-title"},"Useful ‘ps’ examples for Linux process monitoring",-1),E={href:"https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/",target:"_blank",rel:"noopener noreferrer"},q=(0,n.Uk)("https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/"),P=(0,n.uE)('<p>El otro comando que nos permite ver la información, en este caso en tiempo real, de los procesos que se están ejecutando en l máquina junto con los recursos que están consumiendo, es el comando <code>top</code>.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="shiki" style="background-color:#FAFAFA;"><code><span class="line"><span style="color:#90A4AE;">vicente@Desktop-Vicente:</span><span style="color:#39ADB5;">~</span><span style="color:#90A4AE;">$ ps -AF</span></span>\n<span class="line"><span style="color:#90A4AE;">top - 11:14:52 up 14 min,  0 users,  load average: 0.00, 0.00, 0.00</span></span>\n<span class="line"><span style="color:#90A4AE;">Tasks:   5 total,   1 running,   4 sleeping,   0 stopped,   0 zombie</span></span>\n<span class="line"><span style="color:#90A4AE;">%Cpu</span><span style="color:#39ADB5;">(</span><span style="color:#90A4AE;">s</span><span style="color:#39ADB5;">)</span><span style="color:#90A4AE;">:  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span>\n<span class="line"><span style="color:#90A4AE;">MiB Mem </span><span style="color:#6182B8;">:</span><span style="color:#90A4AE;">  12677.3 total,  12556.4 free,     70.6 used,     50.3 buff/cache</span></span>\n<span class="line"><span style="color:#90A4AE;">MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.  12433.8 avail Mem</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#90A4AE;">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span></span>\n<span class="line"><span style="color:#90A4AE;">    1 root      20   0     892    576    516 S   0.0   0.0   0:00.04 init</span></span>\n<span class="line"><span style="color:#90A4AE;">    7 root      20   0     892     80     20 S   0.0   0.0   0:00.00 init</span></span>\n<span class="line"><span style="color:#90A4AE;">    8 root      20   0     892     80     20 S   0.0   0.0   0:00.01 init</span></span>\n<span class="line"><span style="color:#90A4AE;">    9 vicente   20   0   10032   5032   3324 S   0.0   0.0   0:00.11 bash</span></span>\n<span class="line"><span style="color:#90A4AE;">   73 vicente   20   0   10856   3664   3148 R   0.0   0.0   0:00.00 top</span></span>\n<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div>',2),S={class:"custom-container info"},_=(0,n._)("p",{class:"custom-container-title"},"‘top’ examples in Linux",-1),j={href:"https://www.tecmint.com/12-top-command-examples-in-linux/",target:"_blank",rel:"noopener noreferrer"},k=(0,n.Uk)("https://www.tecmint.com/12-top-command-examples-in-linux/"),C=(0,n.uE)('<h3 id="control-de-procesos" tabindex="-1">Control de procesos</h3><p>Linux tiene varios comandos para controlar los procesos, entre los que cabe destacar el comando <code>kill</code>.</p><p>La forma de controlar los procesos es enviándoles señales. Hay multitud de señales que se pueden enviar a un proceso. Sin embargo, para responder a una señal, los procesos deben estar programados para gestionarlas.</p><p>En el siguiente ejemplo</p><div class="language-bash ext-sh line-numbers-mode"><pre class="shiki" style="background-color:#FAFAFA;"><code><span class="line"><span style="color:#90A4AE;font-style:italic;"># Get Firefox PID after it freezes</span></span>\n<span class="line"><span style="color:#90A4AE;">$ pidof firefox</span></span>\n<span class="line"><span style="color:#90A4AE;">2687</span></span>\n<span class="line"><span style="color:#90A4AE;font-style:italic;"># Send the SIGKILL (9) signal to end the process inmediately</span></span>\n<span class="line"><span style="color:#90A4AE;">$ </span><span style="color:#6182B8;">kill</span><span style="color:#90A4AE;"> 9 2687</span></span>\n<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>',5),F={class:"custom-container info"},D=(0,n._)("p",{class:"custom-container-title"},"How to control Linux process Using kill, pkill and kilall",-1),U={href:"https://www.tecmint.com/how-to-kill-a-process-in-linux/",target:"_blank",rel:"noopener noreferrer"},w=(0,n.Uk)("https://www.tecmint.com/how-to-kill-a-process-in-linux/"),T=(0,n.uE)('<p>Otra forma de influir en la ejecución de los procesos es mediante la prioridad. En los sistemas Linux todos los procesos tienen una cierta prioridad. Esto influye a la hora de obtener tiempo de CPU por lo que podemos conseguir que un proceso se ejecute más o menos rápido que los demás.</p><p>Un usuario con privilegios de <em>root</em> puede modificar los valores de prioridad de los procesos. Este valor lo podemos ver en la columna NI (nice) del comando top. Este valor influye en la columna PR que indica la prioridad que le da el sistema a un proceso.</p><p>El rango de asignación de prioridad disponible es de -20 a 19 , siendo -20 la mayor prioridad y 19 la menor. Con el comando <code>nice</code> podemos asegurarnos que en momentos de usos elevados de CPU los procesos adecuados reciban el mayor % de la misma.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="shiki" style="background-color:#FAFAFA;"><code><span class="line"><span style="color:#90A4AE;">vicente@Desktop-Vicente:</span><span style="color:#39ADB5;">~</span><span style="color:#90A4AE;">$ nice</span></span>\n<span class="line"><span style="color:#90A4AE;">0</span></span>\n<span class="line"><span style="color:#90A4AE;">vicente@Desktop-Vicente:</span><span style="color:#39ADB5;">~</span><span style="color:#90A4AE;">$ nice -n 10 bash</span></span>\n<span class="line"><span style="color:#90A4AE;">vicente@Desktop-Vicente:</span><span style="color:#39ADB5;">~</span><span style="color:#90A4AE;">$ nice</span></span>\n<span class="line"><span style="color:#90A4AE;">10</span></span>\n<span class="line"><span style="color:#90A4AE;">vicente@Desktop-Vicente:</span><span style="color:#39ADB5;">~</span><span style="color:#90A4AE;">$</span></span>\n<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">Control de procesos en Windows</p><p>En los sistemas operativos Windows, la mayoría de estas acciones se pueden realizar desde el administrador de tareas, aunque también tenemos los comandos <strong>tasklist</strong> y <strong>taskkill</strong> para hacerlo desde consola</p><p><em>tasklist /svc /fi “imagename eq svchost.exe”</em> Con esta instrucción sabremos que servicios se están ejecutando bajo el proceso svchost.exe, es el nombre de proceso de host genérico para servicios que se ejecutan desde bibliotecas de vínculos dinámicos (DLL), hay tantos para evitar riesgos ya que si estuviera todo en uno u nposible fallo podría colapsar el sistema.</p></div><h2 id="_1-3-3-estados-de-un-proceso" tabindex="-1">1.3.3. Estados de un proceso</h2><p>El siguiente diagrama muestra los tres posibles estados en los que se puede encontrar un proceso. Las líneas que conectan los estados representan las posibles transiciones que se pueden dar.</p><p>En todo momento un procesos estará en una de los tres estados. Como ya hemos visto, en los sitemas monoprocesador, un único proceso podrá estar en estado de ejecución en un momento dado. El resto de procesos estará o bien en espera o bien bbloqueados.</p><p>Para cada uno de los estados se gestiona una lista de procesos que administra el kernel del SO. Los procesos permanecerán en la cola hasta que se produzca algún evento.</p><p><img src="/media/estados_proceso.png" alt="Estados de un proceso"></p><ul><li><strong>Nuevo</strong>. El fichero es creado a partir de un ejecutable.</li><li><strong>Listo</strong>. Está parado temporalmente y listo para ejecutarse cuando se le dé la oportunidad. El sistema oprativo todavía no le asigno un procesador para ejecutarse. El planificador del S.O. será el responsable de seleccionar el proceso para que pase a estado de ejecución.</li><li><strong>En ejecución</strong>. Está usando el procesador. El sistema operativo utiliza el mecanismo de interrupciones para controlar su ejecución. Si el proceso necesitase un recurso, incluyendo la realización de operaciones de E/S, llamará a la llamada al sistema correspondiente. Si un proceso se ejecuta durante el máximo tiempo permitido por la política del sistema, salta un temporizador que lanza una interrupción. Si el sistema es de tiempo compartido, lo para y lo pasa a estado de listo.</li><li><strong>Bloqueado</strong>. El proceso se encuentra bloqueado esperando a aque ocurra algún suceso. Por ejemplo puede estar esperando a que termine alguna operación de E/S, o bien a sincronizarse con otro proceso. Cuando ocurre el evento que lo desbloquea, el proceso queda pendiente de ser planificado por el S.O. no pasa directamente a ejecución.</li><li><strong>Terminado</strong>. El proceso termina y libera su imagen de memoria. Es el propio proceso el que debe llamar al sistema para indicar que ha terminado, aunque el sistema puede finalizarlo con una excepción (que es una interrupción especial).</li></ul><p>Transiciones entre estados:</p><ul><li><strong>De ejecución a bloqueado</strong>: un proceso pasa de ejecución a bloqueado cuando espera la ocurrencia de un evento externo.</li><li><strong>De bloqueado a listo</strong>: cuando ocurre el evento externo que esperaba</li><li><strong>De listo a ejecución</strong>: cuando el sistema le otorga un tiempo de CPU.</li><li><strong>De ejecución a listo</strong>: cuando se le acaba el tiempo asignado por el S.O.</li></ul><h2 id="_1-3-4-planificacion-de-procesos" tabindex="-1">1.3.4 Planificación de procesos</h2><p>Uno de los objetivos de los sistemas operativos es la multiprogramación, es decir, admitir varios procesos en memoria para maximizar el uso del procesador. Esto funciona ya que los procesos se irán intercambiando el uso del procesador para su ejecución de forma concurrente. Para ello, el sistema operativo organiza los procesos en varias colas pasándolos de unas colas a otras</p><ul><li>Cola de procesos: contiene todos los procesos del sistema</li><li>Cola de procesos preparados: todos los procesos listos esperando para ejecutarse.</li><li>Varias colas de dispositivos: procesos que están esperando alguna operación de E/S.</li></ul><p><img src="/media/process_queues.gif" alt="Colas de procesos del planificador"></p><p>El planificador es el encargado de seleccionar los movimientos de los procesos entre las distintas colas. Existe una planificación a corto plazo y otra a largo plazo, veamos cada una:</p><ul><li>Corto plazo: selecciona los procesos de la cola de preparados para pasarlos a ejecución, se invoca con mucha frecuencia, del orden de milisegundos, por lo que el algoritmo debe ser muy sencillo. <ul><li>Planificación sin desalojo: un proceso en ejecución sólo se saca si termina o bien se queda bloqueado.</li><li>Planificación apropiativa: solo se saca un proceso de ejecución si termina, se bloquea o por último aparece un proceso con mayor prioridad.</li><li>Tiempo compartido: cada cierto tiempo (cuanto), se desaloja un proceso y se mete otro, Se considera que todos los procesos tienen la misma prioridad.</li></ul></li><li>Largo plazo: selecciona que procesos nuevos pasan a la cola de preparados. Hace un control del grado de multiprogramación del proceso para tomar sus decisiones.</li></ul><div class="custom-container warning"><p class="custom-container-title">Cambios de contexto</p><p>El cambio de contexto que se hace al cambiar un proceso es tiempo perdido, ya no se hace trabajo útil. Cambiar el estado del proceso, el estado del procesador (cambio valores de registro) e información de la gestión de memoria, por muy rápido que se haga si se hace con mucha frecuencia puede provocar una ralentización del sistema, por eso tener muchos programas abiertos provoca una disminución importante en el rendimiento del sistema.</p></div><h2 id="_1-3-5-algoritmos-de-planificacion-de-procesos" tabindex="-1">1.3.5. Algoritmos de planificación de procesos</h2><p>Los algoritmos de planificación se utilizan para intentar mejorar el rendimiento del sistema y, por ende, la experiencia de usuario.</p><p>Para establecer parámetros objetivos que permitan comparar los diferentes resultados, vamos a tomar como referencia los siguientes criterios:</p><ul><li>Tiempo de espera: tiempo que un proceso permanece en la cola de preparados esperando a ser ejecutado.</li><li>Tiempo de retorno: tiempo transcurrido entre la llegada de un proceso y su finalización.</li><li>Uso de CPU: % de tiempo que la CPU está utilizada</li><li>Rendimiento/Productividad (throughput): número de procesos que se completan por unidad de tiempo</li></ul><table><thead><tr><th style="text-align:center;">Procesos</th><th style="text-align:center;">LLegada</th><th style="text-align:center;">Tiempo uso CPU</th><th style="text-align:center;">Prioridad</th></tr></thead><tbody><tr><td style="text-align:center;">P1</td><td style="text-align:center;">0</td><td style="text-align:center;">10</td><td style="text-align:center;">5</td></tr><tr><td style="text-align:center;">P2</td><td style="text-align:center;">1</td><td style="text-align:center;">6</td><td style="text-align:center;">10</td></tr><tr><td style="text-align:center;">P3</td><td style="text-align:center;">2</td><td style="text-align:center;">3</td><td style="text-align:center;">7</td></tr></tbody></table><p>Con esta información, vamos a ver cómo se comportan los diferentes algoritmos</p><h3 id="fcfs-first-come-first-served" tabindex="-1">FCFS - First Come First Served</h3><p>En esta política de planificación, el procesador ejecuta cada proceso hasta que termina o pasa al estado de bloqueado, por tanto, los procesos que están en la cola de procesos preparados permanecerán en el orden en que lleguen hasta que les toque su ejecución. Este método se conoce también como FIFO (Fist In, First Out).</p><p>Se trata de una política muy simple y sencilla de llevar a la práctica, pero muy pobre en cuanto a su comportamiento.</p><p>La cantidad de tiempo de espera de cada proceso depende del número de procesos que se encuentren en la cola en el momento de su petición de ejecución y del tiempo que cada uno de ellos tenga en uso al procesador, y es independiente de las necesidades del propio proceso.</p><p><img src="/media/fcfs-1.svg" alt="FCFS monoprocessor"></p><table><thead><tr><th style="text-align:center;">Procesos</th><th style="text-align:center;">Tiempo espera</th><th style="text-align:center;">Tiempo de retorno</th><th style="text-align:center;">% uso CPU</th><th style="text-align:center;">Productividad</th></tr></thead><tbody><tr><td style="text-align:center;">P1</td><td style="text-align:center;">0</td><td style="text-align:center;">10</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P2</td><td style="text-align:center;">9</td><td style="text-align:center;">15</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P3</td><td style="text-align:center;">14</td><td style="text-align:center;">17</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">Medias</td><td style="text-align:center;">7,6</td><td style="text-align:center;">14</td><td style="text-align:center;">100%</td><td style="text-align:center;">0,15</td></tr></tbody></table><p><img src="/media/fcfs-2.svg" alt="FCFS dual processor"></p><table><thead><tr><th style="text-align:center;">Procesos</th><th style="text-align:center;">Tiempo espera</th><th style="text-align:center;">Tiempo de retorno</th><th style="text-align:center;">% uso CPU</th><th style="text-align:center;">Productividad</th></tr></thead><tbody><tr><td style="text-align:center;">P1</td><td style="text-align:center;">0</td><td style="text-align:center;">10</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P2</td><td style="text-align:center;">0</td><td style="text-align:center;">6</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P3</td><td style="text-align:center;">5</td><td style="text-align:center;">8</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">Medias</td><td style="text-align:center;">1,6</td><td style="text-align:center;">6</td><td style="text-align:center;">95%</td><td style="text-align:center;">0,3</td></tr></tbody></table><h3 id="sjf-shortest-job-first" tabindex="-1">SJF - Shortest Job First</h3><p>Este algoritmo siempre prioriza los procesos más cortos primero independientemente de su llegada y en caso de que los procesos sean iguales utilizara el método FIFO anterior, es decir, el orden según entrada. Este sistema tiene el riesgo de poner siempre al final de la cola los procesos más largos por lo que nunca se ejecutarán, esto se conoce como <code>inanición</code>.</p><p><img src="/media/sjf-1.svg" alt="SJF monoprocessor"></p><table><thead><tr><th style="text-align:center;">Procesos</th><th style="text-align:center;">Tiempo espera</th><th style="text-align:center;">Tiempo de retorno</th><th style="text-align:center;">% uso CPU</th><th style="text-align:center;">Productividad</th></tr></thead><tbody><tr><td style="text-align:center;">P1</td><td style="text-align:center;">0</td><td style="text-align:center;">10</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P2</td><td style="text-align:center;">14</td><td style="text-align:center;">18</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P3</td><td style="text-align:center;">8</td><td style="text-align:center;">11</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">Medias</td><td style="text-align:center;">7,3</td><td style="text-align:center;">13</td><td style="text-align:center;">100%</td><td style="text-align:center;">0,15</td></tr></tbody></table><p><img src="/media/sjf-2.svg" alt="SJF dual processor"></p><table><thead><tr><th style="text-align:center;">Procesos</th><th style="text-align:center;">Tiempo espera</th><th style="text-align:center;">Tiempo de retorno</th><th style="text-align:center;">% uso CPU</th><th style="text-align:center;">Productividad</th></tr></thead><tbody><tr><td style="text-align:center;">P1</td><td style="text-align:center;">0</td><td style="text-align:center;">10</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P2</td><td style="text-align:center;">0</td><td style="text-align:center;">6</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P3</td><td style="text-align:center;">5</td><td style="text-align:center;">8</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">Medias</td><td style="text-align:center;">1,6</td><td style="text-align:center;">6</td><td style="text-align:center;">95%</td><td style="text-align:center;">0,3</td></tr></tbody></table><h3 id="planificacion-por-prioridad" tabindex="-1">Planificación por prioridad</h3><p>Cada proceso tiene una prioridad, ejecutándose primero el que tenga mayor prioridad, independientemente de su llegada y en caso de que las prioridades sean iguales utilizará el método FIFO anterior, es decir, el orden según entrada.</p><p>Como ocurría con SJF, con este algoritmo son los procesos de prioridad más baja los que tienen riesgo de inanición.</p><p><img src="/media/prioridad-1.svg" alt="Prioridad monoprocessor"></p><table><thead><tr><th style="text-align:center;">Procesos</th><th style="text-align:center;">Tiempo espera</th><th style="text-align:center;">Tiempo de retorno</th><th style="text-align:center;">% uso CPU</th><th style="text-align:center;">Productividad</th></tr></thead><tbody><tr><td style="text-align:center;">P1</td><td style="text-align:center;">0</td><td style="text-align:center;">10</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P2</td><td style="text-align:center;">9</td><td style="text-align:center;">15</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P3</td><td style="text-align:center;">14</td><td style="text-align:center;">17</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">Medias</td><td style="text-align:center;">7,6</td><td style="text-align:center;">14</td><td style="text-align:center;">100%</td><td style="text-align:center;">0,15</td></tr></tbody></table><p><img src="/media/prioridad-2.svg" alt="Prioridad dual processor"></p><table><thead><tr><th style="text-align:center;">Procesos</th><th style="text-align:center;">Tiempo espera</th><th style="text-align:center;">Tiempo de retorno</th><th style="text-align:center;">% uso CPU</th><th style="text-align:center;">Productividad</th></tr></thead><tbody><tr><td style="text-align:center;">P1</td><td style="text-align:center;">0</td><td style="text-align:center;">10</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P2</td><td style="text-align:center;">0</td><td style="text-align:center;">6</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P3</td><td style="text-align:center;">5</td><td style="text-align:center;">8</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">Medias</td><td style="text-align:center;">1,6</td><td style="text-align:center;">6</td><td style="text-align:center;">95%</td><td style="text-align:center;">0,3</td></tr></tbody></table><h3 id="round-robin" tabindex="-1">Round Robin</h3><p>Este algoritmo de planificación es uno de los más complejos y difíciles de implementar, asigna a cada proceso un tiempo equitativo tratando a todos los procesos por igual y con la misma prioridad.</p><p>Este algoritmo es circular, volviendo siempre al primer proceso una vez terminado con el último. Para controlar que todos los procesos tienen su tiempo de CPU este método asigna a cada proceso un intervalo de tiempo llamado <code>quantum</code>.</p><p>Se pueden dar dos casuísticas con este método :</p><ul><li>El proceso, o lo que le queda por ejecutar, es menor que el quantum: Al terminar antes se planifica un nuevo proceso.</li><li>El proceso, o lo que le queda por ejecutar, es mayor que el quantum: Al terminar el quantum se expulsa el proceso dando paso al siguiente proceso en la lista. Al terminar la iteración se volverá para terminar el primer proceso expulsado.</li></ul><p><img src="/media/roundrobin-1.svg" alt="RR monoprocessor"></p><table><thead><tr><th style="text-align:center;">Procesos</th><th style="text-align:center;">Tiempo espera</th><th style="text-align:center;">Tiempo de retorno</th><th style="text-align:center;">% uso CPU</th><th style="text-align:center;">Productividad</th></tr></thead><tbody><tr><td style="text-align:center;">P1</td><td style="text-align:center;">9</td><td style="text-align:center;">19</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P2</td><td style="text-align:center;">8</td><td style="text-align:center;">14</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P3</td><td style="text-align:center;">6</td><td style="text-align:center;">9</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">Medias</td><td style="text-align:center;">7,6</td><td style="text-align:center;">14</td><td style="text-align:center;">100%</td><td style="text-align:center;">0,15</td></tr></tbody></table><p><img src="/media/roundrobin-2.svg" alt="RR dual processor"></p><table><thead><tr><th style="text-align:center;">Procesos</th><th style="text-align:center;">Tiempo espera</th><th style="text-align:center;">Tiempo de retorno</th><th style="text-align:center;">% uso CPU</th><th style="text-align:center;">Productividad</th></tr></thead><tbody><tr><td style="text-align:center;">P1</td><td style="text-align:center;">3</td><td style="text-align:center;">13</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P2</td><td style="text-align:center;">0</td><td style="text-align:center;">5</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">P3</td><td style="text-align:center;">2</td><td style="text-align:center;">5</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">Medias</td><td style="text-align:center;">1,6</td><td style="text-align:center;">7,6</td><td style="text-align:center;">73%</td><td style="text-align:center;">0,23</td></tr></tbody></table><div class="custom-container question"><p class="custom-container-title">Planificador combinado</p><p>En realidad, no se usa una única estrategia de planificación, sino que lo más común es que se combinen varias de ellas. De hecho en Round-Robin hemos usado también FCFS.</p><p>¿Te atreves a ver cómo sería una planificación Round-Robin con prioridad? Ten en cuenta que funcionará con el quantum y a la hora de escoger el siguiente proceso a ejecutar, se basará en la prioridad de los que haya en la lista.</p></div><h3 id="procesos-con-operaciones-de-e-s-o-bloqueos" tabindex="-1">Procesos con operaciones de E/S o bloqueos</h3><p>En los ejemplos anteriores hemos visto que todos los procesos pasan su tiempo en el procesador, pero esto no es un reflejo de la realidad, más bien al contrario. Los procesos en determinados momentos deben dejar el procesador para esperar una entrada de usuario, leer o almacenar información en disco, o símplemente esperar a que otro proceso termine una acción y le envie un dato que necesita para continuar.</p><p>En esos instantes, el proceso deja el procesador libre para que otros puedan hacer uso de él. En el momento en que ha terminado su espera o bloqueo, se vuelve a poner en cola de preparado para seguir ejecutándose.</p><p>En el siguiente gráfico tenemos una especificación de la actividad de 2 procesosen el que, antes de realizar el último paso de ambos, debe haber acabado la operación de E/S que realiza el proceso1.</p><p><img src="/media/operaciones_es.svg" alt="Procesos con E/S"></p><p>Veamos cómo se materializa esto en una ejecución de los procesos, suponiendo que ambos llegan a la vez a la cola.</p><p><img src="/media/roundrobin-3.svg" alt="RR dual processor"></p>',64),z={render:function(e,t){const s=(0,n.up)("DownloadPDF-component"),z=(0,n.up)("DocumentCover-component"),R=(0,n.up)("RouterLink"),B=(0,n.up)("OutboundLink");return(0,n.wg)(),(0,n.iD)(n.HY,null,[(0,n.Wm)(s),(0,n.Wm)(z,{titulo:"1.3. Procesos en el So"}),a,(0,n._)("nav",o,[(0,n._)("ul",null,[(0,n._)("li",null,[(0,n.Wm)(R,{to:"#_1-3-1-el-kernel-del-so"},{default:(0,n.w5)((()=>[l])),_:1})]),(0,n._)("li",null,[(0,n.Wm)(R,{to:"#_1-3-2-control-de-procesos-en-gnu-linux"},{default:(0,n.w5)((()=>[r])),_:1}),(0,n._)("ul",null,[(0,n._)("li",null,[(0,n.Wm)(R,{to:"#comandos-para-saber-el-pid-de-los-procesos"},{default:(0,n.w5)((()=>[i])),_:1})]),(0,n._)("li",null,[(0,n.Wm)(R,{to:"#comandos-para-ver-los-procesos-activos"},{default:(0,n.w5)((()=>[c])),_:1})]),(0,n._)("li",null,[(0,n.Wm)(R,{to:"#control-de-procesos"},{default:(0,n.w5)((()=>[d])),_:1})])])]),(0,n._)("li",null,[(0,n.Wm)(R,{to:"#_1-3-3-estados-de-un-proceso"},{default:(0,n.w5)((()=>[p])),_:1})]),(0,n._)("li",null,[(0,n.Wm)(R,{to:"#_1-3-4-planificacion-de-procesos"},{default:(0,n.w5)((()=>[u])),_:1})]),(0,n._)("li",null,[(0,n.Wm)(R,{to:"#_1-3-5-algoritmos-de-planificacion-de-procesos"},{default:(0,n.w5)((()=>[m])),_:1}),(0,n._)("ul",null,[(0,n._)("li",null,[(0,n.Wm)(R,{to:"#fcfs-first-come-first-served"},{default:(0,n.w5)((()=>[g])),_:1})]),(0,n._)("li",null,[(0,n.Wm)(R,{to:"#sjf-shortest-job-first"},{default:(0,n.w5)((()=>[y])),_:1})]),(0,n._)("li",null,[(0,n.Wm)(R,{to:"#planificacion-por-prioridad"},{default:(0,n.w5)((()=>[x])),_:1})]),(0,n._)("li",null,[(0,n.Wm)(R,{to:"#round-robin"},{default:(0,n.w5)((()=>[b])),_:1})]),(0,n._)("li",null,[(0,n.Wm)(R,{to:"#procesos-con-operaciones-de-e-s-o-bloqueos"},{default:(0,n.w5)((()=>[h])),_:1})])])])])]),A,(0,n._)("div",v,[f,(0,n._)("p",null,[(0,n._)("a",E,[q,(0,n.Wm)(B)])])]),P,(0,n._)("div",S,[_,(0,n._)("p",null,[(0,n._)("a",j,[k,(0,n.Wm)(B)])])]),C,(0,n._)("div",F,[D,(0,n._)("p",null,[(0,n._)("a",U,[w,(0,n.Wm)(B)])])]),T],64)}}}}]);